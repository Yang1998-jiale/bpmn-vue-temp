var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
import { nextTick, toRaw, defineComponent, reactive, onMounted, watch, onBeforeUnmount, openBlock, createElementBlock, createElementVNode } from "vue";
function e$3(e2, t2) {
  t2 && (e2.super_ = t2, e2.prototype = Object.create(t2.prototype, { constructor: { value: e2, enumerable: false, writable: true, configurable: true } }));
}
function createCommonjsModule(fn, module) {
  return module = { exports: {} }, fn(module, module.exports), module.exports;
}
var hat_1 = createCommonjsModule(function(module) {
  var hat = module.exports = function(bits, base) {
    if (!base)
      base = 16;
    if (bits === void 0)
      bits = 128;
    if (bits <= 0)
      return "0";
    var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
    for (var i2 = 2; digits === Infinity; i2 *= 2) {
      digits = Math.log(Math.pow(2, bits / i2)) / Math.log(base) * i2;
    }
    var rem = digits - Math.floor(digits);
    var res = "";
    for (var i2 = 0; i2 < Math.floor(digits); i2++) {
      var x2 = Math.floor(Math.random() * base).toString(base);
      res = x2 + res;
    }
    if (rem) {
      var b2 = Math.pow(base, rem);
      var x2 = Math.floor(Math.random() * b2).toString(base);
      res = x2 + res;
    }
    var parsed = parseInt(res, base);
    if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {
      return hat(bits, base);
    } else
      return res;
  };
  hat.rack = function(bits, base, expandBy) {
    var fn = function(data) {
      var iters = 0;
      do {
        if (iters++ > 10) {
          if (expandBy)
            bits += expandBy;
          else
            throw new Error("too many ID collisions, use more bits");
        }
        var id = hat(bits, base);
      } while (Object.hasOwnProperty.call(hats, id));
      hats[id] = data;
      return id;
    };
    var hats = fn.hats = {};
    fn.get = function(id) {
      return fn.hats[id];
    };
    fn.set = function(id, value) {
      fn.hats[id] = value;
      return fn;
    };
    fn.bits = bits || 128;
    fn.base = base || 16;
    return fn;
  };
});
function Ids(seed) {
  if (!(this instanceof Ids)) {
    return new Ids(seed);
  }
  seed = seed || [128, 36, 1];
  this._seed = seed.length ? hat_1.rack(seed[0], seed[1], seed[2]) : seed;
}
Ids.prototype.next = function(element) {
  return this._seed(element || true);
};
Ids.prototype.nextPrefixed = function(prefix2, element) {
  var id;
  do {
    id = prefix2 + this.next(true);
  } while (this.assigned(id));
  this.claim(id, element);
  return id;
};
Ids.prototype.claim = function(id, element) {
  this._seed.set(id, element || true);
};
Ids.prototype.assigned = function(id) {
  return this._seed.get(id) || false;
};
Ids.prototype.unclaim = function(id) {
  delete this._seed.hats[id];
};
Ids.prototype.clear = function() {
  var hats = this._seed.hats, id;
  for (id in hats) {
    this.unclaim(id);
  }
};
function flatten(arr) {
  return Array.prototype.concat.apply([], arr);
}
const nativeToString$1 = Object.prototype.toString;
const nativeHasOwnProperty$1 = Object.prototype.hasOwnProperty;
function isUndefined$2(obj) {
  return obj === void 0;
}
function isDefined(obj) {
  return obj !== void 0;
}
function isNil(obj) {
  return obj == null;
}
function isArray$3(obj) {
  return nativeToString$1.call(obj) === "[object Array]";
}
function isObject(obj) {
  return nativeToString$1.call(obj) === "[object Object]";
}
function isNumber(obj) {
  return nativeToString$1.call(obj) === "[object Number]";
}
function isFunction(obj) {
  const tag = nativeToString$1.call(obj);
  return tag === "[object Function]" || tag === "[object AsyncFunction]" || tag === "[object GeneratorFunction]" || tag === "[object AsyncGeneratorFunction]" || tag === "[object Proxy]";
}
function isString(obj) {
  return nativeToString$1.call(obj) === "[object String]";
}
function ensureArray(obj) {
  if (isArray$3(obj)) {
    return;
  }
  throw new Error("must supply array");
}
function has$1(target, key) {
  return nativeHasOwnProperty$1.call(target, key);
}
function find(collection, matcher) {
  const matchFn = toMatcher(matcher);
  let match;
  forEach$1(collection, function(val, key) {
    if (matchFn(val, key)) {
      match = val;
      return false;
    }
  });
  return match;
}
function findIndex(collection, matcher) {
  const matchFn = toMatcher(matcher);
  let idx = isArray$3(collection) ? -1 : void 0;
  forEach$1(collection, function(val, key) {
    if (matchFn(val, key)) {
      idx = key;
      return false;
    }
  });
  return idx;
}
function filter(collection, matcher) {
  const matchFn = toMatcher(matcher);
  let result = [];
  forEach$1(collection, function(val, key) {
    if (matchFn(val, key)) {
      result.push(val);
    }
  });
  return result;
}
function forEach$1(collection, iterator) {
  let val, result;
  if (isUndefined$2(collection)) {
    return;
  }
  const convertKey = isArray$3(collection) ? toNum$1 : identity$1;
  for (let key in collection) {
    if (has$1(collection, key)) {
      val = collection[key];
      result = iterator(val, convertKey(key));
      if (result === false) {
        return val;
      }
    }
  }
}
function without(arr, matcher) {
  if (isUndefined$2(arr)) {
    return [];
  }
  ensureArray(arr);
  const matchFn = toMatcher(matcher);
  return arr.filter(function(el, idx) {
    return !matchFn(el, idx);
  });
}
function reduce(collection, iterator, result) {
  forEach$1(collection, function(value, idx) {
    result = iterator(result, value, idx);
  });
  return result;
}
function every(collection, matcher) {
  return !!reduce(collection, function(matches2, val, key) {
    return matches2 && matcher(val, key);
  }, true);
}
function some(collection, matcher) {
  return !!find(collection, matcher);
}
function map$1(collection, fn) {
  let result = [];
  forEach$1(collection, function(val, key) {
    result.push(fn(val, key));
  });
  return result;
}
function keys(collection) {
  return collection && Object.keys(collection) || [];
}
function size(collection) {
  return keys(collection).length;
}
function values(collection) {
  return map$1(collection, (val) => val);
}
function groupBy(collection, extractor, grouped = {}) {
  extractor = toExtractor(extractor);
  forEach$1(collection, function(val) {
    let discriminator = extractor(val) || "_";
    let group = grouped[discriminator];
    if (!group) {
      group = grouped[discriminator] = [];
    }
    group.push(val);
  });
  return grouped;
}
function uniqueBy(extractor, ...collections) {
  extractor = toExtractor(extractor);
  let grouped = {};
  forEach$1(collections, (c2) => groupBy(c2, extractor, grouped));
  let result = map$1(grouped, function(val, key) {
    return val[0];
  });
  return result;
}
const unionBy = uniqueBy;
function sortBy(collection, extractor) {
  extractor = toExtractor(extractor);
  let sorted = [];
  forEach$1(collection, function(value, key) {
    let disc = extractor(value, key);
    let entry = {
      d: disc,
      v: value
    };
    for (var idx = 0; idx < sorted.length; idx++) {
      let { d: d2 } = sorted[idx];
      if (disc < d2) {
        sorted.splice(idx, 0, entry);
        return;
      }
    }
    sorted.push(entry);
  });
  return map$1(sorted, (e2) => e2.v);
}
function matchPattern(pattern) {
  return function(el) {
    return every(pattern, function(val, key) {
      return el[key] === val;
    });
  };
}
function toExtractor(extractor) {
  return isFunction(extractor) ? extractor : (e2) => {
    return e2[extractor];
  };
}
function toMatcher(matcher) {
  return isFunction(matcher) ? matcher : (e2) => {
    return e2 === matcher;
  };
}
function identity$1(arg) {
  return arg;
}
function toNum$1(arg) {
  return Number(arg);
}
function debounce(fn, timeout) {
  let timer;
  let lastArgs;
  let lastThis;
  let lastNow;
  function fire(force) {
    let now = Date.now();
    let scheduledDiff = force ? 0 : lastNow + timeout - now;
    if (scheduledDiff > 0) {
      return schedule(scheduledDiff);
    }
    fn.apply(lastThis, lastArgs);
    clear2();
  }
  function schedule(timeout2) {
    timer = setTimeout(fire, timeout2);
  }
  function clear2() {
    if (timer) {
      clearTimeout(timer);
    }
    timer = lastNow = lastArgs = lastThis = void 0;
  }
  function flush() {
    if (timer) {
      fire(true);
    }
    clear2();
  }
  function callback(...args) {
    lastNow = Date.now();
    lastArgs = args;
    lastThis = this;
    if (!timer) {
      schedule(timeout);
    }
  }
  callback.flush = flush;
  callback.cancel = clear2;
  return callback;
}
function bind$2(fn, target) {
  return fn.bind(target);
}
function assign$1(target, ...others) {
  return Object.assign(target, ...others);
}
function set$2(target, path, value) {
  let currentTarget = target;
  forEach$1(path, function(key, idx) {
    if (typeof key !== "number" && typeof key !== "string") {
      throw new Error("illegal key type: " + typeof key + ". Key should be of type number or string.");
    }
    if (key === "constructor") {
      throw new Error("illegal key: constructor");
    }
    if (key === "__proto__") {
      throw new Error("illegal key: __proto__");
    }
    let nextKey = path[idx + 1];
    let nextTarget = currentTarget[key];
    if (isDefined(nextKey) && isNil(nextTarget)) {
      nextTarget = currentTarget[key] = isNaN(+nextKey) ? {} : [];
    }
    if (isUndefined$2(nextKey)) {
      if (isUndefined$2(value)) {
        delete currentTarget[key];
      } else {
        currentTarget[key] = value;
      }
    } else {
      currentTarget = nextTarget;
    }
  });
  return target;
}
function pick(target, properties) {
  let result = {};
  let obj = Object(target);
  forEach$1(properties, function(prop) {
    if (prop in obj) {
      result[prop] = target[prop];
    }
  });
  return result;
}
function omit(target, properties) {
  let result = {};
  let obj = Object(target);
  forEach$1(obj, function(prop, key) {
    if (properties.indexOf(key) === -1) {
      result[key] = prop;
    }
  });
  return result;
}
function _mergeNamespaces(n2, m2) {
  m2.forEach(function(e2) {
    e2 && typeof e2 !== "string" && !Array.isArray(e2) && Object.keys(e2).forEach(function(k2) {
      if (k2 !== "default" && !(k2 in n2)) {
        var d2 = Object.getOwnPropertyDescriptor(e2, k2);
        Object.defineProperty(n2, k2, d2.get ? d2 : {
          enumerable: true,
          get: function() {
            return e2[k2];
          }
        });
      }
    });
  });
  return Object.freeze(n2);
}
const nativeToString = Object.prototype.toString;
const nativeHasOwnProperty = Object.prototype.hasOwnProperty;
function isUndefined$1(obj) {
  return obj === void 0;
}
function isArray$2(obj) {
  return nativeToString.call(obj) === "[object Array]";
}
function has(target, key) {
  return nativeHasOwnProperty.call(target, key);
}
function forEach(collection, iterator) {
  let val, result;
  if (isUndefined$1(collection)) {
    return;
  }
  const convertKey = isArray$2(collection) ? toNum : identity;
  for (let key in collection) {
    if (has(collection, key)) {
      val = collection[key];
      result = iterator(val, convertKey(key));
      if (result === false) {
        return val;
      }
    }
  }
}
function identity(arg) {
  return arg;
}
function toNum(arg) {
  return Number(arg);
}
function assign(element, ...styleSources) {
  const target = element.style;
  forEach(styleSources, function(style) {
    if (!style) {
      return;
    }
    forEach(style, function(value, key) {
      target[key] = value;
    });
  });
  return element;
}
function attr$1(el, name2, val) {
  if (arguments.length == 2) {
    return el.getAttribute(name2);
  }
  if (val === null) {
    return el.removeAttribute(name2);
  }
  el.setAttribute(name2, val);
  return el;
}
const toString$1 = Object.prototype.toString;
function classes$1(el) {
  return new ClassList$1(el);
}
function ClassList$1(el) {
  if (!el || !el.nodeType) {
    throw new Error("A DOM element reference is required");
  }
  this.el = el;
  this.list = el.classList;
}
ClassList$1.prototype.add = function(name2) {
  this.list.add(name2);
  return this;
};
ClassList$1.prototype.remove = function(name2) {
  if ("[object RegExp]" == toString$1.call(name2)) {
    return this.removeMatching(name2);
  }
  this.list.remove(name2);
  return this;
};
ClassList$1.prototype.removeMatching = function(re) {
  const arr = this.array();
  for (let i2 = 0; i2 < arr.length; i2++) {
    if (re.test(arr[i2])) {
      this.remove(arr[i2]);
    }
  }
  return this;
};
ClassList$1.prototype.toggle = function(name2, force) {
  if ("undefined" !== typeof force) {
    if (force !== this.list.toggle(name2, force)) {
      this.list.toggle(name2);
    }
  } else {
    this.list.toggle(name2);
  }
  return this;
};
ClassList$1.prototype.array = function() {
  return Array.from(this.list);
};
ClassList$1.prototype.has = ClassList$1.prototype.contains = function(name2) {
  return this.list.contains(name2);
};
function clear$1(el) {
  var c2;
  while (el.childNodes.length) {
    c2 = el.childNodes[0];
    el.removeChild(c2);
  }
  return el;
}
function matches(element, selector) {
  return element && typeof element.matches === "function" && element.matches(selector);
}
function closest(element, selector, checkYourSelf) {
  var currentElem = checkYourSelf ? element : element.parentNode;
  while (currentElem && currentElem.nodeType !== document.DOCUMENT_NODE && currentElem.nodeType !== document.DOCUMENT_FRAGMENT_NODE) {
    if (matches(currentElem, selector)) {
      return currentElem;
    }
    currentElem = currentElem.parentNode;
  }
  return matches(currentElem, selector) ? currentElem : null;
}
var componentEvent = {};
var bind$1, unbind$1, prefix$7;
function detect() {
  bind$1 = window.addEventListener ? "addEventListener" : "attachEvent";
  unbind$1 = window.removeEventListener ? "removeEventListener" : "detachEvent";
  prefix$7 = bind$1 !== "addEventListener" ? "on" : "";
}
var bind_1 = componentEvent.bind = function(el, type, fn, capture) {
  if (!bind$1)
    detect();
  el[bind$1](prefix$7 + type, fn, capture || false);
  return fn;
};
var unbind_1 = componentEvent.unbind = function(el, type, fn, capture) {
  if (!unbind$1)
    detect();
  el[unbind$1](prefix$7 + type, fn, capture || false);
  return fn;
};
var event = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  bind: bind_1,
  unbind: unbind_1,
  "default": componentEvent
}, [componentEvent]);
var forceCaptureEvents = ["focus", "blur"];
function bind(el, selector, type, fn, capture) {
  if (forceCaptureEvents.indexOf(type) !== -1) {
    capture = true;
  }
  return event.bind(el, type, function(e2) {
    var target = e2.target || e2.srcElement;
    e2.delegateTarget = closest(target, selector, true);
    if (e2.delegateTarget) {
      fn.call(el, e2);
    }
  }, capture);
}
function unbind(el, type, fn, capture) {
  if (forceCaptureEvents.indexOf(type) !== -1) {
    capture = true;
  }
  return event.unbind(el, type, fn, capture);
}
var delegate = {
  bind,
  unbind
};
var domify = parse$1;
var innerHTMLBug = false;
var bugTestDiv;
if (typeof document !== "undefined") {
  bugTestDiv = document.createElement("div");
  bugTestDiv.innerHTML = '  <link/><table></table><a href="/a">a</a><input type="checkbox"/>';
  innerHTMLBug = !bugTestDiv.getElementsByTagName("link").length;
  bugTestDiv = void 0;
}
var map = {
  legend: [1, "<fieldset>", "</fieldset>"],
  tr: [2, "<table><tbody>", "</tbody></table>"],
  col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
  // for script/link/style tags to work in IE6-8, you have to wrap
  // in a div with a non-whitespace character in front, ha!
  _default: innerHTMLBug ? [1, "X<div>", "</div>"] : [0, "", ""]
};
map.td = map.th = [3, "<table><tbody><tr>", "</tr></tbody></table>"];
map.option = map.optgroup = [1, '<select multiple="multiple">', "</select>"];
map.thead = map.tbody = map.colgroup = map.caption = map.tfoot = [1, "<table>", "</table>"];
map.polyline = map.ellipse = map.polygon = map.circle = map.text = map.line = map.path = map.rect = map.g = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">', "</svg>"];
function parse$1(html, doc) {
  if ("string" != typeof html)
    throw new TypeError("String expected");
  if (!doc)
    doc = document;
  var m2 = /<([\w:]+)/.exec(html);
  if (!m2)
    return doc.createTextNode(html);
  html = html.replace(/^\s+|\s+$/g, "");
  var tag = m2[1];
  if (tag == "body") {
    var el = doc.createElement("html");
    el.innerHTML = html;
    return el.removeChild(el.lastChild);
  }
  var wrap = Object.prototype.hasOwnProperty.call(map, tag) ? map[tag] : map._default;
  var depth = wrap[0];
  var prefix2 = wrap[1];
  var suffix = wrap[2];
  var el = doc.createElement("div");
  el.innerHTML = prefix2 + html + suffix;
  while (depth--)
    el = el.lastChild;
  if (el.firstChild == el.lastChild) {
    return el.removeChild(el.firstChild);
  }
  var fragment = doc.createDocumentFragment();
  while (el.firstChild) {
    fragment.appendChild(el.removeChild(el.firstChild));
  }
  return fragment;
}
var domify$1 = domify;
function query(selector, el) {
  el = el || document;
  return el.querySelector(selector);
}
function all(selector, el) {
  el = el || document;
  return el.querySelectorAll(selector);
}
function remove$2(el) {
  el.parentNode && el.parentNode.removeChild(el);
}
function ensureImported(element, target) {
  if (element.ownerDocument !== target.ownerDocument) {
    try {
      return target.ownerDocument.importNode(element, true);
    } catch (e2) {
    }
  }
  return element;
}
function appendTo(element, target) {
  return target.appendChild(ensureImported(element, target));
}
function append(target, node2) {
  appendTo(node2, target);
  return target;
}
var LENGTH_ATTR = 2;
var CSS_PROPERTIES = {
  "alignment-baseline": 1,
  "baseline-shift": 1,
  "clip": 1,
  "clip-path": 1,
  "clip-rule": 1,
  "color": 1,
  "color-interpolation": 1,
  "color-interpolation-filters": 1,
  "color-profile": 1,
  "color-rendering": 1,
  "cursor": 1,
  "direction": 1,
  "display": 1,
  "dominant-baseline": 1,
  "enable-background": 1,
  "fill": 1,
  "fill-opacity": 1,
  "fill-rule": 1,
  "filter": 1,
  "flood-color": 1,
  "flood-opacity": 1,
  "font": 1,
  "font-family": 1,
  "font-size": LENGTH_ATTR,
  "font-size-adjust": 1,
  "font-stretch": 1,
  "font-style": 1,
  "font-variant": 1,
  "font-weight": 1,
  "glyph-orientation-horizontal": 1,
  "glyph-orientation-vertical": 1,
  "image-rendering": 1,
  "kerning": 1,
  "letter-spacing": 1,
  "lighting-color": 1,
  "marker": 1,
  "marker-end": 1,
  "marker-mid": 1,
  "marker-start": 1,
  "mask": 1,
  "opacity": 1,
  "overflow": 1,
  "pointer-events": 1,
  "shape-rendering": 1,
  "stop-color": 1,
  "stop-opacity": 1,
  "stroke": 1,
  "stroke-dasharray": 1,
  "stroke-dashoffset": 1,
  "stroke-linecap": 1,
  "stroke-linejoin": 1,
  "stroke-miterlimit": 1,
  "stroke-opacity": 1,
  "stroke-width": LENGTH_ATTR,
  "text-anchor": 1,
  "text-decoration": 1,
  "text-rendering": 1,
  "unicode-bidi": 1,
  "visibility": 1,
  "word-spacing": 1,
  "writing-mode": 1
};
function getAttribute(node2, name2) {
  if (CSS_PROPERTIES[name2]) {
    return node2.style[name2];
  } else {
    return node2.getAttributeNS(null, name2);
  }
}
function setAttribute(node2, name2, value) {
  var hyphenated = name2.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  var type = CSS_PROPERTIES[hyphenated];
  if (type) {
    if (type === LENGTH_ATTR && typeof value === "number") {
      value = String(value) + "px";
    }
    node2.style[hyphenated] = value;
  } else {
    node2.setAttributeNS(null, name2, value);
  }
}
function setAttributes(node2, attrs) {
  var names = Object.keys(attrs), i2, name2;
  for (i2 = 0, name2; name2 = names[i2]; i2++) {
    setAttribute(node2, name2, attrs[name2]);
  }
}
function attr(node2, name2, value) {
  if (typeof name2 === "string") {
    if (value !== void 0) {
      setAttribute(node2, name2, value);
    } else {
      return getAttribute(node2, name2);
    }
  } else {
    setAttributes(node2, name2);
  }
  return node2;
}
const toString = Object.prototype.toString;
function classes(el) {
  return new ClassList(el);
}
function ClassList(el) {
  if (!el || !el.nodeType) {
    throw new Error("A DOM element reference is required");
  }
  this.el = el;
  this.list = el.classList;
}
ClassList.prototype.add = function(name2) {
  this.list.add(name2);
  return this;
};
ClassList.prototype.remove = function(name2) {
  if ("[object RegExp]" == toString.call(name2)) {
    return this.removeMatching(name2);
  }
  this.list.remove(name2);
  return this;
};
ClassList.prototype.removeMatching = function(re) {
  const arr = this.array();
  for (let i2 = 0; i2 < arr.length; i2++) {
    if (re.test(arr[i2])) {
      this.remove(arr[i2]);
    }
  }
  return this;
};
ClassList.prototype.toggle = function(name2, force) {
  if ("undefined" !== typeof force) {
    if (force !== this.list.toggle(name2, force)) {
      this.list.toggle(name2);
    }
  } else {
    this.list.toggle(name2);
  }
  return this;
};
ClassList.prototype.array = function() {
  return Array.from(this.list);
};
ClassList.prototype.has = ClassList.prototype.contains = function(name2) {
  return this.list.contains(name2);
};
function remove$1(element) {
  var parent = element.parentNode;
  if (parent) {
    parent.removeChild(element);
  }
  return element;
}
function clear(element) {
  var child;
  while (child = element.firstChild) {
    remove$1(child);
  }
  return element;
}
function clone$1(element) {
  return element.cloneNode(true);
}
var ns = {
  svg: "http://www.w3.org/2000/svg"
};
var SVG_START = '<svg xmlns="' + ns.svg + '"';
function parse(svg) {
  var unwrap = false;
  if (svg.substring(0, 4) === "<svg") {
    if (svg.indexOf(ns.svg) === -1) {
      svg = SVG_START + svg.substring(4);
    }
  } else {
    svg = SVG_START + ">" + svg + "</svg>";
    unwrap = true;
  }
  var parsed = parseDocument(svg);
  if (!unwrap) {
    return parsed;
  }
  var fragment = document.createDocumentFragment();
  var parent = parsed.firstChild;
  while (parent.firstChild) {
    fragment.appendChild(parent.firstChild);
  }
  return fragment;
}
function parseDocument(svg) {
  var parser;
  parser = new DOMParser();
  parser.async = false;
  return parser.parseFromString(svg, "text/xml");
}
function create$1(name2, attrs) {
  var element;
  if (name2.charAt(0) === "<") {
    element = parse(name2).firstChild;
    element = document.importNode(element, true);
  } else {
    element = document.createElementNS(ns.svg, name2);
  }
  if (attrs) {
    attr(element, attrs);
  }
  return element;
}
var node = null;
function getNode() {
  if (node === null) {
    node = create$1("svg");
  }
  return node;
}
function extend$1(object, props) {
  var i2, k2, keys2 = Object.keys(props);
  for (i2 = 0; k2 = keys2[i2]; i2++) {
    object[k2] = props[k2];
  }
  return object;
}
function createMatrix(a2, b2, c2, d2, e2, f2) {
  var matrix = getNode().createSVGMatrix();
  switch (arguments.length) {
    case 0:
      return matrix;
    case 1:
      return extend$1(matrix, a2);
    case 6:
      return extend$1(matrix, {
        a: a2,
        b: b2,
        c: c2,
        d: d2,
        e: e2,
        f: f2
      });
  }
}
function createTransform(matrix) {
  if (matrix) {
    return getNode().createSVGTransformFromMatrix(matrix);
  } else {
    return getNode().createSVGTransform();
  }
}
var TEXT_ENTITIES = /([&<>]{1})/g;
var ATTR_ENTITIES = /([\n\r"]{1})/g;
var ENTITY_REPLACEMENT = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "'"
};
function escape$1(str, pattern) {
  function replaceFn(match, entity) {
    return ENTITY_REPLACEMENT[entity] || entity;
  }
  return str.replace(pattern, replaceFn);
}
function serialize(node2, output) {
  var i2, len, attrMap, attrNode, childNodes;
  switch (node2.nodeType) {
    case 3:
      output.push(escape$1(node2.textContent, TEXT_ENTITIES));
      break;
    case 1:
      output.push("<", node2.tagName);
      if (node2.hasAttributes()) {
        attrMap = node2.attributes;
        for (i2 = 0, len = attrMap.length; i2 < len; ++i2) {
          attrNode = attrMap.item(i2);
          output.push(" ", attrNode.name, '="', escape$1(attrNode.value, ATTR_ENTITIES), '"');
        }
      }
      if (node2.hasChildNodes()) {
        output.push(">");
        childNodes = node2.childNodes;
        for (i2 = 0, len = childNodes.length; i2 < len; ++i2) {
          serialize(childNodes.item(i2), output);
        }
        output.push("</", node2.tagName, ">");
      } else {
        output.push("/>");
      }
      break;
    case 8:
      output.push("<!--", escape$1(node2.nodeValue, TEXT_ENTITIES), "-->");
      break;
    case 4:
      output.push("<![CDATA[", node2.nodeValue, "]]>");
      break;
    default:
      throw new Error("unable to handle node " + node2.nodeType);
  }
  return output;
}
function set$1(element, svg) {
  var parsed = parse(svg);
  clear(element);
  if (!svg) {
    return;
  }
  if (!isFragment(parsed)) {
    parsed = parsed.documentElement;
  }
  var nodes = slice$1(parsed.childNodes);
  for (var i2 = 0; i2 < nodes.length; i2++) {
    appendTo(nodes[i2], element);
  }
}
function get(element) {
  var child = element.firstChild, output = [];
  while (child) {
    serialize(child, output);
    child = child.nextSibling;
  }
  return output.join("");
}
function isFragment(node2) {
  return node2.nodeName === "#document-fragment";
}
function innerSVG(element, svg) {
  if (svg !== void 0) {
    try {
      set$1(element, svg);
    } catch (e2) {
      throw new Error("error parsing SVG: " + e2.message);
    }
    return element;
  } else {
    return get(element);
  }
}
function slice$1(arr) {
  return Array.prototype.slice.call(arr);
}
function wrapMatrix(transformList, transform2) {
  if (transform2 instanceof SVGMatrix) {
    return transformList.createSVGTransformFromMatrix(transform2);
  }
  return transform2;
}
function setTransforms(transformList, transforms) {
  var i2, t2;
  transformList.clear();
  for (i2 = 0; t2 = transforms[i2]; i2++) {
    transformList.appendItem(wrapMatrix(transformList, t2));
  }
}
function transform$1(node2, transforms) {
  var transformList = node2.transform.baseVal;
  if (transforms) {
    if (!Array.isArray(transforms)) {
      transforms = [transforms];
    }
    setTransforms(transformList, transforms);
  }
  return transformList.consolidate();
}
const CLASS_PATTERN = /^class[ {]/;
function isClass(fn) {
  return CLASS_PATTERN.test(fn.toString());
}
function isArray$1(obj) {
  return Array.isArray(obj);
}
function hasOwnProp(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function annotate(...args) {
  if (args.length === 1 && isArray$1(args[0])) {
    args = args[0];
  }
  args = [...args];
  const fn = args.pop();
  fn.$inject = args;
  return fn;
}
const CONSTRUCTOR_ARGS = /constructor\s*[^(]*\(\s*([^)]*)\)/m;
const FN_ARGS = /^(?:async\s+)?(?:function\s*[^(]*)?(?:\(\s*([^)]*)\)|(\w+))/m;
const FN_ARG = /\/\*([^*]*)\*\//m;
function parseAnnotations(fn) {
  if (typeof fn !== "function") {
    throw new Error(`Cannot annotate "${fn}". Expected a function!`);
  }
  const match = fn.toString().match(isClass(fn) ? CONSTRUCTOR_ARGS : FN_ARGS);
  if (!match) {
    return [];
  }
  const args = match[1] || match[2];
  return args && args.split(",").map((arg) => {
    const argMatch = arg.match(FN_ARG);
    return (argMatch && argMatch[1] || arg).trim();
  }) || [];
}
function Injector(modules, _parent) {
  const parent = _parent || /** @type InjectorContext */
  {
    get: function(name2, strict) {
      currentlyResolving.push(name2);
      if (strict === false) {
        return null;
      } else {
        throw error2(`No provider for "${name2}"!`);
      }
    }
  };
  const currentlyResolving = [];
  const providers = this._providers = Object.create(parent._providers || null);
  const instances = this._instances = /* @__PURE__ */ Object.create(null);
  const self2 = instances.injector = this;
  const error2 = function(msg) {
    const stack = currentlyResolving.join(" -> ");
    currentlyResolving.length = 0;
    return new Error(stack ? `${msg} (Resolving: ${stack})` : msg);
  };
  function get2(name2, strict) {
    if (!providers[name2] && name2.includes(".")) {
      const parts = name2.split(".");
      let pivot = get2(
        /** @type { string } */
        parts.shift()
      );
      while (parts.length) {
        pivot = pivot[
          /** @type { string } */
          parts.shift()
        ];
      }
      return pivot;
    }
    if (hasOwnProp(instances, name2)) {
      return instances[name2];
    }
    if (hasOwnProp(providers, name2)) {
      if (currentlyResolving.indexOf(name2) !== -1) {
        currentlyResolving.push(name2);
        throw error2("Cannot resolve circular dependency!");
      }
      currentlyResolving.push(name2);
      instances[name2] = providers[name2][0](providers[name2][1]);
      currentlyResolving.pop();
      return instances[name2];
    }
    return parent.get(name2, strict);
  }
  function fnDef(fn, locals) {
    if (typeof locals === "undefined") {
      locals = {};
    }
    if (typeof fn !== "function") {
      if (isArray$1(fn)) {
        fn = annotate(fn.slice());
      } else {
        throw error2(`Cannot invoke "${fn}". Expected a function!`);
      }
    }
    const inject = fn.$inject || parseAnnotations(fn);
    const dependencies = inject.map((dep) => {
      if (hasOwnProp(locals, dep)) {
        return locals[dep];
      } else {
        return get2(dep);
      }
    });
    return {
      fn,
      dependencies
    };
  }
  function instantiate(type) {
    const {
      fn,
      dependencies
    } = fnDef(type);
    const Constructor = Function.prototype.bind.call(fn, null, ...dependencies);
    return new Constructor();
  }
  function invoke(func, context, locals) {
    const {
      fn,
      dependencies
    } = fnDef(func, locals);
    return fn.apply(context, dependencies);
  }
  function createPrivateInjectorFactory(childInjector) {
    return annotate((key) => childInjector.get(key));
  }
  function createChild(modules2, forceNewInstances) {
    if (forceNewInstances && forceNewInstances.length) {
      const fromParentModule = /* @__PURE__ */ Object.create(null);
      const matchedScopes = /* @__PURE__ */ Object.create(null);
      const privateInjectorsCache = [];
      const privateChildInjectors = [];
      const privateChildFactories = [];
      let provider;
      let cacheIdx;
      let privateChildInjector;
      let privateChildInjectorFactory;
      for (let name2 in providers) {
        provider = providers[name2];
        if (forceNewInstances.indexOf(name2) !== -1) {
          if (provider[2] === "private") {
            cacheIdx = privateInjectorsCache.indexOf(provider[3]);
            if (cacheIdx === -1) {
              privateChildInjector = provider[3].createChild([], forceNewInstances);
              privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);
              privateInjectorsCache.push(provider[3]);
              privateChildInjectors.push(privateChildInjector);
              privateChildFactories.push(privateChildInjectorFactory);
              fromParentModule[name2] = [privateChildInjectorFactory, name2, "private", privateChildInjector];
            } else {
              fromParentModule[name2] = [privateChildFactories[cacheIdx], name2, "private", privateChildInjectors[cacheIdx]];
            }
          } else {
            fromParentModule[name2] = [provider[2], provider[1]];
          }
          matchedScopes[name2] = true;
        }
        if ((provider[2] === "factory" || provider[2] === "type") && provider[1].$scope) {
          forceNewInstances.forEach((scope) => {
            if (provider[1].$scope.indexOf(scope) !== -1) {
              fromParentModule[name2] = [provider[2], provider[1]];
              matchedScopes[scope] = true;
            }
          });
        }
      }
      forceNewInstances.forEach((scope) => {
        if (!matchedScopes[scope]) {
          throw new Error('No provider for "' + scope + '". Cannot use provider from the parent!');
        }
      });
      modules2.unshift(fromParentModule);
    }
    return new Injector(modules2, self2);
  }
  const factoryMap = {
    factory: invoke,
    type: instantiate,
    value: function(value) {
      return value;
    }
  };
  function createInitializer(moduleDefinition, injector) {
    const initializers = moduleDefinition.__init__ || [];
    return function() {
      initializers.forEach((initializer) => {
        if (typeof initializer === "string") {
          injector.get(initializer);
        } else {
          injector.invoke(initializer);
        }
      });
    };
  }
  function loadModule(moduleDefinition) {
    const moduleExports = moduleDefinition.__exports__;
    if (moduleExports) {
      const nestedModules = moduleDefinition.__modules__;
      const clonedModule = Object.keys(moduleDefinition).reduce((clonedModule2, key) => {
        if (key !== "__exports__" && key !== "__modules__" && key !== "__init__" && key !== "__depends__") {
          clonedModule2[key] = moduleDefinition[key];
        }
        return clonedModule2;
      }, /* @__PURE__ */ Object.create(null));
      const childModules = (nestedModules || []).concat(clonedModule);
      const privateInjector = createChild(childModules);
      const getFromPrivateInjector = annotate(function(key) {
        return privateInjector.get(key);
      });
      moduleExports.forEach(function(key) {
        providers[key] = [getFromPrivateInjector, key, "private", privateInjector];
      });
      const initializers = (moduleDefinition.__init__ || []).slice();
      initializers.unshift(function() {
        privateInjector.init();
      });
      moduleDefinition = Object.assign({}, moduleDefinition, {
        __init__: initializers
      });
      return createInitializer(moduleDefinition, privateInjector);
    }
    Object.keys(moduleDefinition).forEach(function(key) {
      if (key === "__init__" || key === "__depends__") {
        return;
      }
      const typeDeclaration = (
        /** @type { TypedDeclaration } */
        moduleDefinition[key]
      );
      if (typeDeclaration[2] === "private") {
        providers[key] = typeDeclaration;
        return;
      }
      const type = typeDeclaration[0];
      const value = typeDeclaration[1];
      providers[key] = [factoryMap[type], arrayUnwrap(type, value), type];
    });
    return createInitializer(moduleDefinition, self2);
  }
  function resolveDependencies(moduleDefinitions, moduleDefinition) {
    if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {
      return moduleDefinitions;
    }
    moduleDefinitions = (moduleDefinition.__depends__ || []).reduce(resolveDependencies, moduleDefinitions);
    if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {
      return moduleDefinitions;
    }
    return moduleDefinitions.concat(moduleDefinition);
  }
  function bootstrap2(moduleDefinitions) {
    const initializers = moduleDefinitions.reduce(resolveDependencies, []).map(loadModule);
    let initialized = false;
    return function() {
      if (initialized) {
        return;
      }
      initialized = true;
      initializers.forEach((initializer) => initializer());
    };
  }
  this.get = get2;
  this.invoke = invoke;
  this.instantiate = instantiate;
  this.createChild = createChild;
  this.init = bootstrap2(modules);
}
function arrayUnwrap(type, value) {
  if (type !== "value" && isArray$1(value)) {
    value = annotate(value.slice());
  }
  return value;
}
var DEFAULT_RENDER_PRIORITY$1 = 1e3;
function BaseRenderer(eventBus, renderPriority) {
  var self2 = this;
  renderPriority = renderPriority || DEFAULT_RENDER_PRIORITY$1;
  eventBus.on(["render.shape", "render.connection"], renderPriority, function(evt, context) {
    var type = evt.type, element = context.element, visuals = context.gfx, attrs = context.attrs;
    if (self2.canRender(element)) {
      if (type === "render.shape") {
        return self2.drawShape(visuals, element, attrs);
      } else {
        return self2.drawConnection(visuals, element, attrs);
      }
    }
  });
  eventBus.on(["render.getShapePath", "render.getConnectionPath"], renderPriority, function(evt, element) {
    if (self2.canRender(element)) {
      if (evt.type === "render.getShapePath") {
        return self2.getShapePath(element);
      } else {
        return self2.getConnectionPath(element);
      }
    }
  });
}
BaseRenderer.prototype.canRender = function(element) {
};
BaseRenderer.prototype.drawShape = function(visuals, shape) {
};
BaseRenderer.prototype.drawConnection = function(visuals, connection) {
};
BaseRenderer.prototype.getShapePath = function(shape) {
};
BaseRenderer.prototype.getConnectionPath = function(connection) {
};
function componentsToPath(elements) {
  return elements.flat().join(",").replace(/,?([A-z]),?/g, "$1");
}
function move(point) {
  return ["M", point.x, point.y];
}
function lineTo(point) {
  return ["L", point.x, point.y];
}
function curveTo(p1, p2, p3) {
  return ["C", p1.x, p1.y, p2.x, p2.y, p3.x, p3.y];
}
function drawPath(waypoints, cornerRadius) {
  const pointCount = waypoints.length;
  const path = [move(waypoints[0])];
  for (let i2 = 1; i2 < pointCount; i2++) {
    const pointBefore = waypoints[i2 - 1];
    const point = waypoints[i2];
    const pointAfter = waypoints[i2 + 1];
    if (!pointAfter || !cornerRadius) {
      path.push(lineTo(point));
      continue;
    }
    const effectiveRadius = Math.min(
      cornerRadius,
      vectorLength$1(point.x - pointBefore.x, point.y - pointBefore.y),
      vectorLength$1(pointAfter.x - point.x, pointAfter.y - point.y)
    );
    if (!effectiveRadius) {
      path.push(lineTo(point));
      continue;
    }
    const beforePoint = getPointAtLength(point, pointBefore, effectiveRadius);
    const beforePoint2 = getPointAtLength(point, pointBefore, effectiveRadius * 0.5);
    const afterPoint = getPointAtLength(point, pointAfter, effectiveRadius);
    const afterPoint2 = getPointAtLength(point, pointAfter, effectiveRadius * 0.5);
    path.push(lineTo(beforePoint));
    path.push(curveTo(beforePoint2, afterPoint2, afterPoint));
  }
  return path;
}
function getPointAtLength(start, end, length2) {
  const deltaX = end.x - start.x;
  const deltaY = end.y - start.y;
  const totalLength = vectorLength$1(deltaX, deltaY);
  const percent = length2 / totalLength;
  return {
    x: start.x + deltaX * percent,
    y: start.y + deltaY * percent
  };
}
function vectorLength$1(x2, y2) {
  return Math.sqrt(Math.pow(x2, 2) + Math.pow(y2, 2));
}
function createLine(points, attrs, radius) {
  if (isNumber(attrs)) {
    radius = attrs;
    attrs = null;
  }
  if (!attrs) {
    attrs = {};
  }
  const line = create$1("path", attrs);
  if (isNumber(radius)) {
    line.dataset.cornerRadius = String(radius);
  }
  return updateLine(line, points);
}
function updateLine(gfx, points) {
  const cornerRadius = parseInt(gfx.dataset.cornerRadius, 10) || 0;
  attr(gfx, {
    d: componentsToPath(drawPath(points, cornerRadius))
  });
  return gfx;
}
function getParents$1(elements) {
  return filter(elements, function(element) {
    return !find(elements, function(e2) {
      return e2 !== element && getParent$1(element, e2);
    });
  });
}
function getParent$1(element, parent) {
  if (!parent) {
    return;
  }
  if (element === parent) {
    return parent;
  }
  if (!element.parent) {
    return;
  }
  return getParent$1(element.parent, parent);
}
function add$1(elements, element, unique) {
  var canAdd = !unique || elements.indexOf(element) === -1;
  if (canAdd) {
    elements.push(element);
  }
  return canAdd;
}
function eachElement(elements, fn, depth) {
  depth = depth || 0;
  if (!isArray$3(elements)) {
    elements = [elements];
  }
  forEach$1(elements, function(s2, i2) {
    var filter2 = fn(s2, i2, depth);
    if (isArray$3(filter2) && filter2.length) {
      eachElement(filter2, fn, depth + 1);
    }
  });
}
function selfAndChildren(elements, unique, maxDepth) {
  var result = [], processedChildren = [];
  eachElement(elements, function(element, i2, depth) {
    add$1(result, element, unique);
    var children = element.children;
    if (maxDepth === -1 || depth < maxDepth) {
      if (children && add$1(processedChildren, children, unique)) {
        return children;
      }
    }
  });
  return result;
}
function selfAndAllChildren(elements, allowDuplicates) {
  return selfAndChildren(elements, !allowDuplicates, -1);
}
function getClosure(elements, isTopLevel, closure) {
  if (isUndefined$2(isTopLevel)) {
    isTopLevel = true;
  }
  if (isObject(isTopLevel)) {
    closure = isTopLevel;
    isTopLevel = true;
  }
  closure = closure || {};
  var allShapes = copyObject(closure.allShapes), allConnections = copyObject(closure.allConnections), enclosedElements = copyObject(closure.enclosedElements), enclosedConnections = copyObject(closure.enclosedConnections);
  var topLevel = copyObject(
    closure.topLevel,
    isTopLevel && groupBy(elements, function(e2) {
      return e2.id;
    })
  );
  function handleConnection(c2) {
    if (topLevel[c2.source.id] && topLevel[c2.target.id]) {
      topLevel[c2.id] = [c2];
    }
    if (allShapes[c2.source.id] && allShapes[c2.target.id]) {
      enclosedConnections[c2.id] = enclosedElements[c2.id] = c2;
    }
    allConnections[c2.id] = c2;
  }
  function handleElement(element) {
    enclosedElements[element.id] = element;
    if (element.waypoints) {
      enclosedConnections[element.id] = allConnections[element.id] = element;
    } else {
      allShapes[element.id] = element;
      forEach$1(element.incoming, handleConnection);
      forEach$1(element.outgoing, handleConnection);
      return element.children;
    }
  }
  eachElement(elements, handleElement);
  return {
    allShapes,
    allConnections,
    topLevel,
    enclosedConnections,
    enclosedElements
  };
}
function getBBox(elements, stopRecursion) {
  stopRecursion = !!stopRecursion;
  if (!isArray$3(elements)) {
    elements = [elements];
  }
  var minX, minY, maxX, maxY;
  forEach$1(elements, function(element) {
    var bbox = element;
    if (element.waypoints && !stopRecursion) {
      bbox = getBBox(element.waypoints, true);
    }
    var x2 = bbox.x, y2 = bbox.y, height = bbox.height || 0, width = bbox.width || 0;
    if (x2 < minX || minX === void 0) {
      minX = x2;
    }
    if (y2 < minY || minY === void 0) {
      minY = y2;
    }
    if (x2 + width > maxX || maxX === void 0) {
      maxX = x2 + width;
    }
    if (y2 + height > maxY || maxY === void 0) {
      maxY = y2 + height;
    }
  });
  return {
    x: minX,
    y: minY,
    height: maxY - minY,
    width: maxX - minX
  };
}
function getEnclosedElements(elements, bbox) {
  var filteredElements = {};
  forEach$1(elements, function(element) {
    var e2 = element;
    if (e2.waypoints) {
      e2 = getBBox(e2);
    }
    if (!isNumber(bbox.y) && e2.x > bbox.x) {
      filteredElements[element.id] = element;
    }
    if (!isNumber(bbox.x) && e2.y > bbox.y) {
      filteredElements[element.id] = element;
    }
    if (e2.x > bbox.x && e2.y > bbox.y) {
      if (isNumber(bbox.width) && isNumber(bbox.height) && e2.width + e2.x < bbox.width + bbox.x && e2.height + e2.y < bbox.height + bbox.y) {
        filteredElements[element.id] = element;
      } else if (!isNumber(bbox.width) || !isNumber(bbox.height)) {
        filteredElements[element.id] = element;
      }
    }
  });
  return filteredElements;
}
function getType(element) {
  if ("waypoints" in element) {
    return "connection";
  }
  if ("x" in element) {
    return "shape";
  }
  return "root";
}
function isFrameElement$1(element) {
  return !!(element && element.isFrame);
}
function copyObject(src1, src2) {
  return assign$1({}, src1 || {}, src2 || {});
}
var DEFAULT_RENDER_PRIORITY = 1;
function DefaultRenderer(eventBus, styles) {
  BaseRenderer.call(this, eventBus, DEFAULT_RENDER_PRIORITY);
  this.CONNECTION_STYLE = styles.style(["no-fill"], { strokeWidth: 5, stroke: "fuchsia" });
  this.SHAPE_STYLE = styles.style({ fill: "white", stroke: "fuchsia", strokeWidth: 2 });
  this.FRAME_STYLE = styles.style(["no-fill"], { stroke: "fuchsia", strokeDasharray: 4, strokeWidth: 2 });
}
e$3(DefaultRenderer, BaseRenderer);
DefaultRenderer.prototype.canRender = function() {
  return true;
};
DefaultRenderer.prototype.drawShape = function drawShape(visuals, element, attrs) {
  var rect = create$1("rect");
  attr(rect, {
    x: 0,
    y: 0,
    width: element.width || 0,
    height: element.height || 0
  });
  if (isFrameElement$1(element)) {
    attr(rect, assign$1({}, this.FRAME_STYLE, attrs || {}));
  } else {
    attr(rect, assign$1({}, this.SHAPE_STYLE, attrs || {}));
  }
  append(visuals, rect);
  return rect;
};
DefaultRenderer.prototype.drawConnection = function drawConnection(visuals, connection, attrs) {
  var line = createLine(connection.waypoints, assign$1({}, this.CONNECTION_STYLE, attrs || {}));
  append(visuals, line);
  return line;
};
DefaultRenderer.prototype.getShapePath = function getShapePath(shape) {
  var x2 = shape.x, y2 = shape.y, width = shape.width, height = shape.height;
  var shapePath = [
    ["M", x2, y2],
    ["l", width, 0],
    ["l", 0, height],
    ["l", -width, 0],
    ["z"]
  ];
  return componentsToPath(shapePath);
};
DefaultRenderer.prototype.getConnectionPath = function getConnectionPath(connection) {
  var waypoints = connection.waypoints;
  var idx, point, connectionPath = [];
  for (idx = 0; point = waypoints[idx]; idx++) {
    point = point.original || point;
    connectionPath.push([idx === 0 ? "M" : "L", point.x, point.y]);
  }
  return componentsToPath(connectionPath);
};
DefaultRenderer.$inject = ["eventBus", "styles"];
function Styles() {
  var defaultTraits = {
    "no-fill": {
      fill: "none"
    },
    "no-border": {
      strokeOpacity: 0
    },
    "no-events": {
      pointerEvents: "none"
    }
  };
  var self2 = this;
  this.cls = function(className, traits, additionalAttrs) {
    var attrs = this.style(traits, additionalAttrs);
    return assign$1(attrs, { "class": className });
  };
  this.style = function(traits, additionalAttrs) {
    if (!isArray$3(traits) && !additionalAttrs) {
      additionalAttrs = traits;
      traits = [];
    }
    var attrs = reduce(traits, function(attrs2, t2) {
      return assign$1(attrs2, defaultTraits[t2] || {});
    }, {});
    return additionalAttrs ? assign$1(attrs, additionalAttrs) : attrs;
  };
  this.computeStyle = function(custom, traits, defaultStyles) {
    if (!isArray$3(traits)) {
      defaultStyles = traits;
      traits = [];
    }
    return self2.style(traits || [], assign$1({}, defaultStyles, custom || {}));
  };
}
const DrawModule$1 = {
  __init__: ["defaultRenderer"],
  defaultRenderer: ["type", DefaultRenderer],
  styles: ["type", Styles]
};
function remove(collection, element) {
  if (!collection || !element) {
    return -1;
  }
  var idx = collection.indexOf(element);
  if (idx !== -1) {
    collection.splice(idx, 1);
  }
  return idx;
}
function add(collection, element, idx) {
  if (!collection || !element) {
    return;
  }
  if (typeof idx !== "number") {
    idx = -1;
  }
  var currentIdx = collection.indexOf(element);
  if (currentIdx !== -1) {
    if (currentIdx === idx) {
      return;
    } else {
      if (idx !== -1) {
        collection.splice(currentIdx, 1);
      } else {
        return;
      }
    }
  }
  if (idx !== -1) {
    collection.splice(idx, 0, element);
  } else {
    collection.push(element);
  }
}
function indexOf(collection, element) {
  if (!collection || !element) {
    return -1;
  }
  return collection.indexOf(element);
}
function pointDistance(a2, b2) {
  if (!a2 || !b2) {
    return -1;
  }
  return Math.sqrt(
    Math.pow(a2.x - b2.x, 2) + Math.pow(a2.y - b2.y, 2)
  );
}
function pointsOnLine(p2, q2, r2, accuracy) {
  if (typeof accuracy === "undefined") {
    accuracy = 5;
  }
  if (!p2 || !q2 || !r2) {
    return false;
  }
  var val = (q2.x - p2.x) * (r2.y - p2.y) - (q2.y - p2.y) * (r2.x - p2.x), dist = pointDistance(p2, q2);
  return Math.abs(val / dist) <= accuracy;
}
var ALIGNED_THRESHOLD = 2;
function pointsAligned(a2, b2) {
  var points = Array.from(arguments).flat();
  const axisMap = {
    "x": "v",
    "y": "h"
  };
  for (const [axis, orientation] of Object.entries(axisMap)) {
    if (pointsAlignedOnAxis(axis, points)) {
      return orientation;
    }
  }
  return false;
}
function pointsAlignedOnAxis(axis, points) {
  const referencePoint = points[0];
  return every(points, function(point) {
    return Math.abs(referencePoint[axis] - point[axis]) <= ALIGNED_THRESHOLD;
  });
}
function pointInRect(p2, rect, tolerance) {
  tolerance = tolerance || 0;
  return p2.x > rect.x - tolerance && p2.y > rect.y - tolerance && p2.x < rect.x + rect.width + tolerance && p2.y < rect.y + rect.height + tolerance;
}
function getMidPoint(p2, q2) {
  return {
    x: Math.round(p2.x + (q2.x - p2.x) / 2),
    y: Math.round(p2.y + (q2.y - p2.y) / 2)
  };
}
var p2s = /,?([a-z]),?/gi, toFloat = parseFloat, math = Math, PI = math.PI, mmin = math.min, mmax = math.max, pow = math.pow, abs$7 = math.abs, pathCommand = /([a-z])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?[\s]*,?[\s]*)+)/ig, pathValues = /(-?\d*\.?\d*(?:e[-+]?\d+)?)[\s]*,?[\s]*/ig;
var isArray = Array.isArray || function(o2) {
  return o2 instanceof Array;
};
function hasProperty(obj, property) {
  return Object.prototype.hasOwnProperty.call(obj, property);
}
function clone(obj) {
  if (typeof obj == "function" || Object(obj) !== obj) {
    return obj;
  }
  var res = new obj.constructor();
  for (var key in obj) {
    if (hasProperty(obj, key)) {
      res[key] = clone(obj[key]);
    }
  }
  return res;
}
function repush(array, item) {
  for (var i2 = 0, ii = array.length; i2 < ii; i2++)
    if (array[i2] === item) {
      return array.push(array.splice(i2, 1)[0]);
    }
}
function cacher(f2) {
  function newf() {
    var arg = Array.prototype.slice.call(arguments, 0), args = arg.join("␀"), cache = newf.cache = newf.cache || {}, count = newf.count = newf.count || [];
    if (hasProperty(cache, args)) {
      repush(count, args);
      return cache[args];
    }
    count.length >= 1e3 && delete cache[count.shift()];
    count.push(args);
    cache[args] = f2(...arguments);
    return cache[args];
  }
  return newf;
}
function parsePathString(pathString) {
  if (!pathString) {
    return null;
  }
  var pth = paths(pathString);
  if (pth.arr) {
    return clone(pth.arr);
  }
  var paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 }, data = [];
  if (isArray(pathString) && isArray(pathString[0])) {
    data = clone(pathString);
  }
  if (!data.length) {
    String(pathString).replace(pathCommand, function(a2, b2, c2) {
      var params = [], name2 = b2.toLowerCase();
      c2.replace(pathValues, function(a3, b3) {
        b3 && params.push(+b3);
      });
      if (name2 == "m" && params.length > 2) {
        data.push([b2, ...params.splice(0, 2)]);
        name2 = "l";
        b2 = b2 == "m" ? "l" : "L";
      }
      while (params.length >= paramCounts[name2]) {
        data.push([b2, ...params.splice(0, paramCounts[name2])]);
        if (!paramCounts[name2]) {
          break;
        }
      }
    });
  }
  data.toString = paths.toString;
  pth.arr = clone(data);
  return data;
}
function paths(ps) {
  var p2 = paths.ps = paths.ps || {};
  if (p2[ps]) {
    p2[ps].sleep = 100;
  } else {
    p2[ps] = {
      sleep: 100
    };
  }
  setTimeout(function() {
    for (var key in p2) {
      if (hasProperty(p2, key) && key != ps) {
        p2[key].sleep--;
        !p2[key].sleep && delete p2[key];
      }
    }
  });
  return p2[ps];
}
function rectBBox(x2, y2, width, height) {
  if (arguments.length === 1) {
    y2 = x2.y;
    width = x2.width;
    height = x2.height;
    x2 = x2.x;
  }
  return {
    x: x2,
    y: y2,
    width,
    height,
    x2: x2 + width,
    y2: y2 + height
  };
}
function pathToString() {
  return this.join(",").replace(p2s, "$1");
}
function pathClone(pathArray) {
  var res = clone(pathArray);
  res.toString = pathToString;
  return res;
}
function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t2) {
  var t1 = 1 - t2, t13 = pow(t1, 3), t12 = pow(t1, 2), t22 = t2 * t2, t3 = t22 * t2, x2 = t13 * p1x + t12 * 3 * t2 * c1x + t1 * 3 * t2 * t2 * c2x + t3 * p2x, y2 = t13 * p1y + t12 * 3 * t2 * c1y + t1 * 3 * t2 * t2 * c2y + t3 * p2y;
  return {
    x: fixError(x2),
    y: fixError(y2)
  };
}
function bezierBBox(points) {
  var bbox = curveBBox(...points);
  return rectBBox(
    bbox.x0,
    bbox.y0,
    bbox.x1 - bbox.x0,
    bbox.y1 - bbox.y0
  );
}
function isPointInsideBBox$2(bbox, x2, y2) {
  return x2 >= bbox.x && x2 <= bbox.x + bbox.width && y2 >= bbox.y && y2 <= bbox.y + bbox.height;
}
function isBBoxIntersect(bbox1, bbox2) {
  bbox1 = rectBBox(bbox1);
  bbox2 = rectBBox(bbox2);
  return isPointInsideBBox$2(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox$2(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox$2(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox$2(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox$2(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox$2(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox$2(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox$2(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
}
function base3(t2, p1, p2, p3, p4) {
  var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4, t22 = t2 * t1 + 6 * p1 - 12 * p2 + 6 * p3;
  return t2 * t22 - 3 * p1 + 3 * p2;
}
function bezlen(x1, y1, x2, y2, x3, y3, x4, y4, z2) {
  if (z2 == null) {
    z2 = 1;
  }
  z2 = z2 > 1 ? 1 : z2 < 0 ? 0 : z2;
  var z22 = z2 / 2, n2 = 12, Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816], Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472], sum = 0;
  for (var i2 = 0; i2 < n2; i2++) {
    var ct = z22 * Tvalues[i2] + z22, xbase = base3(ct, x1, x2, x3, x4), ybase = base3(ct, y1, y2, y3, y4), comb = xbase * xbase + ybase * ybase;
    sum += Cvalues[i2] * math.sqrt(comb);
  }
  return z22 * sum;
}
function intersectLines(x1, y1, x2, y2, x3, y3, x4, y4) {
  if (mmax(x1, x2) < mmin(x3, x4) || mmin(x1, x2) > mmax(x3, x4) || mmax(y1, y2) < mmin(y3, y4) || mmin(y1, y2) > mmax(y3, y4)) {
    return;
  }
  var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4), ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4), denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
  if (!denominator) {
    return;
  }
  var px = fixError(nx / denominator), py = fixError(ny / denominator), px2 = +px.toFixed(2), py2 = +py.toFixed(2);
  if (px2 < +mmin(x1, x2).toFixed(2) || px2 > +mmax(x1, x2).toFixed(2) || px2 < +mmin(x3, x4).toFixed(2) || px2 > +mmax(x3, x4).toFixed(2) || py2 < +mmin(y1, y2).toFixed(2) || py2 > +mmax(y1, y2).toFixed(2) || py2 < +mmin(y3, y4).toFixed(2) || py2 > +mmax(y3, y4).toFixed(2)) {
    return;
  }
  return { x: px, y: py };
}
function fixError(number) {
  return Math.round(number * 1e11) / 1e11;
}
function findBezierIntersections(bez1, bez2, justCount) {
  var bbox1 = bezierBBox(bez1), bbox2 = bezierBBox(bez2);
  if (!isBBoxIntersect(bbox1, bbox2)) {
    return justCount ? 0 : [];
  }
  var l1 = bezlen(...bez1), l2 = bezlen(...bez2), n1 = isLine(bez1) ? 1 : ~~(l1 / 5) || 1, n2 = isLine(bez2) ? 1 : ~~(l2 / 5) || 1, dots1 = [], dots2 = [], xy = {}, res = justCount ? 0 : [];
  for (var i2 = 0; i2 < n1 + 1; i2++) {
    var p2 = findDotsAtSegment(...bez1, i2 / n1);
    dots1.push({ x: p2.x, y: p2.y, t: i2 / n1 });
  }
  for (i2 = 0; i2 < n2 + 1; i2++) {
    p2 = findDotsAtSegment(...bez2, i2 / n2);
    dots2.push({ x: p2.x, y: p2.y, t: i2 / n2 });
  }
  for (i2 = 0; i2 < n1; i2++) {
    for (var j2 = 0; j2 < n2; j2++) {
      var di = dots1[i2], di1 = dots1[i2 + 1], dj = dots2[j2], dj1 = dots2[j2 + 1], ci = abs$7(di1.x - di.x) < 0.01 ? "y" : "x", cj = abs$7(dj1.x - dj.x) < 0.01 ? "y" : "x", is2 = intersectLines(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y), key;
      if (is2) {
        key = is2.x.toFixed(9) + "#" + is2.y.toFixed(9);
        if (xy[key]) {
          continue;
        }
        xy[key] = true;
        var t1 = di.t + abs$7((is2[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t), t2 = dj.t + abs$7((is2[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
        if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
          if (justCount) {
            res++;
          } else {
            res.push({
              x: is2.x,
              y: is2.y,
              t1,
              t2
            });
          }
        }
      }
    }
  }
  return res;
}
function findPathIntersections(path1, path2, justCount) {
  path1 = pathToCurve(path1);
  path2 = pathToCurve(path2);
  var x1, y1, x2, y2, x1m, y1m, x2m, y2m, bez1, bez2, res = justCount ? 0 : [];
  for (var i2 = 0, ii = path1.length; i2 < ii; i2++) {
    var pi = path1[i2];
    if (pi[0] == "M") {
      x1 = x1m = pi[1];
      y1 = y1m = pi[2];
    } else {
      if (pi[0] == "C") {
        bez1 = [x1, y1, ...pi.slice(1)];
        x1 = bez1[6];
        y1 = bez1[7];
      } else {
        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
        x1 = x1m;
        y1 = y1m;
      }
      for (var j2 = 0, jj = path2.length; j2 < jj; j2++) {
        var pj = path2[j2];
        if (pj[0] == "M") {
          x2 = x2m = pj[1];
          y2 = y2m = pj[2];
        } else {
          if (pj[0] == "C") {
            bez2 = [x2, y2, ...pj.slice(1)];
            x2 = bez2[6];
            y2 = bez2[7];
          } else {
            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
            x2 = x2m;
            y2 = y2m;
          }
          var intr = findBezierIntersections(bez1, bez2, justCount);
          if (justCount) {
            res += intr;
          } else {
            for (var k2 = 0, kk = intr.length; k2 < kk; k2++) {
              intr[k2].segment1 = i2;
              intr[k2].segment2 = j2;
              intr[k2].bez1 = bez1;
              intr[k2].bez2 = bez2;
            }
            res = res.concat(intr);
          }
        }
      }
    }
  }
  return res;
}
function pathToAbsolute(pathArray) {
  var pth = paths(pathArray);
  if (pth.abs) {
    return pathClone(pth.abs);
  }
  if (!isArray(pathArray) || !isArray(pathArray && pathArray[0])) {
    pathArray = parsePathString(pathArray);
  }
  if (!pathArray || !pathArray.length) {
    return [["M", 0, 0]];
  }
  var res = [], x2 = 0, y2 = 0, mx = 0, my = 0, start = 0, pa0;
  if (pathArray[0][0] == "M") {
    x2 = +pathArray[0][1];
    y2 = +pathArray[0][2];
    mx = x2;
    my = y2;
    start++;
    res[0] = ["M", x2, y2];
  }
  for (var r2, pa, i2 = start, ii = pathArray.length; i2 < ii; i2++) {
    res.push(r2 = []);
    pa = pathArray[i2];
    pa0 = pa[0];
    if (pa0 != pa0.toUpperCase()) {
      r2[0] = pa0.toUpperCase();
      switch (r2[0]) {
        case "A":
          r2[1] = pa[1];
          r2[2] = pa[2];
          r2[3] = pa[3];
          r2[4] = pa[4];
          r2[5] = pa[5];
          r2[6] = +pa[6] + x2;
          r2[7] = +pa[7] + y2;
          break;
        case "V":
          r2[1] = +pa[1] + y2;
          break;
        case "H":
          r2[1] = +pa[1] + x2;
          break;
        case "M":
          mx = +pa[1] + x2;
          my = +pa[2] + y2;
        default:
          for (var j2 = 1, jj = pa.length; j2 < jj; j2++) {
            r2[j2] = +pa[j2] + (j2 % 2 ? x2 : y2);
          }
      }
    } else {
      for (var k2 = 0, kk = pa.length; k2 < kk; k2++) {
        r2[k2] = pa[k2];
      }
    }
    pa0 = pa0.toUpperCase();
    switch (r2[0]) {
      case "Z":
        x2 = +mx;
        y2 = +my;
        break;
      case "H":
        x2 = r2[1];
        break;
      case "V":
        y2 = r2[1];
        break;
      case "M":
        mx = r2[r2.length - 2];
        my = r2[r2.length - 1];
      default:
        x2 = r2[r2.length - 2];
        y2 = r2[r2.length - 1];
    }
  }
  res.toString = pathToString;
  pth.abs = pathClone(res);
  return res;
}
function isLine(bez) {
  return bez[0] === bez[2] && bez[1] === bez[3] && bez[4] === bez[6] && bez[5] === bez[7];
}
function lineToCurve(x1, y1, x2, y2) {
  return [
    x1,
    y1,
    x2,
    y2,
    x2,
    y2
  ];
}
function qubicToCurve(x1, y1, ax, ay, x2, y2) {
  var _13 = 1 / 3, _23 = 2 / 3;
  return [
    _13 * x1 + _23 * ax,
    _13 * y1 + _23 * ay,
    _13 * x2 + _23 * ax,
    _13 * y2 + _23 * ay,
    x2,
    y2
  ];
}
function arcToCurve(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) {
  var _120 = PI * 120 / 180, rad = PI / 180 * (+angle || 0), res = [], xy, rotate2 = cacher(function(x4, y4, rad2) {
    var X = x4 * math.cos(rad2) - y4 * math.sin(rad2), Y = x4 * math.sin(rad2) + y4 * math.cos(rad2);
    return { x: X, y: Y };
  });
  if (!recursive) {
    xy = rotate2(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotate2(x2, y2, -rad);
    x2 = xy.x;
    y2 = xy.y;
    var x3 = (x1 - x2) / 2, y3 = (y1 - y2) / 2;
    var h2 = x3 * x3 / (rx * rx) + y3 * y3 / (ry * ry);
    if (h2 > 1) {
      h2 = math.sqrt(h2);
      rx = h2 * rx;
      ry = h2 * ry;
    }
    var rx2 = rx * rx, ry2 = ry * ry, k2 = (large_arc_flag == sweep_flag ? -1 : 1) * math.sqrt(abs$7((rx2 * ry2 - rx2 * y3 * y3 - ry2 * x3 * x3) / (rx2 * y3 * y3 + ry2 * x3 * x3))), cx = k2 * rx * y3 / ry + (x1 + x2) / 2, cy = k2 * -ry * x3 / rx + (y1 + y2) / 2, f1 = math.asin(((y1 - cy) / ry).toFixed(9)), f2 = math.asin(((y2 - cy) / ry).toFixed(9));
    f1 = x1 < cx ? PI - f1 : f1;
    f2 = x2 < cx ? PI - f2 : f2;
    f1 < 0 && (f1 = PI * 2 + f1);
    f2 < 0 && (f2 = PI * 2 + f2);
    if (sweep_flag && f1 > f2) {
      f1 = f1 - PI * 2;
    }
    if (!sweep_flag && f2 > f1) {
      f2 = f2 - PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }
  var df = f2 - f1;
  if (abs$7(df) > _120) {
    var f2old = f2, x2old = x2, y2old = y2;
    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * math.cos(f2);
    y2 = cy + ry * math.sin(f2);
    res = arcToCurve(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
  }
  df = f2 - f1;
  var c1 = math.cos(f1), s1 = math.sin(f1), c2 = math.cos(f2), s2 = math.sin(f2), t2 = math.tan(df / 4), hx = 4 / 3 * rx * t2, hy = 4 / 3 * ry * t2, m1 = [x1, y1], m2 = [x1 + hx * s1, y1 - hy * c1], m3 = [x2 + hx * s2, y2 - hy * c2], m4 = [x2, y2];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];
  if (recursive) {
    return [m2, m3, m4].concat(res);
  } else {
    res = [m2, m3, m4].concat(res).join().split(",");
    var newres = [];
    for (var i2 = 0, ii = res.length; i2 < ii; i2++) {
      newres[i2] = i2 % 2 ? rotate2(res[i2 - 1], res[i2], rad).y : rotate2(res[i2], res[i2 + 1], rad).x;
    }
    return newres;
  }
}
function curveBBox(x0, y0, x1, y1, x2, y2, x3, y3) {
  var tvalues = [], bounds = [[], []], a2, b2, c2, t2, t1, t22, b2ac, sqrtb2ac;
  for (var i2 = 0; i2 < 2; ++i2) {
    if (i2 == 0) {
      b2 = 6 * x0 - 12 * x1 + 6 * x2;
      a2 = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
      c2 = 3 * x1 - 3 * x0;
    } else {
      b2 = 6 * y0 - 12 * y1 + 6 * y2;
      a2 = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
      c2 = 3 * y1 - 3 * y0;
    }
    if (abs$7(a2) < 1e-12) {
      if (abs$7(b2) < 1e-12) {
        continue;
      }
      t2 = -c2 / b2;
      if (0 < t2 && t2 < 1) {
        tvalues.push(t2);
      }
      continue;
    }
    b2ac = b2 * b2 - 4 * c2 * a2;
    sqrtb2ac = math.sqrt(b2ac);
    if (b2ac < 0) {
      continue;
    }
    t1 = (-b2 + sqrtb2ac) / (2 * a2);
    if (0 < t1 && t1 < 1) {
      tvalues.push(t1);
    }
    t22 = (-b2 - sqrtb2ac) / (2 * a2);
    if (0 < t22 && t22 < 1) {
      tvalues.push(t22);
    }
  }
  var j2 = tvalues.length, jlen = j2, mt;
  while (j2--) {
    t2 = tvalues[j2];
    mt = 1 - t2;
    bounds[0][j2] = mt * mt * mt * x0 + 3 * mt * mt * t2 * x1 + 3 * mt * t2 * t2 * x2 + t2 * t2 * t2 * x3;
    bounds[1][j2] = mt * mt * mt * y0 + 3 * mt * mt * t2 * y1 + 3 * mt * t2 * t2 * y2 + t2 * t2 * t2 * y3;
  }
  bounds[0][jlen] = x0;
  bounds[1][jlen] = y0;
  bounds[0][jlen + 1] = x3;
  bounds[1][jlen + 1] = y3;
  bounds[0].length = bounds[1].length = jlen + 2;
  return {
    x0: mmin(...bounds[0]),
    y0: mmin(...bounds[1]),
    x1: mmax(...bounds[0]),
    y1: mmax(...bounds[1])
  };
}
function pathToCurve(path) {
  var pth = paths(path);
  if (pth.curve) {
    return pathClone(pth.curve);
  }
  var curvedPath = pathToAbsolute(path), attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null }, processPath = function(path2, d2, pathCommand3) {
    var nx, ny;
    if (!path2) {
      return ["C", d2.x, d2.y, d2.x, d2.y, d2.x, d2.y];
    }
    !(path2[0] in { T: 1, Q: 1 }) && (d2.qx = d2.qy = null);
    switch (path2[0]) {
      case "M":
        d2.X = path2[1];
        d2.Y = path2[2];
        break;
      case "A":
        path2 = ["C", ...arcToCurve(d2.x, d2.y, ...path2.slice(1))];
        break;
      case "S":
        if (pathCommand3 == "C" || pathCommand3 == "S") {
          nx = d2.x * 2 - d2.bx;
          ny = d2.y * 2 - d2.by;
        } else {
          nx = d2.x;
          ny = d2.y;
        }
        path2 = ["C", nx, ny, ...path2.slice(1)];
        break;
      case "T":
        if (pathCommand3 == "Q" || pathCommand3 == "T") {
          d2.qx = d2.x * 2 - d2.qx;
          d2.qy = d2.y * 2 - d2.qy;
        } else {
          d2.qx = d2.x;
          d2.qy = d2.y;
        }
        path2 = ["C", ...qubicToCurve(d2.x, d2.y, d2.qx, d2.qy, path2[1], path2[2])];
        break;
      case "Q":
        d2.qx = path2[1];
        d2.qy = path2[2];
        path2 = ["C", ...qubicToCurve(d2.x, d2.y, path2[1], path2[2], path2[3], path2[4])];
        break;
      case "L":
        path2 = ["C", ...lineToCurve(d2.x, d2.y, path2[1], path2[2])];
        break;
      case "H":
        path2 = ["C", ...lineToCurve(d2.x, d2.y, path2[1], d2.y)];
        break;
      case "V":
        path2 = ["C", ...lineToCurve(d2.x, d2.y, d2.x, path2[1])];
        break;
      case "Z":
        path2 = ["C", ...lineToCurve(d2.x, d2.y, d2.X, d2.Y)];
        break;
    }
    return path2;
  }, fixArc = function(pp, i3) {
    if (pp[i3].length > 7) {
      pp[i3].shift();
      var pi = pp[i3];
      while (pi.length) {
        pathCommands[i3] = "A";
        pp.splice(i3++, 0, ["C", ...pi.splice(0, 6)]);
      }
      pp.splice(i3, 1);
      ii = curvedPath.length;
    }
  }, pathCommands = [], pfirst = "", pathCommand2 = "";
  for (var i2 = 0, ii = curvedPath.length; i2 < ii; i2++) {
    curvedPath[i2] && (pfirst = curvedPath[i2][0]);
    if (pfirst != "C") {
      pathCommands[i2] = pfirst;
      i2 && (pathCommand2 = pathCommands[i2 - 1]);
    }
    curvedPath[i2] = processPath(curvedPath[i2], attrs, pathCommand2);
    if (pathCommands[i2] != "A" && pfirst == "C")
      pathCommands[i2] = "C";
    fixArc(curvedPath, i2);
    var seg = curvedPath[i2], seglen = seg.length;
    attrs.x = seg[seglen - 2];
    attrs.y = seg[seglen - 1];
    attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
    attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
  }
  pth.curve = pathClone(curvedPath);
  return curvedPath;
}
function isConnection(value) {
  return isObject(value) && has$1(value, "waypoints");
}
function isLabel(value) {
  return isObject(value) && has$1(value, "labelTarget");
}
function roundBounds(bounds) {
  return {
    x: Math.round(bounds.x),
    y: Math.round(bounds.y),
    width: Math.round(bounds.width),
    height: Math.round(bounds.height)
  };
}
function roundPoint(point) {
  return {
    x: Math.round(point.x),
    y: Math.round(point.y)
  };
}
function asTRBL(bounds) {
  return {
    top: bounds.y,
    right: bounds.x + (bounds.width || 0),
    bottom: bounds.y + (bounds.height || 0),
    left: bounds.x
  };
}
function asBounds(trbl) {
  return {
    x: trbl.left,
    y: trbl.top,
    width: trbl.right - trbl.left,
    height: trbl.bottom - trbl.top
  };
}
function getBoundsMid(bounds) {
  return roundPoint({
    x: bounds.x + (bounds.width || 0) / 2,
    y: bounds.y + (bounds.height || 0) / 2
  });
}
function getConnectionMid(connection) {
  var waypoints = connection.waypoints;
  var parts = waypoints.reduce(function(parts2, point, index2) {
    var lastPoint = waypoints[index2 - 1];
    if (lastPoint) {
      var lastPart = parts2[parts2.length - 1];
      var startLength = lastPart && lastPart.endLength || 0;
      var length2 = distance(lastPoint, point);
      parts2.push({
        start: lastPoint,
        end: point,
        startLength,
        endLength: startLength + length2,
        length: length2
      });
    }
    return parts2;
  }, []);
  var totalLength = parts.reduce(function(length2, part) {
    return length2 + part.length;
  }, 0);
  var midLength = totalLength / 2;
  var i2 = 0;
  var midSegment = parts[i2];
  while (midSegment.endLength < midLength) {
    midSegment = parts[++i2];
  }
  var segmentProgress = (midLength - midSegment.startLength) / midSegment.length;
  var midPoint = {
    x: midSegment.start.x + (midSegment.end.x - midSegment.start.x) * segmentProgress,
    y: midSegment.start.y + (midSegment.end.y - midSegment.start.y) * segmentProgress
  };
  return midPoint;
}
function getMid(element) {
  if (isConnection(element)) {
    return getConnectionMid(element);
  }
  return getBoundsMid(element);
}
function getOrientation(rect, reference, padding) {
  padding = padding || 0;
  if (!isObject(padding)) {
    padding = { x: padding, y: padding };
  }
  var rectOrientation = asTRBL(rect), referenceOrientation = asTRBL(reference);
  var top = rectOrientation.bottom + padding.y <= referenceOrientation.top, right = rectOrientation.left - padding.x >= referenceOrientation.right, bottom = rectOrientation.top - padding.y >= referenceOrientation.bottom, left = rectOrientation.right + padding.x <= referenceOrientation.left;
  var vertical = top ? "top" : bottom ? "bottom" : null, horizontal = left ? "left" : right ? "right" : null;
  if (horizontal && vertical) {
    return vertical + "-" + horizontal;
  } else {
    return horizontal || vertical || "intersect";
  }
}
function getElementLineIntersection(elementPath, linePath2, cropStart) {
  var intersections = getIntersections(elementPath, linePath2);
  if (intersections.length === 1) {
    return roundPoint(intersections[0]);
  } else if (intersections.length === 2 && pointDistance(intersections[0], intersections[1]) < 1) {
    return roundPoint(intersections[0]);
  } else if (intersections.length > 1) {
    intersections = sortBy(intersections, function(i2) {
      var distance2 = Math.floor(i2.t2 * 100) || 1;
      distance2 = 100 - distance2;
      distance2 = (distance2 < 10 ? "0" : "") + distance2;
      return i2.segment2 + "#" + distance2;
    });
    return roundPoint(intersections[cropStart ? 0 : intersections.length - 1]);
  }
  return null;
}
function getIntersections(a2, b2) {
  return findPathIntersections(a2, b2);
}
function filterRedundantWaypoints(waypoints) {
  waypoints = waypoints.slice();
  var idx = 0, point, previousPoint, nextPoint;
  while (waypoints[idx]) {
    point = waypoints[idx];
    previousPoint = waypoints[idx - 1];
    nextPoint = waypoints[idx + 1];
    if (pointDistance(point, nextPoint) === 0 || pointsOnLine(previousPoint, nextPoint, point)) {
      waypoints.splice(idx, 1);
    } else {
      idx++;
    }
  }
  return waypoints;
}
function distance(a2, b2) {
  return Math.sqrt(Math.pow(a2.x - b2.x, 2) + Math.pow(a2.y - b2.y, 2));
}
function round$c(number, resolution) {
  return Math.round(number * resolution) / resolution;
}
function ensurePx(number) {
  return isNumber(number) ? number + "px" : number;
}
function findRoot(element) {
  while (element.parent) {
    element = element.parent;
  }
  return element;
}
function createContainer(options) {
  options = assign$1({}, { width: "100%", height: "100%" }, options);
  const container = options.container || document.body;
  const parent = document.createElement("div");
  parent.setAttribute("class", "djs-container djs-parent");
  assign(parent, {
    position: "relative",
    overflow: "hidden",
    width: ensurePx(options.width),
    height: ensurePx(options.height)
  });
  container.appendChild(parent);
  return parent;
}
function createGroup(parent, cls, childIndex) {
  const group = create$1("g");
  classes(group).add(cls);
  const index2 = childIndex !== void 0 ? childIndex : parent.childNodes.length - 1;
  parent.insertBefore(group, parent.childNodes[index2] || null);
  return group;
}
const BASE_LAYER = "base";
const PLANE_LAYER_INDEX = 0;
const UTILITY_LAYER_INDEX = 1;
const REQUIRED_MODEL_ATTRS = {
  shape: ["x", "y", "width", "height"],
  connection: ["waypoints"]
};
function Canvas(config, eventBus, graphicsFactory, elementRegistry) {
  this._eventBus = eventBus;
  this._elementRegistry = elementRegistry;
  this._graphicsFactory = graphicsFactory;
  this._rootsIdx = 0;
  this._layers = {};
  this._planes = [];
  this._rootElement = null;
  this._init(config || {});
}
Canvas.$inject = [
  "config.canvas",
  "eventBus",
  "graphicsFactory",
  "elementRegistry"
];
Canvas.prototype._init = function(config) {
  const eventBus = this._eventBus;
  const container = this._container = createContainer(config);
  const svg = this._svg = create$1("svg");
  attr(svg, { width: "100%", height: "100%" });
  append(container, svg);
  const viewport = this._viewport = createGroup(svg, "viewport");
  if (config.deferUpdate) {
    this._viewboxChanged = debounce(bind$2(this._viewboxChanged, this), 300);
  }
  eventBus.on("diagram.init", () => {
    eventBus.fire("canvas.init", {
      svg,
      viewport
    });
  });
  eventBus.on([
    "shape.added",
    "connection.added",
    "shape.removed",
    "connection.removed",
    "elements.changed",
    "root.set"
  ], () => {
    delete this._cachedViewbox;
  });
  eventBus.on("diagram.destroy", 500, this._destroy, this);
  eventBus.on("diagram.clear", 500, this._clear, this);
};
Canvas.prototype._destroy = function() {
  this._eventBus.fire("canvas.destroy", {
    svg: this._svg,
    viewport: this._viewport
  });
  const parent = this._container.parentNode;
  if (parent) {
    parent.removeChild(this._container);
  }
  delete this._svg;
  delete this._container;
  delete this._layers;
  delete this._planes;
  delete this._rootElement;
  delete this._viewport;
};
Canvas.prototype._clear = function() {
  const allElements = this._elementRegistry.getAll();
  allElements.forEach((element) => {
    const type = getType(element);
    if (type === "root") {
      this.removeRootElement(element);
    } else {
      this._removeElement(element, type);
    }
  });
  this._planes = [];
  this._rootElement = null;
  delete this._cachedViewbox;
};
Canvas.prototype.getDefaultLayer = function() {
  return this.getLayer(BASE_LAYER, PLANE_LAYER_INDEX);
};
Canvas.prototype.getLayer = function(name2, index2) {
  if (!name2) {
    throw new Error("must specify a name");
  }
  let layer = this._layers[name2];
  if (!layer) {
    layer = this._layers[name2] = this._createLayer(name2, index2);
  }
  if (typeof index2 !== "undefined" && layer.index !== index2) {
    throw new Error("layer <" + name2 + "> already created at index <" + index2 + ">");
  }
  return layer.group;
};
Canvas.prototype._getChildIndex = function(index2) {
  return reduce(this._layers, function(childIndex, layer) {
    if (layer.visible && index2 >= layer.index) {
      childIndex++;
    }
    return childIndex;
  }, 0);
};
Canvas.prototype._createLayer = function(name2, index2) {
  if (typeof index2 === "undefined") {
    index2 = UTILITY_LAYER_INDEX;
  }
  const childIndex = this._getChildIndex(index2);
  return {
    group: createGroup(this._viewport, "layer-" + name2, childIndex),
    index: index2,
    visible: true
  };
};
Canvas.prototype.showLayer = function(name2) {
  if (!name2) {
    throw new Error("must specify a name");
  }
  const layer = this._layers[name2];
  if (!layer) {
    throw new Error("layer <" + name2 + "> does not exist");
  }
  const viewport = this._viewport;
  const group = layer.group;
  const index2 = layer.index;
  if (layer.visible) {
    return group;
  }
  const childIndex = this._getChildIndex(index2);
  viewport.insertBefore(group, viewport.childNodes[childIndex] || null);
  layer.visible = true;
  return group;
};
Canvas.prototype.hideLayer = function(name2) {
  if (!name2) {
    throw new Error("must specify a name");
  }
  const layer = this._layers[name2];
  if (!layer) {
    throw new Error("layer <" + name2 + "> does not exist");
  }
  const group = layer.group;
  if (!layer.visible) {
    return group;
  }
  remove$1(group);
  layer.visible = false;
  return group;
};
Canvas.prototype._removeLayer = function(name2) {
  const layer = this._layers[name2];
  if (layer) {
    delete this._layers[name2];
    remove$1(layer.group);
  }
};
Canvas.prototype.getActiveLayer = function() {
  const plane = this._findPlaneForRoot(this.getRootElement());
  if (!plane) {
    return null;
  }
  return plane.layer;
};
Canvas.prototype.findRoot = function(element) {
  if (typeof element === "string") {
    element = this._elementRegistry.get(element);
  }
  if (!element) {
    return;
  }
  const plane = this._findPlaneForRoot(
    findRoot(element)
  ) || {};
  return plane.rootElement;
};
Canvas.prototype.getRootElements = function() {
  return this._planes.map(function(plane) {
    return plane.rootElement;
  });
};
Canvas.prototype._findPlaneForRoot = function(rootElement) {
  return find(this._planes, function(plane) {
    return plane.rootElement === rootElement;
  });
};
Canvas.prototype.getContainer = function() {
  return this._container;
};
Canvas.prototype._updateMarker = function(element, marker, add2) {
  let container;
  if (!element.id) {
    element = this._elementRegistry.get(element);
  }
  container = this._elementRegistry._elements[element.id];
  if (!container) {
    return;
  }
  forEach$1([container.gfx, container.secondaryGfx], function(gfx) {
    if (gfx) {
      if (add2) {
        classes(gfx).add(marker);
      } else {
        classes(gfx).remove(marker);
      }
    }
  });
  this._eventBus.fire("element.marker.update", { element, gfx: container.gfx, marker, add: !!add2 });
};
Canvas.prototype.addMarker = function(element, marker) {
  this._updateMarker(element, marker, true);
};
Canvas.prototype.removeMarker = function(element, marker) {
  this._updateMarker(element, marker, false);
};
Canvas.prototype.hasMarker = function(element, marker) {
  if (!element.id) {
    element = this._elementRegistry.get(element);
  }
  const gfx = this.getGraphics(element);
  return classes(gfx).has(marker);
};
Canvas.prototype.toggleMarker = function(element, marker) {
  if (this.hasMarker(element, marker)) {
    this.removeMarker(element, marker);
  } else {
    this.addMarker(element, marker);
  }
};
Canvas.prototype.getRootElement = function() {
  const rootElement = this._rootElement;
  if (rootElement || this._planes.length) {
    return rootElement;
  }
  return this.setRootElement(this.addRootElement(null));
};
Canvas.prototype.addRootElement = function(rootElement) {
  const idx = this._rootsIdx++;
  if (!rootElement) {
    rootElement = {
      id: "__implicitroot_" + idx,
      children: [],
      isImplicit: true
    };
  }
  const layerName = rootElement.layer = "root-" + idx;
  this._ensureValid("root", rootElement);
  const layer = this.getLayer(layerName, PLANE_LAYER_INDEX);
  this.hideLayer(layerName);
  this._addRoot(rootElement, layer);
  this._planes.push({
    rootElement,
    layer
  });
  return rootElement;
};
Canvas.prototype.removeRootElement = function(rootElement) {
  if (typeof rootElement === "string") {
    rootElement = this._elementRegistry.get(rootElement);
  }
  const plane = this._findPlaneForRoot(rootElement);
  if (!plane) {
    return;
  }
  this._removeRoot(rootElement);
  this._removeLayer(rootElement.layer);
  this._planes = this._planes.filter(function(plane2) {
    return plane2.rootElement !== rootElement;
  });
  if (this._rootElement === rootElement) {
    this._rootElement = null;
  }
  return rootElement;
};
Canvas.prototype.setRootElement = function(rootElement) {
  if (rootElement === this._rootElement) {
    return rootElement;
  }
  let plane;
  if (!rootElement) {
    throw new Error("rootElement required");
  }
  plane = this._findPlaneForRoot(rootElement);
  if (!plane) {
    rootElement = this.addRootElement(rootElement);
  }
  this._setRoot(rootElement);
  return rootElement;
};
Canvas.prototype._removeRoot = function(element) {
  const elementRegistry = this._elementRegistry, eventBus = this._eventBus;
  eventBus.fire("root.remove", { element });
  eventBus.fire("root.removed", { element });
  elementRegistry.remove(element);
};
Canvas.prototype._addRoot = function(element, gfx) {
  const elementRegistry = this._elementRegistry, eventBus = this._eventBus;
  eventBus.fire("root.add", { element });
  elementRegistry.add(element, gfx);
  eventBus.fire("root.added", { element, gfx });
};
Canvas.prototype._setRoot = function(rootElement, layer) {
  const currentRoot = this._rootElement;
  if (currentRoot) {
    this._elementRegistry.updateGraphics(currentRoot, null, true);
    this.hideLayer(currentRoot.layer);
  }
  if (rootElement) {
    if (!layer) {
      layer = this._findPlaneForRoot(rootElement).layer;
    }
    this._elementRegistry.updateGraphics(rootElement, this._svg, true);
    this.showLayer(rootElement.layer);
  }
  this._rootElement = rootElement;
  this._eventBus.fire("root.set", { element: rootElement });
};
Canvas.prototype._ensureValid = function(type, element) {
  if (!element.id) {
    throw new Error("element must have an id");
  }
  if (this._elementRegistry.get(element.id)) {
    throw new Error("element <" + element.id + "> already exists");
  }
  const requiredAttrs = REQUIRED_MODEL_ATTRS[type];
  const valid = every(requiredAttrs, function(attr2) {
    return typeof element[attr2] !== "undefined";
  });
  if (!valid) {
    throw new Error(
      "must supply { " + requiredAttrs.join(", ") + " } with " + type
    );
  }
};
Canvas.prototype._setParent = function(element, parent, parentIndex) {
  add(parent.children, element, parentIndex);
  element.parent = parent;
};
Canvas.prototype._addElement = function(type, element, parent, parentIndex) {
  parent = parent || this.getRootElement();
  const eventBus = this._eventBus, graphicsFactory = this._graphicsFactory;
  this._ensureValid(type, element);
  eventBus.fire(type + ".add", { element, parent });
  this._setParent(element, parent, parentIndex);
  const gfx = graphicsFactory.create(type, element, parentIndex);
  this._elementRegistry.add(element, gfx);
  graphicsFactory.update(type, element, gfx);
  eventBus.fire(type + ".added", { element, gfx });
  return element;
};
Canvas.prototype.addShape = function(shape, parent, parentIndex) {
  return this._addElement("shape", shape, parent, parentIndex);
};
Canvas.prototype.addConnection = function(connection, parent, parentIndex) {
  return this._addElement("connection", connection, parent, parentIndex);
};
Canvas.prototype._removeElement = function(element, type) {
  const elementRegistry = this._elementRegistry, graphicsFactory = this._graphicsFactory, eventBus = this._eventBus;
  element = elementRegistry.get(element.id || element);
  if (!element) {
    return;
  }
  eventBus.fire(type + ".remove", { element });
  graphicsFactory.remove(element);
  remove(element.parent && element.parent.children, element);
  element.parent = null;
  eventBus.fire(type + ".removed", { element });
  elementRegistry.remove(element);
  return element;
};
Canvas.prototype.removeShape = function(shape) {
  return this._removeElement(shape, "shape");
};
Canvas.prototype.removeConnection = function(connection) {
  return this._removeElement(connection, "connection");
};
Canvas.prototype.getGraphics = function(element, secondary) {
  return this._elementRegistry.getGraphics(element, secondary);
};
Canvas.prototype._changeViewbox = function(changeFn) {
  this._eventBus.fire("canvas.viewbox.changing");
  changeFn.apply(this);
  this._cachedViewbox = null;
  this._viewboxChanged();
};
Canvas.prototype._viewboxChanged = function() {
  this._eventBus.fire("canvas.viewbox.changed", { viewbox: this.viewbox() });
};
Canvas.prototype.viewbox = function(box) {
  if (box === void 0 && this._cachedViewbox) {
    return this._cachedViewbox;
  }
  const viewport = this._viewport, outerBox = this.getSize();
  let innerBox, matrix, activeLayer, transform2, scale, x2, y2;
  if (!box) {
    activeLayer = this._rootElement ? this.getActiveLayer() : null;
    innerBox = activeLayer && activeLayer.getBBox() || {};
    transform2 = transform$1(viewport);
    matrix = transform2 ? transform2.matrix : createMatrix();
    scale = round$c(matrix.a, 1e3);
    x2 = round$c(-matrix.e || 0, 1e3);
    y2 = round$c(-matrix.f || 0, 1e3);
    box = this._cachedViewbox = {
      x: x2 ? x2 / scale : 0,
      y: y2 ? y2 / scale : 0,
      width: outerBox.width / scale,
      height: outerBox.height / scale,
      scale,
      inner: {
        width: innerBox.width || 0,
        height: innerBox.height || 0,
        x: innerBox.x || 0,
        y: innerBox.y || 0
      },
      outer: outerBox
    };
    return box;
  } else {
    this._changeViewbox(function() {
      scale = Math.min(outerBox.width / box.width, outerBox.height / box.height);
      const matrix2 = this._svg.createSVGMatrix().scale(scale).translate(-box.x, -box.y);
      transform$1(viewport, matrix2);
    });
  }
  return box;
};
Canvas.prototype.scroll = function(delta2) {
  const node2 = this._viewport;
  let matrix = node2.getCTM();
  if (delta2) {
    this._changeViewbox(function() {
      delta2 = assign$1({ dx: 0, dy: 0 }, delta2 || {});
      matrix = this._svg.createSVGMatrix().translate(delta2.dx, delta2.dy).multiply(matrix);
      setCTM(node2, matrix);
    });
  }
  return { x: matrix.e, y: matrix.f };
};
Canvas.prototype.scrollToElement = function(element, padding) {
  let defaultPadding = 100;
  if (typeof element === "string") {
    element = this._elementRegistry.get(element);
  }
  const rootElement = this.findRoot(element);
  if (rootElement !== this.getRootElement()) {
    this.setRootElement(rootElement);
  }
  if (rootElement === element) {
    return;
  }
  if (!padding) {
    padding = {};
  }
  if (typeof padding === "number") {
    defaultPadding = padding;
  }
  padding = {
    top: padding.top || defaultPadding,
    right: padding.right || defaultPadding,
    bottom: padding.bottom || defaultPadding,
    left: padding.left || defaultPadding
  };
  const elementBounds = getBBox(element), elementTrbl = asTRBL(elementBounds), viewboxBounds = this.viewbox(), zoom2 = this.zoom();
  let dx, dy;
  viewboxBounds.y += padding.top / zoom2;
  viewboxBounds.x += padding.left / zoom2;
  viewboxBounds.width -= (padding.right + padding.left) / zoom2;
  viewboxBounds.height -= (padding.bottom + padding.top) / zoom2;
  const viewboxTrbl = asTRBL(viewboxBounds);
  const canFit = elementBounds.width < viewboxBounds.width && elementBounds.height < viewboxBounds.height;
  if (!canFit) {
    dx = elementBounds.x - viewboxBounds.x;
    dy = elementBounds.y - viewboxBounds.y;
  } else {
    const dRight = Math.max(0, elementTrbl.right - viewboxTrbl.right), dLeft = Math.min(0, elementTrbl.left - viewboxTrbl.left), dBottom = Math.max(0, elementTrbl.bottom - viewboxTrbl.bottom), dTop = Math.min(0, elementTrbl.top - viewboxTrbl.top);
    dx = dRight || dLeft;
    dy = dBottom || dTop;
  }
  this.scroll({ dx: -dx * zoom2, dy: -dy * zoom2 });
};
Canvas.prototype.zoom = function(newScale, center2) {
  if (!newScale) {
    return this.viewbox(newScale).scale;
  }
  if (newScale === "fit-viewport") {
    return this._fitViewport(center2);
  }
  let outer, matrix;
  this._changeViewbox(function() {
    if (typeof center2 !== "object") {
      outer = this.viewbox().outer;
      center2 = {
        x: outer.width / 2,
        y: outer.height / 2
      };
    }
    matrix = this._setZoom(newScale, center2);
  });
  return round$c(matrix.a, 1e3);
};
function setCTM(node2, m2) {
  const mstr = "matrix(" + m2.a + "," + m2.b + "," + m2.c + "," + m2.d + "," + m2.e + "," + m2.f + ")";
  node2.setAttribute("transform", mstr);
}
Canvas.prototype._fitViewport = function(center2) {
  const vbox = this.viewbox(), outer = vbox.outer, inner = vbox.inner;
  let newScale, newViewbox;
  if (inner.x >= 0 && inner.y >= 0 && inner.x + inner.width <= outer.width && inner.y + inner.height <= outer.height && !center2) {
    newViewbox = {
      x: 0,
      y: 0,
      width: Math.max(inner.width + inner.x, outer.width),
      height: Math.max(inner.height + inner.y, outer.height)
    };
  } else {
    newScale = Math.min(1, outer.width / inner.width, outer.height / inner.height);
    newViewbox = {
      x: inner.x + (center2 ? inner.width / 2 - outer.width / newScale / 2 : 0),
      y: inner.y + (center2 ? inner.height / 2 - outer.height / newScale / 2 : 0),
      width: outer.width / newScale,
      height: outer.height / newScale
    };
  }
  this.viewbox(newViewbox);
  return this.viewbox(false).scale;
};
Canvas.prototype._setZoom = function(scale, center2) {
  const svg = this._svg, viewport = this._viewport;
  const matrix = svg.createSVGMatrix();
  const point = svg.createSVGPoint();
  let centerPoint, originalPoint, currentMatrix, scaleMatrix, newMatrix;
  currentMatrix = viewport.getCTM();
  const currentScale = currentMatrix.a;
  if (center2) {
    centerPoint = assign$1(point, center2);
    originalPoint = centerPoint.matrixTransform(currentMatrix.inverse());
    scaleMatrix = matrix.translate(originalPoint.x, originalPoint.y).scale(1 / currentScale * scale).translate(-originalPoint.x, -originalPoint.y);
    newMatrix = currentMatrix.multiply(scaleMatrix);
  } else {
    newMatrix = matrix.scale(scale);
  }
  setCTM(this._viewport, newMatrix);
  return newMatrix;
};
Canvas.prototype.getSize = function() {
  return {
    width: this._container.clientWidth,
    height: this._container.clientHeight
  };
};
Canvas.prototype.getAbsoluteBBox = function(element) {
  const vbox = this.viewbox();
  let bbox;
  if (element.waypoints) {
    const gfx = this.getGraphics(element);
    bbox = gfx.getBBox();
  } else {
    bbox = element;
  }
  const x2 = bbox.x * vbox.scale - vbox.x * vbox.scale;
  const y2 = bbox.y * vbox.scale - vbox.y * vbox.scale;
  const width = bbox.width * vbox.scale;
  const height = bbox.height * vbox.scale;
  return {
    x: x2,
    y: y2,
    width,
    height
  };
};
Canvas.prototype.resized = function() {
  delete this._cachedViewbox;
  this._eventBus.fire("canvas.resized");
};
var ELEMENT_ID = "data-element-id";
function ElementRegistry(eventBus) {
  this._elements = {};
  this._eventBus = eventBus;
}
ElementRegistry.$inject = ["eventBus"];
ElementRegistry.prototype.add = function(element, gfx, secondaryGfx) {
  var id = element.id;
  this._validateId(id);
  attr(gfx, ELEMENT_ID, id);
  if (secondaryGfx) {
    attr(secondaryGfx, ELEMENT_ID, id);
  }
  this._elements[id] = { element, gfx, secondaryGfx };
};
ElementRegistry.prototype.remove = function(element) {
  var elements = this._elements, id = element.id || element, container = id && elements[id];
  if (container) {
    attr(container.gfx, ELEMENT_ID, "");
    if (container.secondaryGfx) {
      attr(container.secondaryGfx, ELEMENT_ID, "");
    }
    delete elements[id];
  }
};
ElementRegistry.prototype.updateId = function(element, newId) {
  this._validateId(newId);
  if (typeof element === "string") {
    element = this.get(element);
  }
  this._eventBus.fire("element.updateId", {
    element,
    newId
  });
  var gfx = this.getGraphics(element), secondaryGfx = this.getGraphics(element, true);
  this.remove(element);
  element.id = newId;
  this.add(element, gfx, secondaryGfx);
};
ElementRegistry.prototype.updateGraphics = function(filter2, gfx, secondary) {
  var id = filter2.id || filter2;
  var container = this._elements[id];
  if (secondary) {
    container.secondaryGfx = gfx;
  } else {
    container.gfx = gfx;
  }
  if (gfx) {
    attr(gfx, ELEMENT_ID, id);
  }
  return gfx;
};
ElementRegistry.prototype.get = function(filter2) {
  var id;
  if (typeof filter2 === "string") {
    id = filter2;
  } else {
    id = filter2 && attr(filter2, ELEMENT_ID);
  }
  var container = this._elements[id];
  return container && container.element;
};
ElementRegistry.prototype.filter = function(fn) {
  var filtered = [];
  this.forEach(function(element, gfx) {
    if (fn(element, gfx)) {
      filtered.push(element);
    }
  });
  return filtered;
};
ElementRegistry.prototype.find = function(fn) {
  var map2 = this._elements, keys2 = Object.keys(map2);
  for (var i2 = 0; i2 < keys2.length; i2++) {
    var id = keys2[i2], container = map2[id], element = container.element, gfx = container.gfx;
    if (fn(element, gfx)) {
      return element;
    }
  }
};
ElementRegistry.prototype.getAll = function() {
  return this.filter(function(e2) {
    return e2;
  });
};
ElementRegistry.prototype.forEach = function(fn) {
  var map2 = this._elements;
  Object.keys(map2).forEach(function(id) {
    var container = map2[id], element = container.element, gfx = container.gfx;
    return fn(element, gfx);
  });
};
ElementRegistry.prototype.getGraphics = function(filter2, secondary) {
  var id = filter2.id || filter2;
  var container = this._elements[id];
  return container && (secondary ? container.secondaryGfx : container.gfx);
};
ElementRegistry.prototype._validateId = function(id) {
  if (!id) {
    throw new Error("element must have an id");
  }
  if (this._elements[id]) {
    throw new Error("element with id " + id + " already added");
  }
};
function extend(collection, refs, property, target) {
  var inverseProperty = property.inverse;
  Object.defineProperty(collection, "remove", {
    value: function(element) {
      var idx = this.indexOf(element);
      if (idx !== -1) {
        this.splice(idx, 1);
        refs.unset(element, inverseProperty, target);
      }
      return element;
    }
  });
  Object.defineProperty(collection, "contains", {
    value: function(element) {
      return this.indexOf(element) !== -1;
    }
  });
  Object.defineProperty(collection, "add", {
    value: function(element, idx) {
      var currentIdx = this.indexOf(element);
      if (typeof idx === "undefined") {
        if (currentIdx !== -1) {
          return;
        }
        idx = this.length;
      }
      if (currentIdx !== -1) {
        this.splice(currentIdx, 1);
      }
      this.splice(idx, 0, element);
      if (currentIdx === -1) {
        refs.set(element, inverseProperty, target);
      }
    }
  });
  Object.defineProperty(collection, "__refs_collection", {
    value: true
  });
  return collection;
}
function isExtended(collection) {
  return collection.__refs_collection === true;
}
function hasOwnProperty$1(e2, property) {
  return Object.prototype.hasOwnProperty.call(e2, property.name || property);
}
function defineCollectionProperty(ref, property, target) {
  var collection = extend(target[property.name] || [], ref, property, target);
  Object.defineProperty(target, property.name, {
    enumerable: property.enumerable,
    value: collection
  });
  if (collection.length) {
    collection.forEach(function(o2) {
      ref.set(o2, property.inverse, target);
    });
  }
}
function defineProperty$1(ref, property, target) {
  var inverseProperty = property.inverse;
  var _value = target[property.name];
  Object.defineProperty(target, property.name, {
    configurable: property.configurable,
    enumerable: property.enumerable,
    get: function() {
      return _value;
    },
    set: function(value) {
      if (value === _value) {
        return;
      }
      var old = _value;
      _value = null;
      if (old) {
        ref.unset(old, inverseProperty, target);
      }
      _value = value;
      ref.set(_value, inverseProperty, target);
    }
  });
}
function Refs(a2, b2) {
  if (!(this instanceof Refs)) {
    return new Refs(a2, b2);
  }
  a2.inverse = b2;
  b2.inverse = a2;
  this.props = {};
  this.props[a2.name] = a2;
  this.props[b2.name] = b2;
}
Refs.prototype.bind = function(target, property) {
  if (typeof property === "string") {
    if (!this.props[property]) {
      throw new Error("no property <" + property + "> in ref");
    }
    property = this.props[property];
  }
  if (property.collection) {
    defineCollectionProperty(this, property, target);
  } else {
    defineProperty$1(this, property, target);
  }
};
Refs.prototype.ensureRefsCollection = function(target, property) {
  var collection = target[property.name];
  if (!isExtended(collection)) {
    defineCollectionProperty(this, property, target);
  }
  return collection;
};
Refs.prototype.ensureBound = function(target, property) {
  if (!hasOwnProperty$1(target, property)) {
    this.bind(target, property);
  }
};
Refs.prototype.unset = function(target, property, value) {
  if (target) {
    this.ensureBound(target, property);
    if (property.collection) {
      this.ensureRefsCollection(target, property).remove(value);
    } else {
      target[property.name] = void 0;
    }
  }
};
Refs.prototype.set = function(target, property, value) {
  if (target) {
    this.ensureBound(target, property);
    if (property.collection) {
      this.ensureRefsCollection(target, property).add(value);
    } else {
      target[property.name] = value;
    }
  }
};
var parentRefs = new Refs({ name: "children", enumerable: true, collection: true }, { name: "parent" }), labelRefs = new Refs({ name: "labels", enumerable: true, collection: true }, { name: "labelTarget" }), attacherRefs = new Refs({ name: "attachers", collection: true }, { name: "host" }), outgoingRefs = new Refs({ name: "outgoing", collection: true }, { name: "source" }), incomingRefs = new Refs({ name: "incoming", collection: true }, { name: "target" });
function ElementImpl() {
  Object.defineProperty(this, "businessObject", {
    writable: true
  });
  Object.defineProperty(this, "label", {
    get: function() {
      return this.labels[0];
    },
    set: function(newLabel) {
      var label = this.label, labels = this.labels;
      if (!newLabel && label) {
        labels.remove(label);
      } else {
        labels.add(newLabel, 0);
      }
    }
  });
  parentRefs.bind(this, "parent");
  labelRefs.bind(this, "labels");
  outgoingRefs.bind(this, "outgoing");
  incomingRefs.bind(this, "incoming");
}
function ShapeImpl() {
  ElementImpl.call(this);
  parentRefs.bind(this, "children");
  attacherRefs.bind(this, "host");
  attacherRefs.bind(this, "attachers");
}
e$3(ShapeImpl, ElementImpl);
function RootImpl() {
  ElementImpl.call(this);
  parentRefs.bind(this, "children");
}
e$3(RootImpl, ShapeImpl);
function LabelImpl() {
  ShapeImpl.call(this);
  labelRefs.bind(this, "labelTarget");
}
e$3(LabelImpl, ShapeImpl);
function ConnectionImpl() {
  ElementImpl.call(this);
  outgoingRefs.bind(this, "source");
  incomingRefs.bind(this, "target");
}
e$3(ConnectionImpl, ElementImpl);
var types$7 = {
  connection: ConnectionImpl,
  shape: ShapeImpl,
  label: LabelImpl,
  root: RootImpl
};
function create(type, attrs) {
  var Type = types$7[type];
  if (!Type) {
    throw new Error("unknown type: <" + type + ">");
  }
  return assign$1(new Type(), attrs);
}
function isModelElement(obj) {
  return obj instanceof ElementImpl;
}
function ElementFactory$1() {
  this._uid = 12;
}
ElementFactory$1.prototype.createRoot = function(attrs) {
  return this.create("root", attrs);
};
ElementFactory$1.prototype.createLabel = function(attrs) {
  return this.create("label", attrs);
};
ElementFactory$1.prototype.createShape = function(attrs) {
  return this.create("shape", attrs);
};
ElementFactory$1.prototype.createConnection = function(attrs) {
  return this.create("connection", attrs);
};
ElementFactory$1.prototype.create = function(type, attrs) {
  attrs = assign$1({}, attrs || {});
  if (!attrs.id) {
    attrs.id = type + "_" + this._uid++;
  }
  return create(type, attrs);
};
var FN_REF = "__fn";
var DEFAULT_PRIORITY$6 = 1e3;
var slice = Array.prototype.slice;
function EventBus() {
  this._listeners = {};
  this.on("diagram.destroy", 1, this._destroy, this);
}
EventBus.prototype.on = function(events, priority, callback, that) {
  events = isArray$3(events) ? events : [events];
  if (isFunction(priority)) {
    that = callback;
    callback = priority;
    priority = DEFAULT_PRIORITY$6;
  }
  if (!isNumber(priority)) {
    throw new Error("priority must be a number");
  }
  var actualCallback = callback;
  if (that) {
    actualCallback = bind$2(callback, that);
    actualCallback[FN_REF] = callback[FN_REF] || callback;
  }
  var self2 = this;
  events.forEach(function(e2) {
    self2._addListener(e2, {
      priority,
      callback: actualCallback,
      next: null
    });
  });
};
EventBus.prototype.once = function(events, priority, callback, that) {
  var self2 = this;
  if (isFunction(priority)) {
    that = callback;
    callback = priority;
    priority = DEFAULT_PRIORITY$6;
  }
  if (!isNumber(priority)) {
    throw new Error("priority must be a number");
  }
  function wrappedCallback() {
    wrappedCallback.__isTomb = true;
    var result = callback.apply(that, arguments);
    self2.off(events, wrappedCallback);
    return result;
  }
  wrappedCallback[FN_REF] = callback;
  this.on(events, priority, wrappedCallback);
};
EventBus.prototype.off = function(events, callback) {
  events = isArray$3(events) ? events : [events];
  var self2 = this;
  events.forEach(function(event2) {
    self2._removeListener(event2, callback);
  });
};
EventBus.prototype.createEvent = function(data) {
  var event2 = new InternalEvent();
  event2.init(data);
  return event2;
};
EventBus.prototype.fire = function(type, data) {
  var event2, firstListener, returnValue, args;
  args = slice.call(arguments);
  if (typeof type === "object") {
    data = type;
    type = data.type;
  }
  if (!type) {
    throw new Error("no event type specified");
  }
  firstListener = this._listeners[type];
  if (!firstListener) {
    return;
  }
  if (data instanceof InternalEvent) {
    event2 = data;
  } else {
    event2 = this.createEvent(data);
  }
  args[0] = event2;
  var originalType = event2.type;
  if (type !== originalType) {
    event2.type = type;
  }
  try {
    returnValue = this._invokeListeners(event2, args, firstListener);
  } finally {
    if (type !== originalType) {
      event2.type = originalType;
    }
  }
  if (returnValue === void 0 && event2.defaultPrevented) {
    returnValue = false;
  }
  return returnValue;
};
EventBus.prototype.handleError = function(error2) {
  return this.fire("error", { error: error2 }) === false;
};
EventBus.prototype._destroy = function() {
  this._listeners = {};
};
EventBus.prototype._invokeListeners = function(event2, args, listener) {
  var returnValue;
  while (listener) {
    if (event2.cancelBubble) {
      break;
    }
    returnValue = this._invokeListener(event2, args, listener);
    listener = listener.next;
  }
  return returnValue;
};
EventBus.prototype._invokeListener = function(event2, args, listener) {
  var returnValue;
  if (listener.callback.__isTomb) {
    return returnValue;
  }
  try {
    returnValue = invokeFunction(listener.callback, args);
    if (returnValue !== void 0) {
      event2.returnValue = returnValue;
      event2.stopPropagation();
    }
    if (returnValue === false) {
      event2.preventDefault();
    }
  } catch (error2) {
    if (!this.handleError(error2)) {
      console.error("unhandled error in event listener", error2);
      throw error2;
    }
  }
  return returnValue;
};
EventBus.prototype._addListener = function(event2, newListener) {
  var listener = this._getListeners(event2), previousListener;
  if (!listener) {
    this._setListeners(event2, newListener);
    return;
  }
  while (listener) {
    if (listener.priority < newListener.priority) {
      newListener.next = listener;
      if (previousListener) {
        previousListener.next = newListener;
      } else {
        this._setListeners(event2, newListener);
      }
      return;
    }
    previousListener = listener;
    listener = listener.next;
  }
  previousListener.next = newListener;
};
EventBus.prototype._getListeners = function(name2) {
  return this._listeners[name2];
};
EventBus.prototype._setListeners = function(name2, listener) {
  this._listeners[name2] = listener;
};
EventBus.prototype._removeListener = function(event2, callback) {
  var listener = this._getListeners(event2), nextListener, previousListener, listenerCallback;
  if (!callback) {
    this._setListeners(event2, null);
    return;
  }
  while (listener) {
    nextListener = listener.next;
    listenerCallback = listener.callback;
    if (listenerCallback === callback || listenerCallback[FN_REF] === callback) {
      if (previousListener) {
        previousListener.next = nextListener;
      } else {
        this._setListeners(event2, nextListener);
      }
    }
    previousListener = listener;
    listener = nextListener;
  }
};
function InternalEvent() {
}
InternalEvent.prototype.stopPropagation = function() {
  this.cancelBubble = true;
};
InternalEvent.prototype.preventDefault = function() {
  this.defaultPrevented = true;
};
InternalEvent.prototype.init = function(data) {
  assign$1(this, data || {});
};
function invokeFunction(fn, args) {
  return fn.apply(null, args);
}
function getVisual(gfx) {
  return gfx.childNodes[0];
}
function getChildren$1(gfx) {
  return gfx.parentNode.childNodes[1];
}
function transform(gfx, x2, y2, angle, amount) {
  var translate2 = createTransform();
  translate2.setTranslate(x2, y2);
  var rotate2 = createTransform();
  rotate2.setRotate(angle || 0, 0, 0);
  var scale = createTransform();
  scale.setScale(amount || 1, amount || 1);
  transform$1(gfx, [translate2, rotate2, scale]);
}
function translate$2(gfx, x2, y2) {
  var translate2 = createTransform();
  translate2.setTranslate(x2, y2);
  transform$1(gfx, translate2);
}
function rotate(gfx, angle) {
  var rotate2 = createTransform();
  rotate2.setRotate(angle, 0, 0);
  transform$1(gfx, rotate2);
}
function GraphicsFactory(eventBus, elementRegistry) {
  this._eventBus = eventBus;
  this._elementRegistry = elementRegistry;
}
GraphicsFactory.$inject = ["eventBus", "elementRegistry"];
GraphicsFactory.prototype._getChildrenContainer = function(element) {
  var gfx = this._elementRegistry.getGraphics(element);
  var childrenGfx;
  if (!element.parent) {
    childrenGfx = gfx;
  } else {
    childrenGfx = getChildren$1(gfx);
    if (!childrenGfx) {
      childrenGfx = create$1("g");
      classes(childrenGfx).add("djs-children");
      append(gfx.parentNode, childrenGfx);
    }
  }
  return childrenGfx;
};
GraphicsFactory.prototype._clear = function(gfx) {
  var visual = getVisual(gfx);
  clear$1(visual);
  return visual;
};
GraphicsFactory.prototype._createContainer = function(type, childrenGfx, parentIndex, isFrame) {
  var outerGfx = create$1("g");
  classes(outerGfx).add("djs-group");
  if (typeof parentIndex !== "undefined") {
    prependTo(outerGfx, childrenGfx, childrenGfx.childNodes[parentIndex]);
  } else {
    append(childrenGfx, outerGfx);
  }
  var gfx = create$1("g");
  classes(gfx).add("djs-element");
  classes(gfx).add("djs-" + type);
  if (isFrame) {
    classes(gfx).add("djs-frame");
  }
  append(outerGfx, gfx);
  var visual = create$1("g");
  classes(visual).add("djs-visual");
  append(gfx, visual);
  return gfx;
};
GraphicsFactory.prototype.create = function(type, element, parentIndex) {
  var childrenGfx = this._getChildrenContainer(element.parent);
  return this._createContainer(type, childrenGfx, parentIndex, isFrameElement$1(element));
};
GraphicsFactory.prototype.updateContainments = function(elements) {
  var self2 = this, elementRegistry = this._elementRegistry, parents;
  parents = reduce(elements, function(map2, e2) {
    if (e2.parent) {
      map2[e2.parent.id] = e2.parent;
    }
    return map2;
  }, {});
  forEach$1(parents, function(parent) {
    var children = parent.children;
    if (!children) {
      return;
    }
    var childrenGfx = self2._getChildrenContainer(parent);
    forEach$1(children.slice().reverse(), function(child) {
      var childGfx = elementRegistry.getGraphics(child);
      prependTo(childGfx.parentNode, childrenGfx);
    });
  });
};
GraphicsFactory.prototype.drawShape = function(visual, element, attrs = {}) {
  var eventBus = this._eventBus;
  return eventBus.fire("render.shape", { gfx: visual, element, attrs });
};
GraphicsFactory.prototype.getShapePath = function(element) {
  var eventBus = this._eventBus;
  return eventBus.fire("render.getShapePath", element);
};
GraphicsFactory.prototype.drawConnection = function(visual, element, attrs = {}) {
  var eventBus = this._eventBus;
  return eventBus.fire("render.connection", { gfx: visual, element, attrs });
};
GraphicsFactory.prototype.getConnectionPath = function(connection) {
  var eventBus = this._eventBus;
  return eventBus.fire("render.getConnectionPath", connection);
};
GraphicsFactory.prototype.update = function(type, element, gfx) {
  if (!element.parent) {
    return;
  }
  var visual = this._clear(gfx);
  if (type === "shape") {
    this.drawShape(visual, element);
    translate$2(gfx, element.x, element.y);
  } else if (type === "connection") {
    this.drawConnection(visual, element);
  } else {
    throw new Error("unknown type: " + type);
  }
  if (element.hidden) {
    attr(gfx, "display", "none");
  } else {
    attr(gfx, "display", "block");
  }
};
GraphicsFactory.prototype.remove = function(element) {
  var gfx = this._elementRegistry.getGraphics(element);
  remove$1(gfx.parentNode);
};
function prependTo(newNode, parentNode, siblingNode) {
  var node2 = siblingNode || parentNode.firstChild;
  if (newNode === node2) {
    return;
  }
  parentNode.insertBefore(newNode, node2);
}
const CoreModule$1 = {
  __depends__: [DrawModule$1],
  __init__: ["canvas"],
  canvas: ["type", Canvas],
  elementRegistry: ["type", ElementRegistry],
  elementFactory: ["type", ElementFactory$1],
  eventBus: ["type", EventBus],
  graphicsFactory: ["type", GraphicsFactory]
};
function bootstrap(modules) {
  var injector = new Injector(modules);
  injector.init();
  return injector;
}
function createInjector(options) {
  options = options || {};
  var configModule = {
    "config": ["value", options]
  };
  var modules = [configModule, CoreModule$1].concat(options.modules || []);
  return bootstrap(modules);
}
function Diagram(options, injector) {
  this._injector = injector || createInjector(options);
  this.get("eventBus").fire("diagram.init");
}
Diagram.prototype.get = function(name2, strict) {
  return this._injector.get(name2, strict);
};
Diagram.prototype.invoke = function(func, context, locals) {
  return this._injector.invoke(func, context, locals);
};
Diagram.prototype.destroy = function() {
  this.get("eventBus").fire("diagram.destroy");
};
Diagram.prototype.clear = function() {
  this.get("eventBus").fire("diagram.clear");
};
function Base() {
}
Base.prototype.get = function(name2) {
  return this.$model.properties.get(this, name2);
};
Base.prototype.set = function(name2, value) {
  this.$model.properties.set(this, name2, value);
};
function Factory(model, properties) {
  this.model = model;
  this.properties = properties;
}
Factory.prototype.createType = function(descriptor) {
  var model = this.model;
  var props = this.properties, prototype = Object.create(Base.prototype);
  forEach$1(descriptor.properties, function(p2) {
    if (!p2.isMany && p2.default !== void 0) {
      prototype[p2.name] = p2.default;
    }
  });
  props.defineModel(prototype, model);
  props.defineDescriptor(prototype, descriptor);
  var name2 = descriptor.ns.name;
  function ModdleElement(attrs) {
    props.define(this, "$type", { value: name2, enumerable: true });
    props.define(this, "$attrs", { value: {} });
    props.define(this, "$parent", { writable: true });
    forEach$1(attrs, bind$2(function(val, key) {
      this.set(key, val);
    }, this));
  }
  ModdleElement.prototype = prototype;
  ModdleElement.hasType = prototype.$instanceOf = this.model.hasType;
  props.defineModel(ModdleElement, model);
  props.defineDescriptor(ModdleElement, descriptor);
  return ModdleElement;
};
var BUILTINS = {
  String: true,
  Boolean: true,
  Integer: true,
  Real: true,
  Element: true
};
var TYPE_CONVERTERS = {
  String: function(s2) {
    return s2;
  },
  Boolean: function(s2) {
    return s2 === "true";
  },
  Integer: function(s2) {
    return parseInt(s2, 10);
  },
  Real: function(s2) {
    return parseFloat(s2);
  }
};
function coerceType(type, value) {
  var converter = TYPE_CONVERTERS[type];
  if (converter) {
    return converter(value);
  } else {
    return value;
  }
}
function isBuiltIn(type) {
  return !!BUILTINS[type];
}
function isSimple(type) {
  return !!TYPE_CONVERTERS[type];
}
function parseName(name2, defaultPrefix) {
  var parts = name2.split(/:/), localName, prefix2;
  if (parts.length === 1) {
    localName = name2;
    prefix2 = defaultPrefix;
  } else if (parts.length === 2) {
    localName = parts[1];
    prefix2 = parts[0];
  } else {
    throw new Error("expected <prefix:localName> or <localName>, got " + name2);
  }
  name2 = (prefix2 ? prefix2 + ":" : "") + localName;
  return {
    name: name2,
    prefix: prefix2,
    localName
  };
}
function DescriptorBuilder(nameNs) {
  this.ns = nameNs;
  this.name = nameNs.name;
  this.allTypes = [];
  this.allTypesByName = {};
  this.properties = [];
  this.propertiesByName = {};
}
DescriptorBuilder.prototype.build = function() {
  return pick(this, [
    "ns",
    "name",
    "allTypes",
    "allTypesByName",
    "properties",
    "propertiesByName",
    "bodyProperty",
    "idProperty"
  ]);
};
DescriptorBuilder.prototype.addProperty = function(p2, idx, validate) {
  if (typeof idx === "boolean") {
    validate = idx;
    idx = void 0;
  }
  this.addNamedProperty(p2, validate !== false);
  var properties = this.properties;
  if (idx !== void 0) {
    properties.splice(idx, 0, p2);
  } else {
    properties.push(p2);
  }
};
DescriptorBuilder.prototype.replaceProperty = function(oldProperty, newProperty, replace) {
  var oldNameNs = oldProperty.ns;
  var props = this.properties, propertiesByName = this.propertiesByName, rename = oldProperty.name !== newProperty.name;
  if (oldProperty.isId) {
    if (!newProperty.isId) {
      throw new Error(
        "property <" + newProperty.ns.name + "> must be id property to refine <" + oldProperty.ns.name + ">"
      );
    }
    this.setIdProperty(newProperty, false);
  }
  if (oldProperty.isBody) {
    if (!newProperty.isBody) {
      throw new Error(
        "property <" + newProperty.ns.name + "> must be body property to refine <" + oldProperty.ns.name + ">"
      );
    }
    this.setBodyProperty(newProperty, false);
  }
  var idx = props.indexOf(oldProperty);
  if (idx === -1) {
    throw new Error("property <" + oldNameNs.name + "> not found in property list");
  }
  props.splice(idx, 1);
  this.addProperty(newProperty, replace ? void 0 : idx, rename);
  propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;
};
DescriptorBuilder.prototype.redefineProperty = function(p2, targetPropertyName, replace) {
  var nsPrefix = p2.ns.prefix;
  var parts = targetPropertyName.split("#");
  var name2 = parseName(parts[0], nsPrefix);
  var attrName = parseName(parts[1], name2.prefix).name;
  var redefinedProperty = this.propertiesByName[attrName];
  if (!redefinedProperty) {
    throw new Error("refined property <" + attrName + "> not found");
  } else {
    this.replaceProperty(redefinedProperty, p2, replace);
  }
  delete p2.redefines;
};
DescriptorBuilder.prototype.addNamedProperty = function(p2, validate) {
  var ns2 = p2.ns, propsByName = this.propertiesByName;
  if (validate) {
    this.assertNotDefined(p2, ns2.name);
    this.assertNotDefined(p2, ns2.localName);
  }
  propsByName[ns2.name] = propsByName[ns2.localName] = p2;
};
DescriptorBuilder.prototype.removeNamedProperty = function(p2) {
  var ns2 = p2.ns, propsByName = this.propertiesByName;
  delete propsByName[ns2.name];
  delete propsByName[ns2.localName];
};
DescriptorBuilder.prototype.setBodyProperty = function(p2, validate) {
  if (validate && this.bodyProperty) {
    throw new Error(
      "body property defined multiple times (<" + this.bodyProperty.ns.name + ">, <" + p2.ns.name + ">)"
    );
  }
  this.bodyProperty = p2;
};
DescriptorBuilder.prototype.setIdProperty = function(p2, validate) {
  if (validate && this.idProperty) {
    throw new Error(
      "id property defined multiple times (<" + this.idProperty.ns.name + ">, <" + p2.ns.name + ">)"
    );
  }
  this.idProperty = p2;
};
DescriptorBuilder.prototype.assertNotTrait = function(typeDescriptor) {
  const _extends = typeDescriptor.extends || [];
  if (_extends.length) {
    throw new Error(
      `cannot create <${typeDescriptor.name}> extending <${typeDescriptor.extends}>`
    );
  }
};
DescriptorBuilder.prototype.assertNotDefined = function(p2, name2) {
  var propertyName = p2.name, definedProperty = this.propertiesByName[propertyName];
  if (definedProperty) {
    throw new Error(
      "property <" + propertyName + "> already defined; override of <" + definedProperty.definedBy.ns.name + "#" + definedProperty.ns.name + "> by <" + p2.definedBy.ns.name + "#" + p2.ns.name + "> not allowed without redefines"
    );
  }
};
DescriptorBuilder.prototype.hasProperty = function(name2) {
  return this.propertiesByName[name2];
};
DescriptorBuilder.prototype.addTrait = function(t2, inherited) {
  if (inherited) {
    this.assertNotTrait(t2);
  }
  var typesByName = this.allTypesByName, types2 = this.allTypes;
  var typeName = t2.name;
  if (typeName in typesByName) {
    return;
  }
  forEach$1(t2.properties, bind$2(function(p2) {
    p2 = assign$1({}, p2, {
      name: p2.ns.localName,
      inherited
    });
    Object.defineProperty(p2, "definedBy", {
      value: t2
    });
    var replaces = p2.replaces, redefines = p2.redefines;
    if (replaces || redefines) {
      this.redefineProperty(p2, replaces || redefines, replaces);
    } else {
      if (p2.isBody) {
        this.setBodyProperty(p2);
      }
      if (p2.isId) {
        this.setIdProperty(p2);
      }
      this.addProperty(p2);
    }
  }, this));
  types2.push(t2);
  typesByName[typeName] = t2;
};
function Registry(packages2, properties) {
  this.packageMap = {};
  this.typeMap = {};
  this.packages = [];
  this.properties = properties;
  forEach$1(packages2, bind$2(this.registerPackage, this));
}
Registry.prototype.getPackage = function(uriOrPrefix) {
  return this.packageMap[uriOrPrefix];
};
Registry.prototype.getPackages = function() {
  return this.packages;
};
Registry.prototype.registerPackage = function(pkg) {
  pkg = assign$1({}, pkg);
  var pkgMap = this.packageMap;
  ensureAvailable(pkgMap, pkg, "prefix");
  ensureAvailable(pkgMap, pkg, "uri");
  forEach$1(pkg.types, bind$2(function(descriptor) {
    this.registerType(descriptor, pkg);
  }, this));
  pkgMap[pkg.uri] = pkgMap[pkg.prefix] = pkg;
  this.packages.push(pkg);
};
Registry.prototype.registerType = function(type, pkg) {
  type = assign$1({}, type, {
    superClass: (type.superClass || []).slice(),
    extends: (type.extends || []).slice(),
    properties: (type.properties || []).slice(),
    meta: assign$1(type.meta || {})
  });
  var ns2 = parseName(type.name, pkg.prefix), name2 = ns2.name, propertiesByName = {};
  forEach$1(type.properties, bind$2(function(p2) {
    var propertyNs = parseName(p2.name, ns2.prefix), propertyName = propertyNs.name;
    if (!isBuiltIn(p2.type)) {
      p2.type = parseName(p2.type, propertyNs.prefix).name;
    }
    assign$1(p2, {
      ns: propertyNs,
      name: propertyName
    });
    propertiesByName[propertyName] = p2;
  }, this));
  assign$1(type, {
    ns: ns2,
    name: name2,
    propertiesByName
  });
  forEach$1(type.extends, bind$2(function(extendsName) {
    var extendsNameNs = parseName(extendsName, ns2.prefix);
    var extended = this.typeMap[extendsNameNs.name];
    extended.traits = extended.traits || [];
    extended.traits.push(name2);
  }, this));
  this.definePackage(type, pkg);
  this.typeMap[name2] = type;
};
Registry.prototype.mapTypes = function(nsName2, iterator, trait) {
  var type = isBuiltIn(nsName2.name) ? { name: nsName2.name } : this.typeMap[nsName2.name];
  var self2 = this;
  function traverse(cls, trait2) {
    var parentNs = parseName(cls, isBuiltIn(cls) ? "" : nsName2.prefix);
    self2.mapTypes(parentNs, iterator, trait2);
  }
  function traverseTrait(cls) {
    return traverse(cls, true);
  }
  function traverseSuper(cls) {
    return traverse(cls, false);
  }
  if (!type) {
    throw new Error("unknown type <" + nsName2.name + ">");
  }
  forEach$1(type.superClass, trait ? traverseTrait : traverseSuper);
  iterator(type, !trait);
  forEach$1(type.traits, traverseTrait);
};
Registry.prototype.getEffectiveDescriptor = function(name2) {
  var nsName2 = parseName(name2);
  var builder = new DescriptorBuilder(nsName2);
  this.mapTypes(nsName2, function(type, inherited) {
    builder.addTrait(type, inherited);
  });
  var descriptor = builder.build();
  this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);
  return descriptor;
};
Registry.prototype.definePackage = function(target, pkg) {
  this.properties.define(target, "$pkg", { value: pkg });
};
function ensureAvailable(packageMap, pkg, identifierKey) {
  var value = pkg[identifierKey];
  if (value in packageMap) {
    throw new Error("package with " + identifierKey + " <" + value + "> already defined");
  }
}
function Properties(model) {
  this.model = model;
}
Properties.prototype.set = function(target, name2, value) {
  if (!isString(name2) || !name2.length) {
    throw new TypeError("property name must be a non-empty string");
  }
  var property = this.getProperty(target, name2);
  var propertyName = property && property.name;
  if (isUndefined(value)) {
    if (property) {
      delete target[propertyName];
    } else {
      delete target.$attrs[stripGlobal(name2)];
    }
  } else {
    if (property) {
      if (propertyName in target) {
        target[propertyName] = value;
      } else {
        defineProperty(target, property, value);
      }
    } else {
      target.$attrs[stripGlobal(name2)] = value;
    }
  }
};
Properties.prototype.get = function(target, name2) {
  var property = this.getProperty(target, name2);
  if (!property) {
    return target.$attrs[stripGlobal(name2)];
  }
  var propertyName = property.name;
  if (!target[propertyName] && property.isMany) {
    defineProperty(target, property, []);
  }
  return target[propertyName];
};
Properties.prototype.define = function(target, name2, options) {
  if (!options.writable) {
    var value = options.value;
    options = assign$1({}, options, {
      get: function() {
        return value;
      }
    });
    delete options.value;
  }
  Object.defineProperty(target, name2, options);
};
Properties.prototype.defineDescriptor = function(target, descriptor) {
  this.define(target, "$descriptor", { value: descriptor });
};
Properties.prototype.defineModel = function(target, model) {
  this.define(target, "$model", { value: model });
};
Properties.prototype.getProperty = function(target, name2) {
  var model = this.model;
  var property = model.getPropertyDescriptor(target, name2);
  if (property) {
    return property;
  }
  if (name2.includes(":")) {
    return null;
  }
  const strict = model.config.strict;
  if (typeof strict !== "undefined") {
    const error2 = new TypeError(`unknown property <${name2}> on <${target.$type}>`);
    if (strict) {
      throw error2;
    } else {
      typeof console !== "undefined" && console.warn(error2);
    }
  }
  return null;
};
function isUndefined(val) {
  return typeof val === "undefined";
}
function defineProperty(target, property, value) {
  Object.defineProperty(target, property.name, {
    enumerable: !property.isReference,
    writable: true,
    value,
    configurable: true
  });
}
function stripGlobal(name2) {
  return name2.replace(/^:/, "");
}
function Moddle(packages2, config = {}) {
  this.properties = new Properties(this);
  this.factory = new Factory(this, this.properties);
  this.registry = new Registry(packages2, this.properties);
  this.typeCache = {};
  this.config = config;
}
Moddle.prototype.create = function(descriptor, attrs) {
  var Type = this.getType(descriptor);
  if (!Type) {
    throw new Error("unknown type <" + descriptor + ">");
  }
  return new Type(attrs);
};
Moddle.prototype.getType = function(descriptor) {
  var cache = this.typeCache;
  var name2 = isString(descriptor) ? descriptor : descriptor.ns.name;
  var type = cache[name2];
  if (!type) {
    descriptor = this.registry.getEffectiveDescriptor(name2);
    type = cache[name2] = this.factory.createType(descriptor);
  }
  return type;
};
Moddle.prototype.createAny = function(name2, nsUri, properties) {
  var nameNs = parseName(name2);
  var element = {
    $type: name2,
    $instanceOf: function(type) {
      return type === this.$type;
    },
    get: function(key) {
      return this[key];
    },
    set: function(key, value) {
      set$2(this, [key], value);
    }
  };
  var descriptor = {
    name: name2,
    isGeneric: true,
    ns: {
      prefix: nameNs.prefix,
      localName: nameNs.localName,
      uri: nsUri
    }
  };
  this.properties.defineDescriptor(element, descriptor);
  this.properties.defineModel(element, this);
  this.properties.define(element, "get", { enumerable: false, writable: true });
  this.properties.define(element, "set", { enumerable: false, writable: true });
  this.properties.define(element, "$parent", { enumerable: false, writable: true });
  this.properties.define(element, "$instanceOf", { enumerable: false, writable: true });
  forEach$1(properties, function(a2, key) {
    if (isObject(a2) && a2.value !== void 0) {
      element[a2.name] = a2.value;
    } else {
      element[key] = a2;
    }
  });
  return element;
};
Moddle.prototype.getPackage = function(uriOrPrefix) {
  return this.registry.getPackage(uriOrPrefix);
};
Moddle.prototype.getPackages = function() {
  return this.registry.getPackages();
};
Moddle.prototype.getElementDescriptor = function(element) {
  return element.$descriptor;
};
Moddle.prototype.hasType = function(element, type) {
  if (type === void 0) {
    type = element;
    element = this;
  }
  var descriptor = element.$model.getElementDescriptor(element);
  return type in descriptor.allTypesByName;
};
Moddle.prototype.getPropertyDescriptor = function(element, property) {
  return this.getElementDescriptor(element).propertiesByName[property];
};
Moddle.prototype.getTypeDescriptor = function(type) {
  return this.registry.typeMap[type];
};
var fromCharCode = String.fromCharCode;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var ENTITY_PATTERN = /&#(\d+);|&#x([0-9a-f]+);|&(\w+);/ig;
var ENTITY_MAPPING = {
  "amp": "&",
  "apos": "'",
  "gt": ">",
  "lt": "<",
  "quot": '"'
};
Object.keys(ENTITY_MAPPING).forEach(function(k2) {
  ENTITY_MAPPING[k2.toUpperCase()] = ENTITY_MAPPING[k2];
});
function replaceEntities(_2, d2, x2, z2) {
  if (z2) {
    if (hasOwnProperty.call(ENTITY_MAPPING, z2)) {
      return ENTITY_MAPPING[z2];
    } else {
      return "&" + z2 + ";";
    }
  }
  if (d2) {
    return fromCharCode(d2);
  }
  return fromCharCode(parseInt(x2, 16));
}
function decodeEntities(s2) {
  if (s2.length > 3 && s2.indexOf("&") !== -1) {
    return s2.replace(ENTITY_PATTERN, replaceEntities);
  }
  return s2;
}
var XSI_URI = "http://www.w3.org/2001/XMLSchema-instance";
var XSI_PREFIX = "xsi";
var XSI_TYPE$1 = "xsi:type";
var NON_WHITESPACE_OUTSIDE_ROOT_NODE = "non-whitespace outside of root node";
function error$2(msg) {
  return new Error(msg);
}
function missingNamespaceForPrefix(prefix2) {
  return "missing namespace for prefix <" + prefix2 + ">";
}
function getter(getFn) {
  return {
    "get": getFn,
    "enumerable": true
  };
}
function cloneNsMatrix(nsMatrix) {
  var clone2 = {}, key;
  for (key in nsMatrix) {
    clone2[key] = nsMatrix[key];
  }
  return clone2;
}
function uriPrefix(prefix2) {
  return prefix2 + "$uri";
}
function buildNsMatrix(nsUriToPrefix) {
  var nsMatrix = {}, uri2, prefix2;
  for (uri2 in nsUriToPrefix) {
    prefix2 = nsUriToPrefix[uri2];
    nsMatrix[prefix2] = prefix2;
    nsMatrix[uriPrefix(prefix2)] = uri2;
  }
  return nsMatrix;
}
function noopGetContext() {
  return { "line": 0, "column": 0 };
}
function throwFunc(err) {
  throw err;
}
function Parser(options) {
  if (!this) {
    return new Parser(options);
  }
  var proxy = options && options["proxy"];
  var onText, onOpenTag, onCloseTag, onCDATA, onError = throwFunc, onWarning, onComment, onQuestion, onAttention;
  var getContext = noopGetContext;
  var maybeNS = false;
  var isNamespace = false;
  var returnError = null;
  var parseStop = false;
  var nsUriToPrefix;
  function handleError(err) {
    if (!(err instanceof Error)) {
      err = error$2(err);
    }
    returnError = err;
    onError(err, getContext);
  }
  function handleWarning(err) {
    if (!onWarning) {
      return;
    }
    if (!(err instanceof Error)) {
      err = error$2(err);
    }
    onWarning(err, getContext);
  }
  this["on"] = function(name2, cb) {
    if (typeof cb !== "function") {
      throw error$2("required args <name, cb>");
    }
    switch (name2) {
      case "openTag":
        onOpenTag = cb;
        break;
      case "text":
        onText = cb;
        break;
      case "closeTag":
        onCloseTag = cb;
        break;
      case "error":
        onError = cb;
        break;
      case "warn":
        onWarning = cb;
        break;
      case "cdata":
        onCDATA = cb;
        break;
      case "attention":
        onAttention = cb;
        break;
      case "question":
        onQuestion = cb;
        break;
      case "comment":
        onComment = cb;
        break;
      default:
        throw error$2("unsupported event: " + name2);
    }
    return this;
  };
  this["ns"] = function(nsMap) {
    if (typeof nsMap === "undefined") {
      nsMap = {};
    }
    if (typeof nsMap !== "object") {
      throw error$2("required args <nsMap={}>");
    }
    var _nsUriToPrefix = {}, k2;
    for (k2 in nsMap) {
      _nsUriToPrefix[k2] = nsMap[k2];
    }
    _nsUriToPrefix[XSI_URI] = XSI_PREFIX;
    isNamespace = true;
    nsUriToPrefix = _nsUriToPrefix;
    return this;
  };
  this["parse"] = function(xml2) {
    if (typeof xml2 !== "string") {
      throw error$2("required args <xml=string>");
    }
    returnError = null;
    parse2(xml2);
    getContext = noopGetContext;
    parseStop = false;
    return returnError;
  };
  this["stop"] = function() {
    parseStop = true;
  };
  function parse2(xml2) {
    var nsMatrixStack = isNamespace ? [] : null, nsMatrix = isNamespace ? buildNsMatrix(nsUriToPrefix) : null, _nsMatrix, nodeStack = [], anonymousNsCount = 0, tagStart = false, tagEnd = false, i2 = 0, j2 = 0, x2, y2, q2, w2, v2, xmlns, elementName, _elementName, elementProxy;
    var attrsString = "", attrsStart = 0, cachedAttrs;
    function getAttrs() {
      if (cachedAttrs !== null) {
        return cachedAttrs;
      }
      var nsUri, nsUriPrefix, nsName2, defaultAlias = isNamespace && nsMatrix["xmlns"], attrList = isNamespace && maybeNS ? [] : null, i3 = attrsStart, s2 = attrsString, l2 = s2.length, hasNewMatrix, newalias, value, alias, name2, attrs = {}, seenAttrs = {}, skipAttr, w3, j3;
      parseAttr:
        for (; i3 < l2; i3++) {
          skipAttr = false;
          w3 = s2.charCodeAt(i3);
          if (w3 === 32 || w3 < 14 && w3 > 8) {
            continue;
          }
          if (w3 < 65 || w3 > 122 || w3 > 90 && w3 < 97) {
            if (w3 !== 95 && w3 !== 58) {
              handleWarning("illegal first char attribute name");
              skipAttr = true;
            }
          }
          for (j3 = i3 + 1; j3 < l2; j3++) {
            w3 = s2.charCodeAt(j3);
            if (w3 > 96 && w3 < 123 || w3 > 64 && w3 < 91 || w3 > 47 && w3 < 59 || w3 === 46 || // '.'
            w3 === 45 || // '-'
            w3 === 95) {
              continue;
            }
            if (w3 === 32 || w3 < 14 && w3 > 8) {
              handleWarning("missing attribute value");
              i3 = j3;
              continue parseAttr;
            }
            if (w3 === 61) {
              break;
            }
            handleWarning("illegal attribute name char");
            skipAttr = true;
          }
          name2 = s2.substring(i3, j3);
          if (name2 === "xmlns:xmlns") {
            handleWarning("illegal declaration of xmlns");
            skipAttr = true;
          }
          w3 = s2.charCodeAt(j3 + 1);
          if (w3 === 34) {
            j3 = s2.indexOf('"', i3 = j3 + 2);
            if (j3 === -1) {
              j3 = s2.indexOf("'", i3);
              if (j3 !== -1) {
                handleWarning("attribute value quote missmatch");
                skipAttr = true;
              }
            }
          } else if (w3 === 39) {
            j3 = s2.indexOf("'", i3 = j3 + 2);
            if (j3 === -1) {
              j3 = s2.indexOf('"', i3);
              if (j3 !== -1) {
                handleWarning("attribute value quote missmatch");
                skipAttr = true;
              }
            }
          } else {
            handleWarning("missing attribute value quotes");
            skipAttr = true;
            for (j3 = j3 + 1; j3 < l2; j3++) {
              w3 = s2.charCodeAt(j3 + 1);
              if (w3 === 32 || w3 < 14 && w3 > 8) {
                break;
              }
            }
          }
          if (j3 === -1) {
            handleWarning("missing closing quotes");
            j3 = l2;
            skipAttr = true;
          }
          if (!skipAttr) {
            value = s2.substring(i3, j3);
          }
          i3 = j3;
          for (; j3 + 1 < l2; j3++) {
            w3 = s2.charCodeAt(j3 + 1);
            if (w3 === 32 || w3 < 14 && w3 > 8) {
              break;
            }
            if (i3 === j3) {
              handleWarning("illegal character after attribute end");
              skipAttr = true;
            }
          }
          i3 = j3 + 1;
          if (skipAttr) {
            continue parseAttr;
          }
          if (name2 in seenAttrs) {
            handleWarning("attribute <" + name2 + "> already defined");
            continue;
          }
          seenAttrs[name2] = true;
          if (!isNamespace) {
            attrs[name2] = value;
            continue;
          }
          if (maybeNS) {
            newalias = name2 === "xmlns" ? "xmlns" : name2.charCodeAt(0) === 120 && name2.substr(0, 6) === "xmlns:" ? name2.substr(6) : null;
            if (newalias !== null) {
              nsUri = decodeEntities(value);
              nsUriPrefix = uriPrefix(newalias);
              alias = nsUriToPrefix[nsUri];
              if (!alias) {
                if (newalias === "xmlns" || nsUriPrefix in nsMatrix && nsMatrix[nsUriPrefix] !== nsUri) {
                  do {
                    alias = "ns" + anonymousNsCount++;
                  } while (typeof nsMatrix[alias] !== "undefined");
                } else {
                  alias = newalias;
                }
                nsUriToPrefix[nsUri] = alias;
              }
              if (nsMatrix[newalias] !== alias) {
                if (!hasNewMatrix) {
                  nsMatrix = cloneNsMatrix(nsMatrix);
                  hasNewMatrix = true;
                }
                nsMatrix[newalias] = alias;
                if (newalias === "xmlns") {
                  nsMatrix[uriPrefix(alias)] = nsUri;
                  defaultAlias = alias;
                }
                nsMatrix[nsUriPrefix] = nsUri;
              }
              attrs[name2] = value;
              continue;
            }
            attrList.push(name2, value);
            continue;
          }
          w3 = name2.indexOf(":");
          if (w3 === -1) {
            attrs[name2] = value;
            continue;
          }
          if (!(nsName2 = nsMatrix[name2.substring(0, w3)])) {
            handleWarning(missingNamespaceForPrefix(name2.substring(0, w3)));
            continue;
          }
          name2 = defaultAlias === nsName2 ? name2.substr(w3 + 1) : nsName2 + name2.substr(w3);
          if (name2 === XSI_TYPE$1) {
            w3 = value.indexOf(":");
            if (w3 !== -1) {
              nsName2 = value.substring(0, w3);
              nsName2 = nsMatrix[nsName2] || nsName2;
              value = nsName2 + value.substring(w3);
            } else {
              value = defaultAlias + ":" + value;
            }
          }
          attrs[name2] = value;
        }
      if (maybeNS) {
        for (i3 = 0, l2 = attrList.length; i3 < l2; i3++) {
          name2 = attrList[i3++];
          value = attrList[i3];
          w3 = name2.indexOf(":");
          if (w3 !== -1) {
            if (!(nsName2 = nsMatrix[name2.substring(0, w3)])) {
              handleWarning(missingNamespaceForPrefix(name2.substring(0, w3)));
              continue;
            }
            name2 = defaultAlias === nsName2 ? name2.substr(w3 + 1) : nsName2 + name2.substr(w3);
            if (name2 === XSI_TYPE$1) {
              w3 = value.indexOf(":");
              if (w3 !== -1) {
                nsName2 = value.substring(0, w3);
                nsName2 = nsMatrix[nsName2] || nsName2;
                value = nsName2 + value.substring(w3);
              } else {
                value = defaultAlias + ":" + value;
              }
            }
          }
          attrs[name2] = value;
        }
      }
      return cachedAttrs = attrs;
    }
    function getParseContext() {
      var splitsRe = /(\r\n|\r|\n)/g;
      var line = 0;
      var column = 0;
      var startOfLine = 0;
      var endOfLine = j2;
      var match;
      var data;
      while (i2 >= startOfLine) {
        match = splitsRe.exec(xml2);
        if (!match) {
          break;
        }
        endOfLine = match[0].length + match.index;
        if (endOfLine > i2) {
          break;
        }
        line += 1;
        startOfLine = endOfLine;
      }
      if (i2 == -1) {
        column = endOfLine;
        data = xml2.substring(j2);
      } else if (j2 === 0) {
        data = xml2.substring(j2, i2);
      } else {
        column = i2 - startOfLine;
        data = j2 == -1 ? xml2.substring(i2) : xml2.substring(i2, j2 + 1);
      }
      return {
        "data": data,
        "line": line,
        "column": column
      };
    }
    getContext = getParseContext;
    if (proxy) {
      elementProxy = Object.create({}, {
        "name": getter(function() {
          return elementName;
        }),
        "originalName": getter(function() {
          return _elementName;
        }),
        "attrs": getter(getAttrs),
        "ns": getter(function() {
          return nsMatrix;
        })
      });
    }
    while (j2 !== -1) {
      if (xml2.charCodeAt(j2) === 60) {
        i2 = j2;
      } else {
        i2 = xml2.indexOf("<", j2);
      }
      if (i2 === -1) {
        if (nodeStack.length) {
          return handleError("unexpected end of file");
        }
        if (j2 === 0) {
          return handleError("missing start tag");
        }
        if (j2 < xml2.length) {
          if (xml2.substring(j2).trim()) {
            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);
          }
        }
        return;
      }
      if (j2 !== i2) {
        if (nodeStack.length) {
          if (onText) {
            onText(xml2.substring(j2, i2), decodeEntities, getContext);
            if (parseStop) {
              return;
            }
          }
        } else {
          if (xml2.substring(j2, i2).trim()) {
            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);
            if (parseStop) {
              return;
            }
          }
        }
      }
      w2 = xml2.charCodeAt(i2 + 1);
      if (w2 === 33) {
        q2 = xml2.charCodeAt(i2 + 2);
        if (q2 === 91 && xml2.substr(i2 + 3, 6) === "CDATA[") {
          j2 = xml2.indexOf("]]>", i2);
          if (j2 === -1) {
            return handleError("unclosed cdata");
          }
          if (onCDATA) {
            onCDATA(xml2.substring(i2 + 9, j2), getContext);
            if (parseStop) {
              return;
            }
          }
          j2 += 3;
          continue;
        }
        if (q2 === 45 && xml2.charCodeAt(i2 + 3) === 45) {
          j2 = xml2.indexOf("-->", i2);
          if (j2 === -1) {
            return handleError("unclosed comment");
          }
          if (onComment) {
            onComment(xml2.substring(i2 + 4, j2), decodeEntities, getContext);
            if (parseStop) {
              return;
            }
          }
          j2 += 3;
          continue;
        }
      }
      if (w2 === 63) {
        j2 = xml2.indexOf("?>", i2);
        if (j2 === -1) {
          return handleError("unclosed question");
        }
        if (onQuestion) {
          onQuestion(xml2.substring(i2, j2 + 2), getContext);
          if (parseStop) {
            return;
          }
        }
        j2 += 2;
        continue;
      }
      for (x2 = i2 + 1; ; x2++) {
        v2 = xml2.charCodeAt(x2);
        if (isNaN(v2)) {
          j2 = -1;
          return handleError("unclosed tag");
        }
        if (v2 === 34) {
          q2 = xml2.indexOf('"', x2 + 1);
          x2 = q2 !== -1 ? q2 : x2;
        } else if (v2 === 39) {
          q2 = xml2.indexOf("'", x2 + 1);
          x2 = q2 !== -1 ? q2 : x2;
        } else if (v2 === 62) {
          j2 = x2;
          break;
        }
      }
      if (w2 === 33) {
        if (onAttention) {
          onAttention(xml2.substring(i2, j2 + 1), decodeEntities, getContext);
          if (parseStop) {
            return;
          }
        }
        j2 += 1;
        continue;
      }
      cachedAttrs = {};
      if (w2 === 47) {
        tagStart = false;
        tagEnd = true;
        if (!nodeStack.length) {
          return handleError("missing open tag");
        }
        x2 = elementName = nodeStack.pop();
        q2 = i2 + 2 + x2.length;
        if (xml2.substring(i2 + 2, q2) !== x2) {
          return handleError("closing tag mismatch");
        }
        for (; q2 < j2; q2++) {
          w2 = xml2.charCodeAt(q2);
          if (w2 === 32 || w2 > 8 && w2 < 14) {
            continue;
          }
          return handleError("close tag");
        }
      } else {
        if (xml2.charCodeAt(j2 - 1) === 47) {
          x2 = elementName = xml2.substring(i2 + 1, j2 - 1);
          tagStart = true;
          tagEnd = true;
        } else {
          x2 = elementName = xml2.substring(i2 + 1, j2);
          tagStart = true;
          tagEnd = false;
        }
        if (!(w2 > 96 && w2 < 123 || w2 > 64 && w2 < 91 || w2 === 95 || w2 === 58)) {
          return handleError("illegal first char nodeName");
        }
        for (q2 = 1, y2 = x2.length; q2 < y2; q2++) {
          w2 = x2.charCodeAt(q2);
          if (w2 > 96 && w2 < 123 || w2 > 64 && w2 < 91 || w2 > 47 && w2 < 59 || w2 === 45 || w2 === 95 || w2 == 46) {
            continue;
          }
          if (w2 === 32 || w2 < 14 && w2 > 8) {
            elementName = x2.substring(0, q2);
            cachedAttrs = null;
            break;
          }
          return handleError("invalid nodeName");
        }
        if (!tagEnd) {
          nodeStack.push(elementName);
        }
      }
      if (isNamespace) {
        _nsMatrix = nsMatrix;
        if (tagStart) {
          if (!tagEnd) {
            nsMatrixStack.push(_nsMatrix);
          }
          if (cachedAttrs === null) {
            if (maybeNS = x2.indexOf("xmlns", q2) !== -1) {
              attrsStart = q2;
              attrsString = x2;
              getAttrs();
              maybeNS = false;
            }
          }
        }
        _elementName = elementName;
        w2 = elementName.indexOf(":");
        if (w2 !== -1) {
          xmlns = nsMatrix[elementName.substring(0, w2)];
          if (!xmlns) {
            return handleError("missing namespace on <" + _elementName + ">");
          }
          elementName = elementName.substr(w2 + 1);
        } else {
          xmlns = nsMatrix["xmlns"];
        }
        if (xmlns) {
          elementName = xmlns + ":" + elementName;
        }
      }
      if (tagStart) {
        attrsStart = q2;
        attrsString = x2;
        if (onOpenTag) {
          if (proxy) {
            onOpenTag(elementProxy, decodeEntities, tagEnd, getContext);
          } else {
            onOpenTag(elementName, getAttrs, decodeEntities, tagEnd, getContext);
          }
          if (parseStop) {
            return;
          }
        }
      }
      if (tagEnd) {
        if (onCloseTag) {
          onCloseTag(proxy ? elementProxy : elementName, decodeEntities, tagStart, getContext);
          if (parseStop) {
            return;
          }
        }
        if (isNamespace) {
          if (!tagStart) {
            nsMatrix = nsMatrixStack.pop();
          } else {
            nsMatrix = _nsMatrix;
          }
        }
      }
      j2 += 1;
    }
  }
}
function hasLowerCaseAlias(pkg) {
  return pkg.xml && pkg.xml.tagAlias === "lowerCase";
}
var DEFAULT_NS_MAP = {
  "xsi": "http://www.w3.org/2001/XMLSchema-instance",
  "xml": "http://www.w3.org/XML/1998/namespace"
};
var XSI_TYPE = "xsi:type";
function serializeFormat(element) {
  return element.xml && element.xml.serialize;
}
function serializeAsType(element) {
  return serializeFormat(element) === XSI_TYPE;
}
function serializeAsProperty(element) {
  return serializeFormat(element) === "property";
}
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function aliasToName(aliasNs, pkg) {
  if (!hasLowerCaseAlias(pkg)) {
    return aliasNs.name;
  }
  return aliasNs.prefix + ":" + capitalize(aliasNs.localName);
}
function prefixedToName(nameNs, pkg) {
  var name2 = nameNs.name, localName = nameNs.localName;
  var typePrefix = pkg.xml && pkg.xml.typePrefix;
  if (typePrefix && localName.indexOf(typePrefix) === 0) {
    return nameNs.prefix + ":" + localName.slice(typePrefix.length);
  } else {
    return name2;
  }
}
function normalizeXsiTypeName(name2, model) {
  var nameNs = parseName(name2);
  var pkg = model.getPackage(nameNs.prefix);
  return prefixedToName(nameNs, pkg);
}
function error$1(message) {
  return new Error(message);
}
function getModdleDescriptor(element) {
  return element.$descriptor;
}
function Context(options) {
  assign$1(this, options);
  this.elementsById = {};
  this.references = [];
  this.warnings = [];
  this.addReference = function(reference) {
    this.references.push(reference);
  };
  this.addElement = function(element) {
    if (!element) {
      throw error$1("expected element");
    }
    var elementsById = this.elementsById;
    var descriptor = getModdleDescriptor(element);
    var idProperty = descriptor.idProperty, id;
    if (idProperty) {
      id = element.get(idProperty.name);
      if (id) {
        if (!/^([a-z][\w-.]*:)?[a-z_][\w-.]*$/i.test(id)) {
          throw new Error("illegal ID <" + id + ">");
        }
        if (elementsById[id]) {
          throw error$1("duplicate ID <" + id + ">");
        }
        elementsById[id] = element;
      }
    }
  };
  this.addWarning = function(warning) {
    this.warnings.push(warning);
  };
}
function BaseHandler() {
}
BaseHandler.prototype.handleEnd = function() {
};
BaseHandler.prototype.handleText = function() {
};
BaseHandler.prototype.handleNode = function() {
};
function NoopHandler() {
}
NoopHandler.prototype = Object.create(BaseHandler.prototype);
NoopHandler.prototype.handleNode = function() {
  return this;
};
function BodyHandler() {
}
BodyHandler.prototype = Object.create(BaseHandler.prototype);
BodyHandler.prototype.handleText = function(text) {
  this.body = (this.body || "") + text;
};
function ReferenceHandler(property, context) {
  this.property = property;
  this.context = context;
}
ReferenceHandler.prototype = Object.create(BodyHandler.prototype);
ReferenceHandler.prototype.handleNode = function(node2) {
  if (this.element) {
    throw error$1("expected no sub nodes");
  } else {
    this.element = this.createReference(node2);
  }
  return this;
};
ReferenceHandler.prototype.handleEnd = function() {
  this.element.id = this.body;
};
ReferenceHandler.prototype.createReference = function(node2) {
  return {
    property: this.property.ns.name,
    id: ""
  };
};
function ValueHandler(propertyDesc, element) {
  this.element = element;
  this.propertyDesc = propertyDesc;
}
ValueHandler.prototype = Object.create(BodyHandler.prototype);
ValueHandler.prototype.handleEnd = function() {
  var value = this.body || "", element = this.element, propertyDesc = this.propertyDesc;
  value = coerceType(propertyDesc.type, value);
  if (propertyDesc.isMany) {
    element.get(propertyDesc.name).push(value);
  } else {
    element.set(propertyDesc.name, value);
  }
};
function BaseElementHandler() {
}
BaseElementHandler.prototype = Object.create(BodyHandler.prototype);
BaseElementHandler.prototype.handleNode = function(node2) {
  var parser = this, element = this.element;
  if (!element) {
    element = this.element = this.createElement(node2);
    this.context.addElement(element);
  } else {
    parser = this.handleChild(node2);
  }
  return parser;
};
function ElementHandler(model, typeName, context) {
  this.model = model;
  this.type = model.getType(typeName);
  this.context = context;
}
ElementHandler.prototype = Object.create(BaseElementHandler.prototype);
ElementHandler.prototype.addReference = function(reference) {
  this.context.addReference(reference);
};
ElementHandler.prototype.handleText = function(text) {
  var element = this.element, descriptor = getModdleDescriptor(element), bodyProperty = descriptor.bodyProperty;
  if (!bodyProperty) {
    throw error$1("unexpected body text <" + text + ">");
  }
  BodyHandler.prototype.handleText.call(this, text);
};
ElementHandler.prototype.handleEnd = function() {
  var value = this.body, element = this.element, descriptor = getModdleDescriptor(element), bodyProperty = descriptor.bodyProperty;
  if (bodyProperty && value !== void 0) {
    value = coerceType(bodyProperty.type, value);
    element.set(bodyProperty.name, value);
  }
};
ElementHandler.prototype.createElement = function(node2) {
  var attributes = node2.attributes, Type = this.type, descriptor = getModdleDescriptor(Type), context = this.context, instance = new Type({}), model = this.model, propNameNs;
  forEach$1(attributes, function(value, name2) {
    var prop = descriptor.propertiesByName[name2], values2;
    if (prop && prop.isReference) {
      if (!prop.isMany) {
        context.addReference({
          element: instance,
          property: prop.ns.name,
          id: value
        });
      } else {
        values2 = value.split(" ");
        forEach$1(values2, function(v2) {
          context.addReference({
            element: instance,
            property: prop.ns.name,
            id: v2
          });
        });
      }
    } else {
      if (prop) {
        value = coerceType(prop.type, value);
      } else if (name2 !== "xmlns") {
        propNameNs = parseName(name2, descriptor.ns.prefix);
        if (model.getPackage(propNameNs.prefix)) {
          context.addWarning({
            message: "unknown attribute <" + name2 + ">",
            element: instance,
            property: name2,
            value
          });
        }
      }
      instance.set(name2, value);
    }
  });
  return instance;
};
ElementHandler.prototype.getPropertyForNode = function(node2) {
  var name2 = node2.name;
  var nameNs = parseName(name2);
  var type = this.type, model = this.model, descriptor = getModdleDescriptor(type);
  var propertyName = nameNs.name, property = descriptor.propertiesByName[propertyName], elementTypeName, elementType;
  if (property && !property.isAttr) {
    if (serializeAsType(property)) {
      elementTypeName = node2.attributes[XSI_TYPE];
      if (elementTypeName) {
        elementTypeName = normalizeXsiTypeName(elementTypeName, model);
        elementType = model.getType(elementTypeName);
        return assign$1({}, property, {
          effectiveType: getModdleDescriptor(elementType).name
        });
      }
    }
    return property;
  }
  var pkg = model.getPackage(nameNs.prefix);
  if (pkg) {
    elementTypeName = aliasToName(nameNs, pkg);
    elementType = model.getType(elementTypeName);
    property = find(descriptor.properties, function(p2) {
      return !p2.isVirtual && !p2.isReference && !p2.isAttribute && elementType.hasType(p2.type);
    });
    if (property) {
      return assign$1({}, property, {
        effectiveType: getModdleDescriptor(elementType).name
      });
    }
  } else {
    property = find(descriptor.properties, function(p2) {
      return !p2.isReference && !p2.isAttribute && p2.type === "Element";
    });
    if (property) {
      return property;
    }
  }
  throw error$1("unrecognized element <" + nameNs.name + ">");
};
ElementHandler.prototype.toString = function() {
  return "ElementDescriptor[" + getModdleDescriptor(this.type).name + "]";
};
ElementHandler.prototype.valueHandler = function(propertyDesc, element) {
  return new ValueHandler(propertyDesc, element);
};
ElementHandler.prototype.referenceHandler = function(propertyDesc) {
  return new ReferenceHandler(propertyDesc, this.context);
};
ElementHandler.prototype.handler = function(type) {
  if (type === "Element") {
    return new GenericElementHandler(this.model, type, this.context);
  } else {
    return new ElementHandler(this.model, type, this.context);
  }
};
ElementHandler.prototype.handleChild = function(node2) {
  var propertyDesc, type, element, childHandler;
  propertyDesc = this.getPropertyForNode(node2);
  element = this.element;
  type = propertyDesc.effectiveType || propertyDesc.type;
  if (isSimple(type)) {
    return this.valueHandler(propertyDesc, element);
  }
  if (propertyDesc.isReference) {
    childHandler = this.referenceHandler(propertyDesc).handleNode(node2);
  } else {
    childHandler = this.handler(type).handleNode(node2);
  }
  var newElement = childHandler.element;
  if (newElement !== void 0) {
    if (propertyDesc.isMany) {
      element.get(propertyDesc.name).push(newElement);
    } else {
      element.set(propertyDesc.name, newElement);
    }
    if (propertyDesc.isReference) {
      assign$1(newElement, {
        element
      });
      this.context.addReference(newElement);
    } else {
      newElement.$parent = element;
    }
  }
  return childHandler;
};
function RootElementHandler(model, typeName, context) {
  ElementHandler.call(this, model, typeName, context);
}
RootElementHandler.prototype = Object.create(ElementHandler.prototype);
RootElementHandler.prototype.createElement = function(node2) {
  var name2 = node2.name, nameNs = parseName(name2), model = this.model, type = this.type, pkg = model.getPackage(nameNs.prefix), typeName = pkg && aliasToName(nameNs, pkg) || name2;
  if (!type.hasType(typeName)) {
    throw error$1("unexpected element <" + node2.originalName + ">");
  }
  return ElementHandler.prototype.createElement.call(this, node2);
};
function GenericElementHandler(model, typeName, context) {
  this.model = model;
  this.context = context;
}
GenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);
GenericElementHandler.prototype.createElement = function(node2) {
  var name2 = node2.name, ns2 = parseName(name2), prefix2 = ns2.prefix, uri2 = node2.ns[prefix2 + "$uri"], attributes = node2.attributes;
  return this.model.createAny(name2, uri2, attributes);
};
GenericElementHandler.prototype.handleChild = function(node2) {
  var handler = new GenericElementHandler(this.model, "Element", this.context).handleNode(node2), element = this.element;
  var newElement = handler.element, children;
  if (newElement !== void 0) {
    children = element.$children = element.$children || [];
    children.push(newElement);
    newElement.$parent = element;
  }
  return handler;
};
GenericElementHandler.prototype.handleEnd = function() {
  if (this.body) {
    this.element.$body = this.body;
  }
};
function Reader(options) {
  if (options instanceof Moddle) {
    options = {
      model: options
    };
  }
  assign$1(this, { lax: false }, options);
}
Reader.prototype.fromXML = function(xml2, options, done) {
  var rootHandler = options.rootHandler;
  if (options instanceof ElementHandler) {
    rootHandler = options;
    options = {};
  } else {
    if (typeof options === "string") {
      rootHandler = this.handler(options);
      options = {};
    } else if (typeof rootHandler === "string") {
      rootHandler = this.handler(rootHandler);
    }
  }
  var model = this.model, lax = this.lax;
  var context = new Context(assign$1({}, options, { rootHandler })), parser = new Parser({ proxy: true }), stack = createStack();
  rootHandler.context = context;
  stack.push(rootHandler);
  function handleError(err, getContext, lax2) {
    var ctx = getContext();
    var line = ctx.line, column = ctx.column, data = ctx.data;
    if (data.charAt(0) === "<" && data.indexOf(" ") !== -1) {
      data = data.slice(0, data.indexOf(" ")) + ">";
    }
    var message = "unparsable content " + (data ? data + " " : "") + "detected\n	line: " + line + "\n	column: " + column + "\n	nested error: " + err.message;
    if (lax2) {
      context.addWarning({
        message,
        error: err
      });
      return true;
    } else {
      throw error$1(message);
    }
  }
  function handleWarning(err, getContext) {
    return handleError(err, getContext, true);
  }
  function resolveReferences() {
    var elementsById = context.elementsById;
    var references = context.references;
    var i2, r2;
    for (i2 = 0; r2 = references[i2]; i2++) {
      var element = r2.element;
      var reference = elementsById[r2.id];
      var property = getModdleDescriptor(element).propertiesByName[r2.property];
      if (!reference) {
        context.addWarning({
          message: "unresolved reference <" + r2.id + ">",
          element: r2.element,
          property: r2.property,
          value: r2.id
        });
      }
      if (property.isMany) {
        var collection = element.get(property.name), idx = collection.indexOf(r2);
        if (idx === -1) {
          idx = collection.length;
        }
        if (!reference) {
          collection.splice(idx, 1);
        } else {
          collection[idx] = reference;
        }
      } else {
        element.set(property.name, reference);
      }
    }
  }
  function handleClose() {
    stack.pop().handleEnd();
  }
  var PREAMBLE_START_PATTERN = /^<\?xml /i;
  var ENCODING_PATTERN = / encoding="([^"]+)"/i;
  var UTF_8_PATTERN = /^utf-8$/i;
  function handleQuestion(question) {
    if (!PREAMBLE_START_PATTERN.test(question)) {
      return;
    }
    var match = ENCODING_PATTERN.exec(question);
    var encoding = match && match[1];
    if (!encoding || UTF_8_PATTERN.test(encoding)) {
      return;
    }
    context.addWarning({
      message: "unsupported document encoding <" + encoding + ">, falling back to UTF-8"
    });
  }
  function handleOpen(node2, getContext) {
    var handler = stack.peek();
    try {
      stack.push(handler.handleNode(node2));
    } catch (err) {
      if (handleError(err, getContext, lax)) {
        stack.push(new NoopHandler());
      }
    }
  }
  function handleCData(text, getContext) {
    try {
      stack.peek().handleText(text);
    } catch (err) {
      handleWarning(err, getContext);
    }
  }
  function handleText(text, getContext) {
    if (!text.trim()) {
      return;
    }
    handleCData(text, getContext);
  }
  var uriMap = model.getPackages().reduce(function(uriMap2, p2) {
    uriMap2[p2.uri] = p2.prefix;
    return uriMap2;
  }, {
    "http://www.w3.org/XML/1998/namespace": "xml"
    // add default xml ns
  });
  parser.ns(uriMap).on("openTag", function(obj, decodeStr, selfClosing, getContext) {
    var attrs = obj.attrs || {};
    var decodedAttrs = Object.keys(attrs).reduce(function(d2, key) {
      var value = decodeStr(attrs[key]);
      d2[key] = value;
      return d2;
    }, {});
    var node2 = {
      name: obj.name,
      originalName: obj.originalName,
      attributes: decodedAttrs,
      ns: obj.ns
    };
    handleOpen(node2, getContext);
  }).on("question", handleQuestion).on("closeTag", handleClose).on("cdata", handleCData).on("text", function(text, decodeEntities2, getContext) {
    handleText(decodeEntities2(text), getContext);
  }).on("error", handleError).on("warn", handleWarning);
  return new Promise(function(resolve, reject) {
    var err;
    try {
      parser.parse(xml2);
      resolveReferences();
    } catch (e2) {
      err = e2;
    }
    var rootElement = rootHandler.element;
    if (!err && !rootElement) {
      err = error$1("failed to parse document as <" + rootHandler.type.$descriptor.name + ">");
    }
    var warnings = context.warnings;
    var references = context.references;
    var elementsById = context.elementsById;
    if (err) {
      err.warnings = warnings;
      return reject(err);
    } else {
      return resolve({
        rootElement,
        elementsById,
        references,
        warnings
      });
    }
  });
};
Reader.prototype.handler = function(name2) {
  return new RootElementHandler(this.model, name2);
};
function createStack() {
  var stack = [];
  Object.defineProperty(stack, "peek", {
    value: function() {
      return this[this.length - 1];
    }
  });
  return stack;
}
var XML_PREAMBLE = '<?xml version="1.0" encoding="UTF-8"?>\n';
var ESCAPE_ATTR_CHARS = /<|>|'|"|&|\n\r|\n/g;
var ESCAPE_CHARS = /<|>|&/g;
function Namespaces(parent) {
  var prefixMap = {};
  var uriMap = {};
  var used = {};
  var wellknown = [];
  var custom = [];
  this.byUri = function(uri2) {
    return uriMap[uri2] || parent && parent.byUri(uri2);
  };
  this.add = function(ns2, isWellknown) {
    uriMap[ns2.uri] = ns2;
    if (isWellknown) {
      wellknown.push(ns2);
    } else {
      custom.push(ns2);
    }
    this.mapPrefix(ns2.prefix, ns2.uri);
  };
  this.uriByPrefix = function(prefix2) {
    return prefixMap[prefix2 || "xmlns"];
  };
  this.mapPrefix = function(prefix2, uri2) {
    prefixMap[prefix2 || "xmlns"] = uri2;
  };
  this.getNSKey = function(ns2) {
    return ns2.prefix !== void 0 ? ns2.uri + "|" + ns2.prefix : ns2.uri;
  };
  this.logUsed = function(ns2) {
    var uri2 = ns2.uri;
    var nsKey = this.getNSKey(ns2);
    used[nsKey] = this.byUri(uri2);
    if (parent) {
      parent.logUsed(ns2);
    }
  };
  this.getUsed = function(ns2) {
    function isUsed(ns3) {
      var nsKey = self2.getNSKey(ns3);
      return used[nsKey];
    }
    var self2 = this;
    var allNs = [].concat(wellknown, custom);
    return allNs.filter(isUsed);
  };
}
function lower(string) {
  return string.charAt(0).toLowerCase() + string.slice(1);
}
function nameToAlias(name2, pkg) {
  if (hasLowerCaseAlias(pkg)) {
    return lower(name2);
  } else {
    return name2;
  }
}
function inherits(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
}
function nsName(ns2) {
  if (isString(ns2)) {
    return ns2;
  } else {
    return (ns2.prefix ? ns2.prefix + ":" : "") + ns2.localName;
  }
}
function getNsAttrs(namespaces) {
  return namespaces.getUsed().filter(function(ns2) {
    return ns2.prefix !== "xml";
  }).map(function(ns2) {
    var name2 = "xmlns" + (ns2.prefix ? ":" + ns2.prefix : "");
    return { name: name2, value: ns2.uri };
  });
}
function getElementNs(ns2, descriptor) {
  if (descriptor.isGeneric) {
    return assign$1({ localName: descriptor.ns.localName }, ns2);
  } else {
    return assign$1({ localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg) }, ns2);
  }
}
function getPropertyNs(ns2, descriptor) {
  return assign$1({ localName: descriptor.ns.localName }, ns2);
}
function getSerializableProperties(element) {
  var descriptor = element.$descriptor;
  return filter(descriptor.properties, function(p2) {
    var name2 = p2.name;
    if (p2.isVirtual) {
      return false;
    }
    if (!has$1(element, name2)) {
      return false;
    }
    var value = element[name2];
    if (value === p2.default) {
      return false;
    }
    if (value === null) {
      return false;
    }
    return p2.isMany ? value.length : true;
  });
}
var ESCAPE_ATTR_MAP = {
  "\n": "#10",
  "\n\r": "#10",
  '"': "#34",
  "'": "#39",
  "<": "#60",
  ">": "#62",
  "&": "#38"
};
var ESCAPE_MAP = {
  "<": "lt",
  ">": "gt",
  "&": "amp"
};
function escape(str, charPattern, replaceMap) {
  str = isString(str) ? str : "" + str;
  return str.replace(charPattern, function(s2) {
    return "&" + replaceMap[s2] + ";";
  });
}
function escapeAttr(str) {
  return escape(str, ESCAPE_ATTR_CHARS, ESCAPE_ATTR_MAP);
}
function escapeBody(str) {
  return escape(str, ESCAPE_CHARS, ESCAPE_MAP);
}
function filterAttributes(props) {
  return filter(props, function(p2) {
    return p2.isAttr;
  });
}
function filterContained(props) {
  return filter(props, function(p2) {
    return !p2.isAttr;
  });
}
function ReferenceSerializer(tagName) {
  this.tagName = tagName;
}
ReferenceSerializer.prototype.build = function(element) {
  this.element = element;
  return this;
};
ReferenceSerializer.prototype.serializeTo = function(writer) {
  writer.appendIndent().append("<" + this.tagName + ">" + this.element.id + "</" + this.tagName + ">").appendNewLine();
};
function BodySerializer() {
}
BodySerializer.prototype.serializeValue = BodySerializer.prototype.serializeTo = function(writer) {
  writer.append(
    this.escape ? escapeBody(this.value) : this.value
  );
};
BodySerializer.prototype.build = function(prop, value) {
  this.value = value;
  if (prop.type === "String" && value.search(ESCAPE_CHARS) !== -1) {
    this.escape = true;
  }
  return this;
};
function ValueSerializer(tagName) {
  this.tagName = tagName;
}
inherits(ValueSerializer, BodySerializer);
ValueSerializer.prototype.serializeTo = function(writer) {
  writer.appendIndent().append("<" + this.tagName + ">");
  this.serializeValue(writer);
  writer.append("</" + this.tagName + ">").appendNewLine();
};
function ElementSerializer(parent, propertyDescriptor) {
  this.body = [];
  this.attrs = [];
  this.parent = parent;
  this.propertyDescriptor = propertyDescriptor;
}
ElementSerializer.prototype.build = function(element) {
  this.element = element;
  var elementDescriptor = element.$descriptor, propertyDescriptor = this.propertyDescriptor;
  var otherAttrs, properties;
  var isGeneric = elementDescriptor.isGeneric;
  if (isGeneric) {
    otherAttrs = this.parseGeneric(element);
  } else {
    otherAttrs = this.parseNsAttributes(element);
  }
  if (propertyDescriptor) {
    this.ns = this.nsPropertyTagName(propertyDescriptor);
  } else {
    this.ns = this.nsTagName(elementDescriptor);
  }
  this.tagName = this.addTagName(this.ns);
  if (!isGeneric) {
    properties = getSerializableProperties(element);
    this.parseAttributes(filterAttributes(properties));
    this.parseContainments(filterContained(properties));
  }
  this.parseGenericAttributes(element, otherAttrs);
  return this;
};
ElementSerializer.prototype.nsTagName = function(descriptor) {
  var effectiveNs = this.logNamespaceUsed(descriptor.ns);
  return getElementNs(effectiveNs, descriptor);
};
ElementSerializer.prototype.nsPropertyTagName = function(descriptor) {
  var effectiveNs = this.logNamespaceUsed(descriptor.ns);
  return getPropertyNs(effectiveNs, descriptor);
};
ElementSerializer.prototype.isLocalNs = function(ns2) {
  return ns2.uri === this.ns.uri;
};
ElementSerializer.prototype.nsAttributeName = function(element) {
  var ns2;
  if (isString(element)) {
    ns2 = parseName(element);
  } else {
    ns2 = element.ns;
  }
  if (element.inherited) {
    return { localName: ns2.localName };
  }
  var effectiveNs = this.logNamespaceUsed(ns2);
  this.getNamespaces().logUsed(effectiveNs);
  if (this.isLocalNs(effectiveNs)) {
    return { localName: ns2.localName };
  } else {
    return assign$1({ localName: ns2.localName }, effectiveNs);
  }
};
ElementSerializer.prototype.parseGeneric = function(element) {
  var self2 = this, body = this.body;
  var attributes = [];
  forEach$1(element, function(val, key) {
    var nonNsAttr;
    if (key === "$body") {
      body.push(new BodySerializer().build({ type: "String" }, val));
    } else if (key === "$children") {
      forEach$1(val, function(child) {
        body.push(new ElementSerializer(self2).build(child));
      });
    } else if (key.indexOf("$") !== 0) {
      nonNsAttr = self2.parseNsAttribute(element, key, val);
      if (nonNsAttr) {
        attributes.push({ name: key, value: val });
      }
    }
  });
  return attributes;
};
ElementSerializer.prototype.parseNsAttribute = function(element, name2, value) {
  var model = element.$model;
  var nameNs = parseName(name2);
  var ns2;
  if (nameNs.prefix === "xmlns") {
    ns2 = { prefix: nameNs.localName, uri: value };
  }
  if (!nameNs.prefix && nameNs.localName === "xmlns") {
    ns2 = { uri: value };
  }
  if (!ns2) {
    return {
      name: name2,
      value
    };
  }
  if (model && model.getPackage(value)) {
    this.logNamespace(ns2, true, true);
  } else {
    var actualNs = this.logNamespaceUsed(ns2, true);
    this.getNamespaces().logUsed(actualNs);
  }
};
ElementSerializer.prototype.parseNsAttributes = function(element, attrs) {
  var self2 = this;
  var genericAttrs = element.$attrs;
  var attributes = [];
  forEach$1(genericAttrs, function(value, name2) {
    var nonNsAttr = self2.parseNsAttribute(element, name2, value);
    if (nonNsAttr) {
      attributes.push(nonNsAttr);
    }
  });
  return attributes;
};
ElementSerializer.prototype.parseGenericAttributes = function(element, attributes) {
  var self2 = this;
  forEach$1(attributes, function(attr2) {
    if (attr2.name === XSI_TYPE) {
      return;
    }
    try {
      self2.addAttribute(self2.nsAttributeName(attr2.name), attr2.value);
    } catch (e2) {
      console.warn(
        "missing namespace information for ",
        attr2.name,
        "=",
        attr2.value,
        "on",
        element,
        e2
      );
    }
  });
};
ElementSerializer.prototype.parseContainments = function(properties) {
  var self2 = this, body = this.body, element = this.element;
  forEach$1(properties, function(p2) {
    var value = element.get(p2.name), isReference = p2.isReference, isMany = p2.isMany;
    if (!isMany) {
      value = [value];
    }
    if (p2.isBody) {
      body.push(new BodySerializer().build(p2, value[0]));
    } else if (isSimple(p2.type)) {
      forEach$1(value, function(v2) {
        body.push(new ValueSerializer(self2.addTagName(self2.nsPropertyTagName(p2))).build(p2, v2));
      });
    } else if (isReference) {
      forEach$1(value, function(v2) {
        body.push(new ReferenceSerializer(self2.addTagName(self2.nsPropertyTagName(p2))).build(v2));
      });
    } else {
      var asType = serializeAsType(p2), asProperty = serializeAsProperty(p2);
      forEach$1(value, function(v2) {
        var serializer;
        if (asType) {
          serializer = new TypeSerializer(self2, p2);
        } else if (asProperty) {
          serializer = new ElementSerializer(self2, p2);
        } else {
          serializer = new ElementSerializer(self2);
        }
        body.push(serializer.build(v2));
      });
    }
  });
};
ElementSerializer.prototype.getNamespaces = function(local) {
  var namespaces = this.namespaces, parent = this.parent, parentNamespaces;
  if (!namespaces) {
    parentNamespaces = parent && parent.getNamespaces();
    if (local || !parentNamespaces) {
      this.namespaces = namespaces = new Namespaces(parentNamespaces);
    } else {
      namespaces = parentNamespaces;
    }
  }
  return namespaces;
};
ElementSerializer.prototype.logNamespace = function(ns2, wellknown, local) {
  var namespaces = this.getNamespaces(local);
  var nsUri = ns2.uri, nsPrefix = ns2.prefix;
  var existing = namespaces.byUri(nsUri);
  if (!existing || local) {
    namespaces.add(ns2, wellknown);
  }
  namespaces.mapPrefix(nsPrefix, nsUri);
  return ns2;
};
ElementSerializer.prototype.logNamespaceUsed = function(ns2, local) {
  var element = this.element, model = element.$model, namespaces = this.getNamespaces(local);
  var prefix2 = ns2.prefix, uri2 = ns2.uri, newPrefix, idx, wellknownUri;
  if (!prefix2 && !uri2) {
    return { localName: ns2.localName };
  }
  wellknownUri = DEFAULT_NS_MAP[prefix2] || model && (model.getPackage(prefix2) || {}).uri;
  uri2 = uri2 || wellknownUri || namespaces.uriByPrefix(prefix2);
  if (!uri2) {
    throw new Error("no namespace uri given for prefix <" + prefix2 + ">");
  }
  ns2 = namespaces.byUri(uri2);
  if (!ns2) {
    newPrefix = prefix2;
    idx = 1;
    while (namespaces.uriByPrefix(newPrefix)) {
      newPrefix = prefix2 + "_" + idx++;
    }
    ns2 = this.logNamespace({ prefix: newPrefix, uri: uri2 }, wellknownUri === uri2);
  }
  if (prefix2) {
    namespaces.mapPrefix(prefix2, uri2);
  }
  return ns2;
};
ElementSerializer.prototype.parseAttributes = function(properties) {
  var self2 = this, element = this.element;
  forEach$1(properties, function(p2) {
    var value = element.get(p2.name);
    if (p2.isReference) {
      if (!p2.isMany) {
        value = value.id;
      } else {
        var values2 = [];
        forEach$1(value, function(v2) {
          values2.push(v2.id);
        });
        value = values2.join(" ");
      }
    }
    self2.addAttribute(self2.nsAttributeName(p2), value);
  });
};
ElementSerializer.prototype.addTagName = function(nsTagName) {
  var actualNs = this.logNamespaceUsed(nsTagName);
  this.getNamespaces().logUsed(actualNs);
  return nsName(nsTagName);
};
ElementSerializer.prototype.addAttribute = function(name2, value) {
  var attrs = this.attrs;
  if (isString(value)) {
    value = escapeAttr(value);
  }
  var idx = findIndex(attrs, function(element) {
    return element.name.localName === name2.localName && element.name.uri === name2.uri && element.name.prefix === name2.prefix;
  });
  var attr2 = { name: name2, value };
  if (idx !== -1) {
    attrs.splice(idx, 1, attr2);
  } else {
    attrs.push(attr2);
  }
};
ElementSerializer.prototype.serializeAttributes = function(writer) {
  var attrs = this.attrs, namespaces = this.namespaces;
  if (namespaces) {
    attrs = getNsAttrs(namespaces).concat(attrs);
  }
  forEach$1(attrs, function(a2) {
    writer.append(" ").append(nsName(a2.name)).append('="').append(a2.value).append('"');
  });
};
ElementSerializer.prototype.serializeTo = function(writer) {
  var firstBody = this.body[0], indent = firstBody && firstBody.constructor !== BodySerializer;
  writer.appendIndent().append("<" + this.tagName);
  this.serializeAttributes(writer);
  writer.append(firstBody ? ">" : " />");
  if (firstBody) {
    if (indent) {
      writer.appendNewLine().indent();
    }
    forEach$1(this.body, function(b2) {
      b2.serializeTo(writer);
    });
    if (indent) {
      writer.unindent().appendIndent();
    }
    writer.append("</" + this.tagName + ">");
  }
  writer.appendNewLine();
};
function TypeSerializer(parent, propertyDescriptor) {
  ElementSerializer.call(this, parent, propertyDescriptor);
}
inherits(TypeSerializer, ElementSerializer);
TypeSerializer.prototype.parseNsAttributes = function(element) {
  var attributes = ElementSerializer.prototype.parseNsAttributes.call(this, element);
  var descriptor = element.$descriptor;
  if (descriptor.name === this.propertyDescriptor.type) {
    return attributes;
  }
  var typeNs = this.typeNs = this.nsTagName(descriptor);
  this.getNamespaces().logUsed(this.typeNs);
  var pkg = element.$model.getPackage(typeNs.uri), typePrefix = pkg.xml && pkg.xml.typePrefix || "";
  this.addAttribute(
    this.nsAttributeName(XSI_TYPE),
    (typeNs.prefix ? typeNs.prefix + ":" : "") + typePrefix + descriptor.ns.localName
  );
  return attributes;
};
TypeSerializer.prototype.isLocalNs = function(ns2) {
  return ns2.uri === (this.typeNs || this.ns).uri;
};
function SavingWriter() {
  this.value = "";
  this.write = function(str) {
    this.value += str;
  };
}
function FormatingWriter(out, format2) {
  var indent = [""];
  this.append = function(str) {
    out.write(str);
    return this;
  };
  this.appendNewLine = function() {
    if (format2) {
      out.write("\n");
    }
    return this;
  };
  this.appendIndent = function() {
    if (format2) {
      out.write(indent.join("  "));
    }
    return this;
  };
  this.indent = function() {
    indent.push("");
    return this;
  };
  this.unindent = function() {
    indent.pop();
    return this;
  };
}
function Writer(options) {
  options = assign$1({ format: false, preamble: true }, options || {});
  function toXML(tree, writer) {
    var internalWriter = writer || new SavingWriter();
    var formatingWriter = new FormatingWriter(internalWriter, options.format);
    if (options.preamble) {
      formatingWriter.append(XML_PREAMBLE);
    }
    new ElementSerializer().build(tree).serializeTo(formatingWriter);
    if (!writer) {
      return internalWriter.value;
    }
  }
  return {
    toXML
  };
}
function BpmnModdle(packages2, options) {
  Moddle.call(this, packages2, options);
}
BpmnModdle.prototype = Object.create(Moddle.prototype);
BpmnModdle.prototype.fromXML = function(xmlStr, typeName, options) {
  if (!isString(typeName)) {
    options = typeName;
    typeName = "bpmn:Definitions";
  }
  var reader = new Reader(assign$1({ model: this, lax: true }, options));
  var rootHandler = reader.handler(typeName);
  return reader.fromXML(xmlStr, rootHandler);
};
BpmnModdle.prototype.toXML = function(element, options) {
  var writer = new Writer(options);
  return new Promise(function(resolve, reject) {
    try {
      var result = writer.toXML(element);
      return resolve({
        xml: result
      });
    } catch (err) {
      return reject(err);
    }
  });
};
var name$5 = "BPMN20";
var uri$5 = "http://www.omg.org/spec/BPMN/20100524/MODEL";
var prefix$5 = "bpmn";
var associations$5 = [];
var types$5 = [
  {
    name: "Interface",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "operations",
        type: "Operation",
        isMany: true
      },
      {
        name: "implementationRef",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Operation",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "inMessageRef",
        type: "Message",
        isReference: true
      },
      {
        name: "outMessageRef",
        type: "Message",
        isReference: true
      },
      {
        name: "errorRef",
        type: "Error",
        isMany: true,
        isReference: true
      },
      {
        name: "implementationRef",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "EndPoint",
    superClass: [
      "RootElement"
    ]
  },
  {
    name: "Auditing",
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "GlobalTask",
    superClass: [
      "CallableElement"
    ],
    properties: [
      {
        name: "resources",
        type: "ResourceRole",
        isMany: true
      }
    ]
  },
  {
    name: "Monitoring",
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "Performer",
    superClass: [
      "ResourceRole"
    ]
  },
  {
    name: "Process",
    superClass: [
      "FlowElementsContainer",
      "CallableElement"
    ],
    properties: [
      {
        name: "processType",
        type: "ProcessType",
        isAttr: true
      },
      {
        name: "isClosed",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "auditing",
        type: "Auditing"
      },
      {
        name: "monitoring",
        type: "Monitoring"
      },
      {
        name: "properties",
        type: "Property",
        isMany: true
      },
      {
        name: "laneSets",
        isMany: true,
        replaces: "FlowElementsContainer#laneSets",
        type: "LaneSet"
      },
      {
        name: "flowElements",
        isMany: true,
        replaces: "FlowElementsContainer#flowElements",
        type: "FlowElement"
      },
      {
        name: "artifacts",
        type: "Artifact",
        isMany: true
      },
      {
        name: "resources",
        type: "ResourceRole",
        isMany: true
      },
      {
        name: "correlationSubscriptions",
        type: "CorrelationSubscription",
        isMany: true
      },
      {
        name: "supports",
        type: "Process",
        isMany: true,
        isReference: true
      },
      {
        name: "definitionalCollaborationRef",
        type: "Collaboration",
        isAttr: true,
        isReference: true
      },
      {
        name: "isExecutable",
        isAttr: true,
        type: "Boolean"
      }
    ]
  },
  {
    name: "LaneSet",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "lanes",
        type: "Lane",
        isMany: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Lane",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "partitionElementRef",
        type: "BaseElement",
        isAttr: true,
        isReference: true
      },
      {
        name: "partitionElement",
        type: "BaseElement"
      },
      {
        name: "flowNodeRef",
        type: "FlowNode",
        isMany: true,
        isReference: true
      },
      {
        name: "childLaneSet",
        type: "LaneSet",
        xml: {
          serialize: "xsi:type"
        }
      }
    ]
  },
  {
    name: "GlobalManualTask",
    superClass: [
      "GlobalTask"
    ]
  },
  {
    name: "ManualTask",
    superClass: [
      "Task"
    ]
  },
  {
    name: "UserTask",
    superClass: [
      "Task"
    ],
    properties: [
      {
        name: "renderings",
        type: "Rendering",
        isMany: true
      },
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Rendering",
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "HumanPerformer",
    superClass: [
      "Performer"
    ]
  },
  {
    name: "PotentialOwner",
    superClass: [
      "HumanPerformer"
    ]
  },
  {
    name: "GlobalUserTask",
    superClass: [
      "GlobalTask"
    ],
    properties: [
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      },
      {
        name: "renderings",
        type: "Rendering",
        isMany: true
      }
    ]
  },
  {
    name: "Gateway",
    isAbstract: true,
    superClass: [
      "FlowNode"
    ],
    properties: [
      {
        name: "gatewayDirection",
        type: "GatewayDirection",
        "default": "Unspecified",
        isAttr: true
      }
    ]
  },
  {
    name: "EventBasedGateway",
    superClass: [
      "Gateway"
    ],
    properties: [
      {
        name: "instantiate",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "eventGatewayType",
        type: "EventBasedGatewayType",
        isAttr: true,
        "default": "Exclusive"
      }
    ]
  },
  {
    name: "ComplexGateway",
    superClass: [
      "Gateway"
    ],
    properties: [
      {
        name: "activationCondition",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "default",
        type: "SequenceFlow",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ExclusiveGateway",
    superClass: [
      "Gateway"
    ],
    properties: [
      {
        name: "default",
        type: "SequenceFlow",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "InclusiveGateway",
    superClass: [
      "Gateway"
    ],
    properties: [
      {
        name: "default",
        type: "SequenceFlow",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ParallelGateway",
    superClass: [
      "Gateway"
    ]
  },
  {
    name: "RootElement",
    isAbstract: true,
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "Relationship",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "type",
        isAttr: true,
        type: "String"
      },
      {
        name: "direction",
        type: "RelationshipDirection",
        isAttr: true
      },
      {
        name: "source",
        isMany: true,
        isReference: true,
        type: "Element"
      },
      {
        name: "target",
        isMany: true,
        isReference: true,
        type: "Element"
      }
    ]
  },
  {
    name: "BaseElement",
    isAbstract: true,
    properties: [
      {
        name: "id",
        isAttr: true,
        type: "String",
        isId: true
      },
      {
        name: "documentation",
        type: "Documentation",
        isMany: true
      },
      {
        name: "extensionDefinitions",
        type: "ExtensionDefinition",
        isMany: true,
        isReference: true
      },
      {
        name: "extensionElements",
        type: "ExtensionElements"
      }
    ]
  },
  {
    name: "Extension",
    properties: [
      {
        name: "mustUnderstand",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "definition",
        type: "ExtensionDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ExtensionDefinition",
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "extensionAttributeDefinitions",
        type: "ExtensionAttributeDefinition",
        isMany: true
      }
    ]
  },
  {
    name: "ExtensionAttributeDefinition",
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "type",
        isAttr: true,
        type: "String"
      },
      {
        name: "isReference",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "extensionDefinition",
        type: "ExtensionDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ExtensionElements",
    properties: [
      {
        name: "valueRef",
        isAttr: true,
        isReference: true,
        type: "Element"
      },
      {
        name: "values",
        type: "Element",
        isMany: true
      },
      {
        name: "extensionAttributeDefinition",
        type: "ExtensionAttributeDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Documentation",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "text",
        type: "String",
        isBody: true
      },
      {
        name: "textFormat",
        "default": "text/plain",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Event",
    isAbstract: true,
    superClass: [
      "FlowNode",
      "InteractionNode"
    ],
    properties: [
      {
        name: "properties",
        type: "Property",
        isMany: true
      }
    ]
  },
  {
    name: "IntermediateCatchEvent",
    superClass: [
      "CatchEvent"
    ]
  },
  {
    name: "IntermediateThrowEvent",
    superClass: [
      "ThrowEvent"
    ]
  },
  {
    name: "EndEvent",
    superClass: [
      "ThrowEvent"
    ]
  },
  {
    name: "StartEvent",
    superClass: [
      "CatchEvent"
    ],
    properties: [
      {
        name: "isInterrupting",
        "default": true,
        isAttr: true,
        type: "Boolean"
      }
    ]
  },
  {
    name: "ThrowEvent",
    isAbstract: true,
    superClass: [
      "Event"
    ],
    properties: [
      {
        name: "dataInputs",
        type: "DataInput",
        isMany: true
      },
      {
        name: "dataInputAssociations",
        type: "DataInputAssociation",
        isMany: true
      },
      {
        name: "inputSet",
        type: "InputSet"
      },
      {
        name: "eventDefinitions",
        type: "EventDefinition",
        isMany: true
      },
      {
        name: "eventDefinitionRef",
        type: "EventDefinition",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "CatchEvent",
    isAbstract: true,
    superClass: [
      "Event"
    ],
    properties: [
      {
        name: "parallelMultiple",
        isAttr: true,
        type: "Boolean",
        "default": false
      },
      {
        name: "dataOutputs",
        type: "DataOutput",
        isMany: true
      },
      {
        name: "dataOutputAssociations",
        type: "DataOutputAssociation",
        isMany: true
      },
      {
        name: "outputSet",
        type: "OutputSet"
      },
      {
        name: "eventDefinitions",
        type: "EventDefinition",
        isMany: true
      },
      {
        name: "eventDefinitionRef",
        type: "EventDefinition",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "BoundaryEvent",
    superClass: [
      "CatchEvent"
    ],
    properties: [
      {
        name: "cancelActivity",
        "default": true,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "attachedToRef",
        type: "Activity",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "EventDefinition",
    isAbstract: true,
    superClass: [
      "RootElement"
    ]
  },
  {
    name: "CancelEventDefinition",
    superClass: [
      "EventDefinition"
    ]
  },
  {
    name: "ErrorEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "errorRef",
        type: "Error",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "TerminateEventDefinition",
    superClass: [
      "EventDefinition"
    ]
  },
  {
    name: "EscalationEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "escalationRef",
        type: "Escalation",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Escalation",
    properties: [
      {
        name: "structureRef",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "escalationCode",
        isAttr: true,
        type: "String"
      }
    ],
    superClass: [
      "RootElement"
    ]
  },
  {
    name: "CompensateEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "waitForCompletion",
        isAttr: true,
        type: "Boolean",
        "default": true
      },
      {
        name: "activityRef",
        type: "Activity",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "TimerEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "timeDate",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "timeCycle",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "timeDuration",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      }
    ]
  },
  {
    name: "LinkEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "target",
        type: "LinkEventDefinition",
        isReference: true
      },
      {
        name: "source",
        type: "LinkEventDefinition",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "MessageEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "messageRef",
        type: "Message",
        isAttr: true,
        isReference: true
      },
      {
        name: "operationRef",
        type: "Operation",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ConditionalEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "condition",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      }
    ]
  },
  {
    name: "SignalEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "signalRef",
        type: "Signal",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Signal",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "structureRef",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ImplicitThrowEvent",
    superClass: [
      "ThrowEvent"
    ]
  },
  {
    name: "DataState",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ItemAwareElement",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "itemSubjectRef",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      },
      {
        name: "dataState",
        type: "DataState"
      }
    ]
  },
  {
    name: "DataAssociation",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "sourceRef",
        type: "ItemAwareElement",
        isMany: true,
        isReference: true
      },
      {
        name: "targetRef",
        type: "ItemAwareElement",
        isReference: true
      },
      {
        name: "transformation",
        type: "FormalExpression",
        xml: {
          serialize: "property"
        }
      },
      {
        name: "assignment",
        type: "Assignment",
        isMany: true
      }
    ]
  },
  {
    name: "DataInput",
    superClass: [
      "ItemAwareElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "isCollection",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "inputSetRef",
        type: "InputSet",
        isMany: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "inputSetWithOptional",
        type: "InputSet",
        isMany: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "inputSetWithWhileExecuting",
        type: "InputSet",
        isMany: true,
        isVirtual: true,
        isReference: true
      }
    ]
  },
  {
    name: "DataOutput",
    superClass: [
      "ItemAwareElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "isCollection",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "outputSetRef",
        type: "OutputSet",
        isMany: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "outputSetWithOptional",
        type: "OutputSet",
        isMany: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "outputSetWithWhileExecuting",
        type: "OutputSet",
        isMany: true,
        isVirtual: true,
        isReference: true
      }
    ]
  },
  {
    name: "InputSet",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "dataInputRefs",
        type: "DataInput",
        isMany: true,
        isReference: true
      },
      {
        name: "optionalInputRefs",
        type: "DataInput",
        isMany: true,
        isReference: true
      },
      {
        name: "whileExecutingInputRefs",
        type: "DataInput",
        isMany: true,
        isReference: true
      },
      {
        name: "outputSetRefs",
        type: "OutputSet",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "OutputSet",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "dataOutputRefs",
        type: "DataOutput",
        isMany: true,
        isReference: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "inputSetRefs",
        type: "InputSet",
        isMany: true,
        isReference: true
      },
      {
        name: "optionalOutputRefs",
        type: "DataOutput",
        isMany: true,
        isReference: true
      },
      {
        name: "whileExecutingOutputRefs",
        type: "DataOutput",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "Property",
    superClass: [
      "ItemAwareElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "DataInputAssociation",
    superClass: [
      "DataAssociation"
    ]
  },
  {
    name: "DataOutputAssociation",
    superClass: [
      "DataAssociation"
    ]
  },
  {
    name: "InputOutputSpecification",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "dataInputs",
        type: "DataInput",
        isMany: true
      },
      {
        name: "dataOutputs",
        type: "DataOutput",
        isMany: true
      },
      {
        name: "inputSets",
        type: "InputSet",
        isMany: true
      },
      {
        name: "outputSets",
        type: "OutputSet",
        isMany: true
      }
    ]
  },
  {
    name: "DataObject",
    superClass: [
      "FlowElement",
      "ItemAwareElement"
    ],
    properties: [
      {
        name: "isCollection",
        "default": false,
        isAttr: true,
        type: "Boolean"
      }
    ]
  },
  {
    name: "InputOutputBinding",
    properties: [
      {
        name: "inputDataRef",
        type: "InputSet",
        isAttr: true,
        isReference: true
      },
      {
        name: "outputDataRef",
        type: "OutputSet",
        isAttr: true,
        isReference: true
      },
      {
        name: "operationRef",
        type: "Operation",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Assignment",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "from",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "to",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      }
    ]
  },
  {
    name: "DataStore",
    superClass: [
      "RootElement",
      "ItemAwareElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "capacity",
        isAttr: true,
        type: "Integer"
      },
      {
        name: "isUnlimited",
        "default": true,
        isAttr: true,
        type: "Boolean"
      }
    ]
  },
  {
    name: "DataStoreReference",
    superClass: [
      "ItemAwareElement",
      "FlowElement"
    ],
    properties: [
      {
        name: "dataStoreRef",
        type: "DataStore",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "DataObjectReference",
    superClass: [
      "ItemAwareElement",
      "FlowElement"
    ],
    properties: [
      {
        name: "dataObjectRef",
        type: "DataObject",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ConversationLink",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "sourceRef",
        type: "InteractionNode",
        isAttr: true,
        isReference: true
      },
      {
        name: "targetRef",
        type: "InteractionNode",
        isAttr: true,
        isReference: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ConversationAssociation",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "innerConversationNodeRef",
        type: "ConversationNode",
        isAttr: true,
        isReference: true
      },
      {
        name: "outerConversationNodeRef",
        type: "ConversationNode",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "CallConversation",
    superClass: [
      "ConversationNode"
    ],
    properties: [
      {
        name: "calledCollaborationRef",
        type: "Collaboration",
        isAttr: true,
        isReference: true
      },
      {
        name: "participantAssociations",
        type: "ParticipantAssociation",
        isMany: true
      }
    ]
  },
  {
    name: "Conversation",
    superClass: [
      "ConversationNode"
    ]
  },
  {
    name: "SubConversation",
    superClass: [
      "ConversationNode"
    ],
    properties: [
      {
        name: "conversationNodes",
        type: "ConversationNode",
        isMany: true
      }
    ]
  },
  {
    name: "ConversationNode",
    isAbstract: true,
    superClass: [
      "InteractionNode",
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "participantRef",
        type: "Participant",
        isMany: true,
        isReference: true
      },
      {
        name: "messageFlowRefs",
        type: "MessageFlow",
        isMany: true,
        isReference: true
      },
      {
        name: "correlationKeys",
        type: "CorrelationKey",
        isMany: true
      }
    ]
  },
  {
    name: "GlobalConversation",
    superClass: [
      "Collaboration"
    ]
  },
  {
    name: "PartnerEntity",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "participantRef",
        type: "Participant",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "PartnerRole",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "participantRef",
        type: "Participant",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "CorrelationProperty",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "correlationPropertyRetrievalExpression",
        type: "CorrelationPropertyRetrievalExpression",
        isMany: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "type",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Error",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "structureRef",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "errorCode",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "CorrelationKey",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "correlationPropertyRef",
        type: "CorrelationProperty",
        isMany: true,
        isReference: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Expression",
    superClass: [
      "BaseElement"
    ],
    isAbstract: false,
    properties: [
      {
        name: "body",
        isBody: true,
        type: "String"
      }
    ]
  },
  {
    name: "FormalExpression",
    superClass: [
      "Expression"
    ],
    properties: [
      {
        name: "language",
        isAttr: true,
        type: "String"
      },
      {
        name: "evaluatesToTypeRef",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Message",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "itemRef",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ItemDefinition",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "itemKind",
        type: "ItemKind",
        isAttr: true
      },
      {
        name: "structureRef",
        isAttr: true,
        type: "String"
      },
      {
        name: "isCollection",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "import",
        type: "Import",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "FlowElement",
    isAbstract: true,
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "auditing",
        type: "Auditing"
      },
      {
        name: "monitoring",
        type: "Monitoring"
      },
      {
        name: "categoryValueRef",
        type: "CategoryValue",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "SequenceFlow",
    superClass: [
      "FlowElement"
    ],
    properties: [
      {
        name: "isImmediate",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "conditionExpression",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "sourceRef",
        type: "FlowNode",
        isAttr: true,
        isReference: true
      },
      {
        name: "targetRef",
        type: "FlowNode",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "FlowElementsContainer",
    isAbstract: true,
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "laneSets",
        type: "LaneSet",
        isMany: true
      },
      {
        name: "flowElements",
        type: "FlowElement",
        isMany: true
      }
    ]
  },
  {
    name: "CallableElement",
    isAbstract: true,
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "ioSpecification",
        type: "InputOutputSpecification",
        xml: {
          serialize: "property"
        }
      },
      {
        name: "supportedInterfaceRef",
        type: "Interface",
        isMany: true,
        isReference: true
      },
      {
        name: "ioBinding",
        type: "InputOutputBinding",
        isMany: true,
        xml: {
          serialize: "property"
        }
      }
    ]
  },
  {
    name: "FlowNode",
    isAbstract: true,
    superClass: [
      "FlowElement"
    ],
    properties: [
      {
        name: "incoming",
        type: "SequenceFlow",
        isMany: true,
        isReference: true
      },
      {
        name: "outgoing",
        type: "SequenceFlow",
        isMany: true,
        isReference: true
      },
      {
        name: "lanes",
        type: "Lane",
        isMany: true,
        isVirtual: true,
        isReference: true
      }
    ]
  },
  {
    name: "CorrelationPropertyRetrievalExpression",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "messagePath",
        type: "FormalExpression"
      },
      {
        name: "messageRef",
        type: "Message",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "CorrelationPropertyBinding",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "dataPath",
        type: "FormalExpression"
      },
      {
        name: "correlationPropertyRef",
        type: "CorrelationProperty",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Resource",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "resourceParameters",
        type: "ResourceParameter",
        isMany: true
      }
    ]
  },
  {
    name: "ResourceParameter",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "isRequired",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "type",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "CorrelationSubscription",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "correlationKeyRef",
        type: "CorrelationKey",
        isAttr: true,
        isReference: true
      },
      {
        name: "correlationPropertyBinding",
        type: "CorrelationPropertyBinding",
        isMany: true
      }
    ]
  },
  {
    name: "MessageFlow",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "sourceRef",
        type: "InteractionNode",
        isAttr: true,
        isReference: true
      },
      {
        name: "targetRef",
        type: "InteractionNode",
        isAttr: true,
        isReference: true
      },
      {
        name: "messageRef",
        type: "Message",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "MessageFlowAssociation",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "innerMessageFlowRef",
        type: "MessageFlow",
        isAttr: true,
        isReference: true
      },
      {
        name: "outerMessageFlowRef",
        type: "MessageFlow",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "InteractionNode",
    isAbstract: true,
    properties: [
      {
        name: "incomingConversationLinks",
        type: "ConversationLink",
        isMany: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "outgoingConversationLinks",
        type: "ConversationLink",
        isMany: true,
        isVirtual: true,
        isReference: true
      }
    ]
  },
  {
    name: "Participant",
    superClass: [
      "InteractionNode",
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "interfaceRef",
        type: "Interface",
        isMany: true,
        isReference: true
      },
      {
        name: "participantMultiplicity",
        type: "ParticipantMultiplicity"
      },
      {
        name: "endPointRefs",
        type: "EndPoint",
        isMany: true,
        isReference: true
      },
      {
        name: "processRef",
        type: "Process",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ParticipantAssociation",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "innerParticipantRef",
        type: "Participant",
        isAttr: true,
        isReference: true
      },
      {
        name: "outerParticipantRef",
        type: "Participant",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ParticipantMultiplicity",
    properties: [
      {
        name: "minimum",
        "default": 0,
        isAttr: true,
        type: "Integer"
      },
      {
        name: "maximum",
        "default": 1,
        isAttr: true,
        type: "Integer"
      }
    ],
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "Collaboration",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "isClosed",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "participants",
        type: "Participant",
        isMany: true
      },
      {
        name: "messageFlows",
        type: "MessageFlow",
        isMany: true
      },
      {
        name: "artifacts",
        type: "Artifact",
        isMany: true
      },
      {
        name: "conversations",
        type: "ConversationNode",
        isMany: true
      },
      {
        name: "conversationAssociations",
        type: "ConversationAssociation"
      },
      {
        name: "participantAssociations",
        type: "ParticipantAssociation",
        isMany: true
      },
      {
        name: "messageFlowAssociations",
        type: "MessageFlowAssociation",
        isMany: true
      },
      {
        name: "correlationKeys",
        type: "CorrelationKey",
        isMany: true
      },
      {
        name: "choreographyRef",
        type: "Choreography",
        isMany: true,
        isReference: true
      },
      {
        name: "conversationLinks",
        type: "ConversationLink",
        isMany: true
      }
    ]
  },
  {
    name: "ChoreographyActivity",
    isAbstract: true,
    superClass: [
      "FlowNode"
    ],
    properties: [
      {
        name: "participantRef",
        type: "Participant",
        isMany: true,
        isReference: true
      },
      {
        name: "initiatingParticipantRef",
        type: "Participant",
        isAttr: true,
        isReference: true
      },
      {
        name: "correlationKeys",
        type: "CorrelationKey",
        isMany: true
      },
      {
        name: "loopType",
        type: "ChoreographyLoopType",
        "default": "None",
        isAttr: true
      }
    ]
  },
  {
    name: "CallChoreography",
    superClass: [
      "ChoreographyActivity"
    ],
    properties: [
      {
        name: "calledChoreographyRef",
        type: "Choreography",
        isAttr: true,
        isReference: true
      },
      {
        name: "participantAssociations",
        type: "ParticipantAssociation",
        isMany: true
      }
    ]
  },
  {
    name: "SubChoreography",
    superClass: [
      "ChoreographyActivity",
      "FlowElementsContainer"
    ],
    properties: [
      {
        name: "artifacts",
        type: "Artifact",
        isMany: true
      }
    ]
  },
  {
    name: "ChoreographyTask",
    superClass: [
      "ChoreographyActivity"
    ],
    properties: [
      {
        name: "messageFlowRef",
        type: "MessageFlow",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "Choreography",
    superClass: [
      "Collaboration",
      "FlowElementsContainer"
    ]
  },
  {
    name: "GlobalChoreographyTask",
    superClass: [
      "Choreography"
    ],
    properties: [
      {
        name: "initiatingParticipantRef",
        type: "Participant",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "TextAnnotation",
    superClass: [
      "Artifact"
    ],
    properties: [
      {
        name: "text",
        type: "String"
      },
      {
        name: "textFormat",
        "default": "text/plain",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Group",
    superClass: [
      "Artifact"
    ],
    properties: [
      {
        name: "categoryValueRef",
        type: "CategoryValue",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Association",
    superClass: [
      "Artifact"
    ],
    properties: [
      {
        name: "associationDirection",
        type: "AssociationDirection",
        isAttr: true
      },
      {
        name: "sourceRef",
        type: "BaseElement",
        isAttr: true,
        isReference: true
      },
      {
        name: "targetRef",
        type: "BaseElement",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Category",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "categoryValue",
        type: "CategoryValue",
        isMany: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Artifact",
    isAbstract: true,
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "CategoryValue",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "categorizedFlowElements",
        type: "FlowElement",
        isMany: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "value",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Activity",
    isAbstract: true,
    superClass: [
      "FlowNode"
    ],
    properties: [
      {
        name: "isForCompensation",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "default",
        type: "SequenceFlow",
        isAttr: true,
        isReference: true
      },
      {
        name: "ioSpecification",
        type: "InputOutputSpecification",
        xml: {
          serialize: "property"
        }
      },
      {
        name: "boundaryEventRefs",
        type: "BoundaryEvent",
        isMany: true,
        isReference: true
      },
      {
        name: "properties",
        type: "Property",
        isMany: true
      },
      {
        name: "dataInputAssociations",
        type: "DataInputAssociation",
        isMany: true
      },
      {
        name: "dataOutputAssociations",
        type: "DataOutputAssociation",
        isMany: true
      },
      {
        name: "startQuantity",
        "default": 1,
        isAttr: true,
        type: "Integer"
      },
      {
        name: "resources",
        type: "ResourceRole",
        isMany: true
      },
      {
        name: "completionQuantity",
        "default": 1,
        isAttr: true,
        type: "Integer"
      },
      {
        name: "loopCharacteristics",
        type: "LoopCharacteristics"
      }
    ]
  },
  {
    name: "ServiceTask",
    superClass: [
      "Task"
    ],
    properties: [
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      },
      {
        name: "operationRef",
        type: "Operation",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "SubProcess",
    superClass: [
      "Activity",
      "FlowElementsContainer",
      "InteractionNode"
    ],
    properties: [
      {
        name: "triggeredByEvent",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "artifacts",
        type: "Artifact",
        isMany: true
      }
    ]
  },
  {
    name: "LoopCharacteristics",
    isAbstract: true,
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "MultiInstanceLoopCharacteristics",
    superClass: [
      "LoopCharacteristics"
    ],
    properties: [
      {
        name: "isSequential",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "behavior",
        type: "MultiInstanceBehavior",
        "default": "All",
        isAttr: true
      },
      {
        name: "loopCardinality",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "loopDataInputRef",
        type: "ItemAwareElement",
        isReference: true
      },
      {
        name: "loopDataOutputRef",
        type: "ItemAwareElement",
        isReference: true
      },
      {
        name: "inputDataItem",
        type: "DataInput",
        xml: {
          serialize: "property"
        }
      },
      {
        name: "outputDataItem",
        type: "DataOutput",
        xml: {
          serialize: "property"
        }
      },
      {
        name: "complexBehaviorDefinition",
        type: "ComplexBehaviorDefinition",
        isMany: true
      },
      {
        name: "completionCondition",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "oneBehaviorEventRef",
        type: "EventDefinition",
        isAttr: true,
        isReference: true
      },
      {
        name: "noneBehaviorEventRef",
        type: "EventDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "StandardLoopCharacteristics",
    superClass: [
      "LoopCharacteristics"
    ],
    properties: [
      {
        name: "testBefore",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "loopCondition",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "loopMaximum",
        type: "Integer",
        isAttr: true
      }
    ]
  },
  {
    name: "CallActivity",
    superClass: [
      "Activity",
      "InteractionNode"
    ],
    properties: [
      {
        name: "calledElement",
        type: "String",
        isAttr: true
      }
    ]
  },
  {
    name: "Task",
    superClass: [
      "Activity",
      "InteractionNode"
    ]
  },
  {
    name: "SendTask",
    superClass: [
      "Task"
    ],
    properties: [
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      },
      {
        name: "operationRef",
        type: "Operation",
        isAttr: true,
        isReference: true
      },
      {
        name: "messageRef",
        type: "Message",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ReceiveTask",
    superClass: [
      "Task"
    ],
    properties: [
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      },
      {
        name: "instantiate",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "operationRef",
        type: "Operation",
        isAttr: true,
        isReference: true
      },
      {
        name: "messageRef",
        type: "Message",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ScriptTask",
    superClass: [
      "Task"
    ],
    properties: [
      {
        name: "scriptFormat",
        isAttr: true,
        type: "String"
      },
      {
        name: "script",
        type: "String"
      }
    ]
  },
  {
    name: "BusinessRuleTask",
    superClass: [
      "Task"
    ],
    properties: [
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "AdHocSubProcess",
    superClass: [
      "SubProcess"
    ],
    properties: [
      {
        name: "completionCondition",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "ordering",
        type: "AdHocOrdering",
        isAttr: true
      },
      {
        name: "cancelRemainingInstances",
        "default": true,
        isAttr: true,
        type: "Boolean"
      }
    ]
  },
  {
    name: "Transaction",
    superClass: [
      "SubProcess"
    ],
    properties: [
      {
        name: "protocol",
        isAttr: true,
        type: "String"
      },
      {
        name: "method",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "GlobalScriptTask",
    superClass: [
      "GlobalTask"
    ],
    properties: [
      {
        name: "scriptLanguage",
        isAttr: true,
        type: "String"
      },
      {
        name: "script",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "GlobalBusinessRuleTask",
    superClass: [
      "GlobalTask"
    ],
    properties: [
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ComplexBehaviorDefinition",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "condition",
        type: "FormalExpression"
      },
      {
        name: "event",
        type: "ImplicitThrowEvent"
      }
    ]
  },
  {
    name: "ResourceRole",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "resourceRef",
        type: "Resource",
        isReference: true
      },
      {
        name: "resourceParameterBindings",
        type: "ResourceParameterBinding",
        isMany: true
      },
      {
        name: "resourceAssignmentExpression",
        type: "ResourceAssignmentExpression"
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ResourceParameterBinding",
    properties: [
      {
        name: "expression",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "parameterRef",
        type: "ResourceParameter",
        isAttr: true,
        isReference: true
      }
    ],
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "ResourceAssignmentExpression",
    properties: [
      {
        name: "expression",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      }
    ],
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "Import",
    properties: [
      {
        name: "importType",
        isAttr: true,
        type: "String"
      },
      {
        name: "location",
        isAttr: true,
        type: "String"
      },
      {
        name: "namespace",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Definitions",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "targetNamespace",
        isAttr: true,
        type: "String"
      },
      {
        name: "expressionLanguage",
        "default": "http://www.w3.org/1999/XPath",
        isAttr: true,
        type: "String"
      },
      {
        name: "typeLanguage",
        "default": "http://www.w3.org/2001/XMLSchema",
        isAttr: true,
        type: "String"
      },
      {
        name: "imports",
        type: "Import",
        isMany: true
      },
      {
        name: "extensions",
        type: "Extension",
        isMany: true
      },
      {
        name: "rootElements",
        type: "RootElement",
        isMany: true
      },
      {
        name: "diagrams",
        isMany: true,
        type: "bpmndi:BPMNDiagram"
      },
      {
        name: "exporter",
        isAttr: true,
        type: "String"
      },
      {
        name: "relationships",
        type: "Relationship",
        isMany: true
      },
      {
        name: "exporterVersion",
        isAttr: true,
        type: "String"
      }
    ]
  }
];
var enumerations$3 = [
  {
    name: "ProcessType",
    literalValues: [
      {
        name: "None"
      },
      {
        name: "Public"
      },
      {
        name: "Private"
      }
    ]
  },
  {
    name: "GatewayDirection",
    literalValues: [
      {
        name: "Unspecified"
      },
      {
        name: "Converging"
      },
      {
        name: "Diverging"
      },
      {
        name: "Mixed"
      }
    ]
  },
  {
    name: "EventBasedGatewayType",
    literalValues: [
      {
        name: "Parallel"
      },
      {
        name: "Exclusive"
      }
    ]
  },
  {
    name: "RelationshipDirection",
    literalValues: [
      {
        name: "None"
      },
      {
        name: "Forward"
      },
      {
        name: "Backward"
      },
      {
        name: "Both"
      }
    ]
  },
  {
    name: "ItemKind",
    literalValues: [
      {
        name: "Physical"
      },
      {
        name: "Information"
      }
    ]
  },
  {
    name: "ChoreographyLoopType",
    literalValues: [
      {
        name: "None"
      },
      {
        name: "Standard"
      },
      {
        name: "MultiInstanceSequential"
      },
      {
        name: "MultiInstanceParallel"
      }
    ]
  },
  {
    name: "AssociationDirection",
    literalValues: [
      {
        name: "None"
      },
      {
        name: "One"
      },
      {
        name: "Both"
      }
    ]
  },
  {
    name: "MultiInstanceBehavior",
    literalValues: [
      {
        name: "None"
      },
      {
        name: "One"
      },
      {
        name: "All"
      },
      {
        name: "Complex"
      }
    ]
  },
  {
    name: "AdHocOrdering",
    literalValues: [
      {
        name: "Parallel"
      },
      {
        name: "Sequential"
      }
    ]
  }
];
var xml$1 = {
  tagAlias: "lowerCase",
  typePrefix: "t"
};
var BpmnPackage = {
  name: name$5,
  uri: uri$5,
  prefix: prefix$5,
  associations: associations$5,
  types: types$5,
  enumerations: enumerations$3,
  xml: xml$1
};
var name$4 = "BPMNDI";
var uri$4 = "http://www.omg.org/spec/BPMN/20100524/DI";
var prefix$4 = "bpmndi";
var types$4 = [
  {
    name: "BPMNDiagram",
    properties: [
      {
        name: "plane",
        type: "BPMNPlane",
        redefines: "di:Diagram#rootElement"
      },
      {
        name: "labelStyle",
        type: "BPMNLabelStyle",
        isMany: true
      }
    ],
    superClass: [
      "di:Diagram"
    ]
  },
  {
    name: "BPMNPlane",
    properties: [
      {
        name: "bpmnElement",
        isAttr: true,
        isReference: true,
        type: "bpmn:BaseElement",
        redefines: "di:DiagramElement#modelElement"
      }
    ],
    superClass: [
      "di:Plane"
    ]
  },
  {
    name: "BPMNShape",
    properties: [
      {
        name: "bpmnElement",
        isAttr: true,
        isReference: true,
        type: "bpmn:BaseElement",
        redefines: "di:DiagramElement#modelElement"
      },
      {
        name: "isHorizontal",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "isExpanded",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "isMarkerVisible",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "label",
        type: "BPMNLabel"
      },
      {
        name: "isMessageVisible",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "participantBandKind",
        type: "ParticipantBandKind",
        isAttr: true
      },
      {
        name: "choreographyActivityShape",
        type: "BPMNShape",
        isAttr: true,
        isReference: true
      }
    ],
    superClass: [
      "di:LabeledShape"
    ]
  },
  {
    name: "BPMNEdge",
    properties: [
      {
        name: "label",
        type: "BPMNLabel"
      },
      {
        name: "bpmnElement",
        isAttr: true,
        isReference: true,
        type: "bpmn:BaseElement",
        redefines: "di:DiagramElement#modelElement"
      },
      {
        name: "sourceElement",
        isAttr: true,
        isReference: true,
        type: "di:DiagramElement",
        redefines: "di:Edge#source"
      },
      {
        name: "targetElement",
        isAttr: true,
        isReference: true,
        type: "di:DiagramElement",
        redefines: "di:Edge#target"
      },
      {
        name: "messageVisibleKind",
        type: "MessageVisibleKind",
        isAttr: true,
        "default": "initiating"
      }
    ],
    superClass: [
      "di:LabeledEdge"
    ]
  },
  {
    name: "BPMNLabel",
    properties: [
      {
        name: "labelStyle",
        type: "BPMNLabelStyle",
        isAttr: true,
        isReference: true,
        redefines: "di:DiagramElement#style"
      }
    ],
    superClass: [
      "di:Label"
    ]
  },
  {
    name: "BPMNLabelStyle",
    properties: [
      {
        name: "font",
        type: "dc:Font"
      }
    ],
    superClass: [
      "di:Style"
    ]
  }
];
var enumerations$2 = [
  {
    name: "ParticipantBandKind",
    literalValues: [
      {
        name: "top_initiating"
      },
      {
        name: "middle_initiating"
      },
      {
        name: "bottom_initiating"
      },
      {
        name: "top_non_initiating"
      },
      {
        name: "middle_non_initiating"
      },
      {
        name: "bottom_non_initiating"
      }
    ]
  },
  {
    name: "MessageVisibleKind",
    literalValues: [
      {
        name: "initiating"
      },
      {
        name: "non_initiating"
      }
    ]
  }
];
var associations$4 = [];
var BpmnDiPackage = {
  name: name$4,
  uri: uri$4,
  prefix: prefix$4,
  types: types$4,
  enumerations: enumerations$2,
  associations: associations$4
};
var name$3 = "DC";
var uri$3 = "http://www.omg.org/spec/DD/20100524/DC";
var prefix$3 = "dc";
var types$3 = [
  {
    name: "Boolean"
  },
  {
    name: "Integer"
  },
  {
    name: "Real"
  },
  {
    name: "String"
  },
  {
    name: "Font",
    properties: [
      {
        name: "name",
        type: "String",
        isAttr: true
      },
      {
        name: "size",
        type: "Real",
        isAttr: true
      },
      {
        name: "isBold",
        type: "Boolean",
        isAttr: true
      },
      {
        name: "isItalic",
        type: "Boolean",
        isAttr: true
      },
      {
        name: "isUnderline",
        type: "Boolean",
        isAttr: true
      },
      {
        name: "isStrikeThrough",
        type: "Boolean",
        isAttr: true
      }
    ]
  },
  {
    name: "Point",
    properties: [
      {
        name: "x",
        type: "Real",
        "default": "0",
        isAttr: true
      },
      {
        name: "y",
        type: "Real",
        "default": "0",
        isAttr: true
      }
    ]
  },
  {
    name: "Bounds",
    properties: [
      {
        name: "x",
        type: "Real",
        "default": "0",
        isAttr: true
      },
      {
        name: "y",
        type: "Real",
        "default": "0",
        isAttr: true
      },
      {
        name: "width",
        type: "Real",
        isAttr: true
      },
      {
        name: "height",
        type: "Real",
        isAttr: true
      }
    ]
  }
];
var associations$3 = [];
var DcPackage = {
  name: name$3,
  uri: uri$3,
  prefix: prefix$3,
  types: types$3,
  associations: associations$3
};
var name$2 = "DI";
var uri$2 = "http://www.omg.org/spec/DD/20100524/DI";
var prefix$2 = "di";
var types$2 = [
  {
    name: "DiagramElement",
    isAbstract: true,
    properties: [
      {
        name: "id",
        isAttr: true,
        isId: true,
        type: "String"
      },
      {
        name: "extension",
        type: "Extension"
      },
      {
        name: "owningDiagram",
        type: "Diagram",
        isReadOnly: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "owningElement",
        type: "DiagramElement",
        isReadOnly: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "modelElement",
        isReadOnly: true,
        isVirtual: true,
        isReference: true,
        type: "Element"
      },
      {
        name: "style",
        type: "Style",
        isReadOnly: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "ownedElement",
        type: "DiagramElement",
        isReadOnly: true,
        isMany: true,
        isVirtual: true
      }
    ]
  },
  {
    name: "Node",
    isAbstract: true,
    superClass: [
      "DiagramElement"
    ]
  },
  {
    name: "Edge",
    isAbstract: true,
    superClass: [
      "DiagramElement"
    ],
    properties: [
      {
        name: "source",
        type: "DiagramElement",
        isReadOnly: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "target",
        type: "DiagramElement",
        isReadOnly: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "waypoint",
        isUnique: false,
        isMany: true,
        type: "dc:Point",
        xml: {
          serialize: "xsi:type"
        }
      }
    ]
  },
  {
    name: "Diagram",
    isAbstract: true,
    properties: [
      {
        name: "id",
        isAttr: true,
        isId: true,
        type: "String"
      },
      {
        name: "rootElement",
        type: "DiagramElement",
        isReadOnly: true,
        isVirtual: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "documentation",
        isAttr: true,
        type: "String"
      },
      {
        name: "resolution",
        isAttr: true,
        type: "Real"
      },
      {
        name: "ownedStyle",
        type: "Style",
        isReadOnly: true,
        isMany: true,
        isVirtual: true
      }
    ]
  },
  {
    name: "Shape",
    isAbstract: true,
    superClass: [
      "Node"
    ],
    properties: [
      {
        name: "bounds",
        type: "dc:Bounds"
      }
    ]
  },
  {
    name: "Plane",
    isAbstract: true,
    superClass: [
      "Node"
    ],
    properties: [
      {
        name: "planeElement",
        type: "DiagramElement",
        subsettedProperty: "DiagramElement-ownedElement",
        isMany: true
      }
    ]
  },
  {
    name: "LabeledEdge",
    isAbstract: true,
    superClass: [
      "Edge"
    ],
    properties: [
      {
        name: "ownedLabel",
        type: "Label",
        isReadOnly: true,
        subsettedProperty: "DiagramElement-ownedElement",
        isMany: true,
        isVirtual: true
      }
    ]
  },
  {
    name: "LabeledShape",
    isAbstract: true,
    superClass: [
      "Shape"
    ],
    properties: [
      {
        name: "ownedLabel",
        type: "Label",
        isReadOnly: true,
        subsettedProperty: "DiagramElement-ownedElement",
        isMany: true,
        isVirtual: true
      }
    ]
  },
  {
    name: "Label",
    isAbstract: true,
    superClass: [
      "Node"
    ],
    properties: [
      {
        name: "bounds",
        type: "dc:Bounds"
      }
    ]
  },
  {
    name: "Style",
    isAbstract: true,
    properties: [
      {
        name: "id",
        isAttr: true,
        isId: true,
        type: "String"
      }
    ]
  },
  {
    name: "Extension",
    properties: [
      {
        name: "values",
        isMany: true,
        type: "Element"
      }
    ]
  }
];
var associations$2 = [];
var xml$2 = {
  tagAlias: "lowerCase"
};
var DiPackage = {
  name: name$2,
  uri: uri$2,
  prefix: prefix$2,
  types: types$2,
  associations: associations$2,
  xml: xml$2
};
var name$1 = "bpmn.io colors for BPMN";
var uri$1 = "http://bpmn.io/schema/bpmn/biocolor/1.0";
var prefix$1 = "bioc";
var types$1 = [
  {
    name: "ColoredShape",
    "extends": [
      "bpmndi:BPMNShape"
    ],
    properties: [
      {
        name: "stroke",
        isAttr: true,
        type: "String"
      },
      {
        name: "fill",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ColoredEdge",
    "extends": [
      "bpmndi:BPMNEdge"
    ],
    properties: [
      {
        name: "stroke",
        isAttr: true,
        type: "String"
      },
      {
        name: "fill",
        isAttr: true,
        type: "String"
      }
    ]
  }
];
var enumerations$1 = [];
var associations$1 = [];
var BiocPackage = {
  name: name$1,
  uri: uri$1,
  prefix: prefix$1,
  types: types$1,
  enumerations: enumerations$1,
  associations: associations$1
};
var name$6 = "BPMN in Color";
var uri$6 = "http://www.omg.org/spec/BPMN/non-normative/color/1.0";
var prefix$6 = "color";
var types$6 = [
  {
    name: "ColoredLabel",
    "extends": [
      "bpmndi:BPMNLabel"
    ],
    properties: [
      {
        name: "color",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ColoredShape",
    "extends": [
      "bpmndi:BPMNShape"
    ],
    properties: [
      {
        name: "background-color",
        isAttr: true,
        type: "String"
      },
      {
        name: "border-color",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ColoredEdge",
    "extends": [
      "bpmndi:BPMNEdge"
    ],
    properties: [
      {
        name: "border-color",
        isAttr: true,
        type: "String"
      }
    ]
  }
];
var enumerations = [];
var associations$6 = [];
var BpmnInColorPackage = {
  name: name$6,
  uri: uri$6,
  prefix: prefix$6,
  types: types$6,
  enumerations,
  associations: associations$6
};
var packages = {
  bpmn: BpmnPackage,
  bpmndi: BpmnDiPackage,
  dc: DcPackage,
  di: DiPackage,
  bioc: BiocPackage,
  color: BpmnInColorPackage
};
function simple(additionalPackages, options) {
  var pks = assign$1({}, packages, additionalPackages);
  return new BpmnModdle(pks, options);
}
function elementToString(e2) {
  if (!e2) {
    return "<null>";
  }
  return "<" + e2.$type + (e2.id ? ' id="' + e2.id : "") + '" />';
}
var DI_ERROR_MESSAGE = "Tried to access di from the businessObject. The di is available through the diagram element only. For more information, see https://github.com/bpmn-io/bpmn-js/issues/1472";
function ensureCompatDiRef(businessObject) {
  if (!has$1(businessObject, "di")) {
    Object.defineProperty(businessObject, "di", {
      enumerable: false,
      get: function() {
        throw new Error(DI_ERROR_MESSAGE);
      }
    });
  }
}
function is$2(element, type) {
  return element.$instanceOf(type);
}
function findDisplayCandidate(definitions) {
  return find(definitions.rootElements, function(e2) {
    return is$2(e2, "bpmn:Process") || is$2(e2, "bpmn:Collaboration");
  });
}
function BpmnTreeWalker(handler, translate2) {
  var handledElements = {};
  var deferred = [];
  var diMap = {};
  function contextual(fn, ctx) {
    return function(e2) {
      fn(e2, ctx);
    };
  }
  function handled(element) {
    handledElements[element.id] = element;
  }
  function isHandled(element) {
    return handledElements[element.id];
  }
  function visit(element, ctx) {
    var gfx = element.gfx;
    if (gfx) {
      throw new Error(
        translate2("already rendered {element}", { element: elementToString(element) })
      );
    }
    return handler.element(element, diMap[element.id], ctx);
  }
  function visitRoot(element, diagram) {
    return handler.root(element, diMap[element.id], diagram);
  }
  function visitIfDi(element, ctx) {
    try {
      var gfx = diMap[element.id] && visit(element, ctx);
      handled(element);
      return gfx;
    } catch (e2) {
      logError(e2.message, { element, error: e2 });
      console.error(translate2("failed to import {element}", { element: elementToString(element) }));
      console.error(e2);
    }
  }
  function logError(message, context) {
    handler.error(message, context);
  }
  var registerDi = this.registerDi = function registerDi2(di) {
    var bpmnElement = di.bpmnElement;
    if (bpmnElement) {
      if (diMap[bpmnElement.id]) {
        logError(
          translate2("multiple DI elements defined for {element}", {
            element: elementToString(bpmnElement)
          }),
          { element: bpmnElement }
        );
      } else {
        diMap[bpmnElement.id] = di;
        ensureCompatDiRef(bpmnElement);
      }
    } else {
      logError(
        translate2("no bpmnElement referenced in {element}", {
          element: elementToString(di)
        }),
        { element: di }
      );
    }
  };
  function handleDiagram(diagram) {
    handlePlane(diagram.plane);
  }
  function handlePlane(plane) {
    registerDi(plane);
    forEach$1(plane.planeElement, handlePlaneElement);
  }
  function handlePlaneElement(planeElement) {
    registerDi(planeElement);
  }
  this.handleDefinitions = function handleDefinitions(definitions, diagram) {
    var diagrams = definitions.diagrams;
    if (diagram && diagrams.indexOf(diagram) === -1) {
      throw new Error(translate2("diagram not part of bpmn:Definitions"));
    }
    if (!diagram && diagrams && diagrams.length) {
      diagram = diagrams[0];
    }
    if (!diagram) {
      throw new Error(translate2("no diagram to display"));
    }
    diMap = {};
    handleDiagram(diagram);
    var plane = diagram.plane;
    if (!plane) {
      throw new Error(translate2(
        "no plane for {element}",
        { element: elementToString(diagram) }
      ));
    }
    var rootElement = plane.bpmnElement;
    if (!rootElement) {
      rootElement = findDisplayCandidate(definitions);
      if (!rootElement) {
        throw new Error(translate2("no process or collaboration to display"));
      } else {
        logError(
          translate2("correcting missing bpmnElement on {plane} to {rootElement}", {
            plane: elementToString(plane),
            rootElement: elementToString(rootElement)
          })
        );
        plane.bpmnElement = rootElement;
        registerDi(plane);
      }
    }
    var ctx = visitRoot(rootElement, plane);
    if (is$2(rootElement, "bpmn:Process") || is$2(rootElement, "bpmn:SubProcess")) {
      handleProcess(rootElement, ctx);
    } else if (is$2(rootElement, "bpmn:Collaboration")) {
      handleCollaboration(rootElement, ctx);
      handleUnhandledProcesses(definitions.rootElements, ctx);
    } else {
      throw new Error(
        translate2("unsupported bpmnElement for {plane}: {rootElement}", {
          plane: elementToString(plane),
          rootElement: elementToString(rootElement)
        })
      );
    }
    handleDeferred(deferred);
  };
  var handleDeferred = this.handleDeferred = function handleDeferred2() {
    var fn;
    while (deferred.length) {
      fn = deferred.shift();
      fn();
    }
  };
  function handleProcess(process, context) {
    handleFlowElementsContainer(process, context);
    handleIoSpecification(process.ioSpecification, context);
    handleArtifacts(process.artifacts, context);
    handled(process);
  }
  function handleUnhandledProcesses(rootElements, ctx) {
    var processes = filter(rootElements, function(e2) {
      return !isHandled(e2) && is$2(e2, "bpmn:Process") && e2.laneSets;
    });
    processes.forEach(contextual(handleProcess, ctx));
  }
  function handleMessageFlow(messageFlow, context) {
    visitIfDi(messageFlow, context);
  }
  function handleMessageFlows(messageFlows, context) {
    forEach$1(messageFlows, contextual(handleMessageFlow, context));
  }
  function handleDataAssociation(association, context) {
    visitIfDi(association, context);
  }
  function handleDataInput(dataInput, context) {
    visitIfDi(dataInput, context);
  }
  function handleDataOutput(dataOutput, context) {
    visitIfDi(dataOutput, context);
  }
  function handleArtifact(artifact, context) {
    visitIfDi(artifact, context);
  }
  function handleArtifacts(artifacts, context) {
    forEach$1(artifacts, function(e2) {
      if (is$2(e2, "bpmn:Association")) {
        deferred.push(function() {
          handleArtifact(e2, context);
        });
      } else {
        handleArtifact(e2, context);
      }
    });
  }
  function handleIoSpecification(ioSpecification, context) {
    if (!ioSpecification) {
      return;
    }
    forEach$1(ioSpecification.dataInputs, contextual(handleDataInput, context));
    forEach$1(ioSpecification.dataOutputs, contextual(handleDataOutput, context));
  }
  var handleSubProcess = this.handleSubProcess = function handleSubProcess2(subProcess, context) {
    handleFlowElementsContainer(subProcess, context);
    handleArtifacts(subProcess.artifacts, context);
  };
  function handleFlowNode(flowNode, context) {
    var childCtx = visitIfDi(flowNode, context);
    if (is$2(flowNode, "bpmn:SubProcess")) {
      handleSubProcess(flowNode, childCtx || context);
    }
    if (is$2(flowNode, "bpmn:Activity")) {
      handleIoSpecification(flowNode.ioSpecification, context);
    }
    deferred.push(function() {
      forEach$1(flowNode.dataInputAssociations, contextual(handleDataAssociation, context));
      forEach$1(flowNode.dataOutputAssociations, contextual(handleDataAssociation, context));
    });
  }
  function handleSequenceFlow(sequenceFlow, context) {
    visitIfDi(sequenceFlow, context);
  }
  function handleDataElement(dataObject, context) {
    visitIfDi(dataObject, context);
  }
  function handleLane(lane, context) {
    deferred.push(function() {
      var newContext = visitIfDi(lane, context);
      if (lane.childLaneSet) {
        handleLaneSet(lane.childLaneSet, newContext || context);
      }
      wireFlowNodeRefs(lane);
    });
  }
  function handleLaneSet(laneSet, context) {
    forEach$1(laneSet.lanes, contextual(handleLane, context));
  }
  function handleLaneSets(laneSets, context) {
    forEach$1(laneSets, contextual(handleLaneSet, context));
  }
  function handleFlowElementsContainer(container, context) {
    handleFlowElements(container.flowElements, context);
    if (container.laneSets) {
      handleLaneSets(container.laneSets, context);
    }
  }
  function handleFlowElements(flowElements, context) {
    forEach$1(flowElements, function(e2) {
      if (is$2(e2, "bpmn:SequenceFlow")) {
        deferred.push(function() {
          handleSequenceFlow(e2, context);
        });
      } else if (is$2(e2, "bpmn:BoundaryEvent")) {
        deferred.unshift(function() {
          handleFlowNode(e2, context);
        });
      } else if (is$2(e2, "bpmn:FlowNode")) {
        handleFlowNode(e2, context);
      } else if (is$2(e2, "bpmn:DataObject"))
        ;
      else if (is$2(e2, "bpmn:DataStoreReference")) {
        handleDataElement(e2, context);
      } else if (is$2(e2, "bpmn:DataObjectReference")) {
        handleDataElement(e2, context);
      } else {
        logError(
          translate2("unrecognized flowElement {element} in context {context}", {
            element: elementToString(e2),
            context: context ? elementToString(context.businessObject) : "null"
          }),
          { element: e2, context }
        );
      }
    });
  }
  function handleParticipant(participant, context) {
    var newCtx = visitIfDi(participant, context);
    var process = participant.processRef;
    if (process) {
      handleProcess(process, newCtx || context);
    }
  }
  function handleCollaboration(collaboration, context) {
    forEach$1(collaboration.participants, contextual(handleParticipant, context));
    handleArtifacts(collaboration.artifacts, context);
    deferred.push(function() {
      handleMessageFlows(collaboration.messageFlows, context);
    });
  }
  function wireFlowNodeRefs(lane) {
    forEach$1(lane.flowNodeRef, function(flowNode) {
      var lanes = flowNode.get("lanes");
      if (lanes) {
        lanes.push(lane);
      }
    });
  }
}
function is$1(element, type) {
  var bo = getBusinessObject(element);
  return bo && typeof bo.$instanceOf === "function" && bo.$instanceOf(type);
}
function isAny(element, types2) {
  return some(types2, function(t2) {
    return is$1(element, t2);
  });
}
function getBusinessObject(element) {
  return element && element.businessObject || element;
}
function getDi(element) {
  return element && element.di;
}
function importBpmnDiagram(diagram, definitions, bpmnDiagram) {
  var importer, eventBus, translate2, canvas;
  var error2, warnings = [];
  function render(definitions2, bpmnDiagram2) {
    var visitor = {
      root: function(element, di) {
        return importer.add(element, di);
      },
      element: function(element, di, parentShape) {
        return importer.add(element, di, parentShape);
      },
      error: function(message, context) {
        warnings.push({ message, context });
      }
    };
    var walker = new BpmnTreeWalker(visitor, translate2);
    bpmnDiagram2 = bpmnDiagram2 || definitions2.diagrams && definitions2.diagrams[0];
    var diagramsToImport = getDiagramsToImport(definitions2, bpmnDiagram2);
    if (!diagramsToImport) {
      throw new Error(translate2("no diagram to display"));
    }
    forEach$1(diagramsToImport, function(diagram2) {
      walker.handleDefinitions(definitions2, diagram2);
    });
    var rootId = bpmnDiagram2.plane.bpmnElement.id;
    canvas.setRootElement(
      canvas.findRoot(rootId + "_plane") || canvas.findRoot(rootId)
    );
  }
  return new Promise(function(resolve, reject) {
    try {
      importer = diagram.get("bpmnImporter");
      eventBus = diagram.get("eventBus");
      translate2 = diagram.get("translate");
      canvas = diagram.get("canvas");
      eventBus.fire("import.render.start", { definitions });
      render(definitions, bpmnDiagram);
      eventBus.fire("import.render.complete", {
        error: error2,
        warnings
      });
      return resolve({ warnings });
    } catch (e2) {
      e2.warnings = warnings;
      return reject(e2);
    }
  });
}
function getDiagramsToImport(definitions, bpmnDiagram) {
  if (!bpmnDiagram) {
    return;
  }
  var bpmnElement = bpmnDiagram.plane.bpmnElement, rootElement = bpmnElement;
  if (!is$1(bpmnElement, "bpmn:Process") && !is$1(bpmnElement, "bpmn:Collaboration")) {
    rootElement = findRootProcess(bpmnElement);
  }
  var collaboration;
  if (is$1(rootElement, "bpmn:Collaboration")) {
    collaboration = rootElement;
  } else {
    collaboration = find(definitions.rootElements, function(element) {
      if (!is$1(element, "bpmn:Collaboration")) {
        return;
      }
      return find(element.participants, function(participant) {
        return participant.processRef === rootElement;
      });
    });
  }
  var rootElements = [rootElement];
  if (collaboration) {
    rootElements = map$1(collaboration.participants, function(participant) {
      return participant.processRef;
    });
    rootElements.push(collaboration);
  }
  var allChildren = selfAndAllFlowElements(rootElements);
  var diagramsToImport = [bpmnDiagram];
  var handledElements = [bpmnElement];
  forEach$1(definitions.diagrams, function(diagram) {
    var businessObject = diagram.plane.bpmnElement;
    if (allChildren.indexOf(businessObject) !== -1 && handledElements.indexOf(businessObject) === -1) {
      diagramsToImport.push(diagram);
      handledElements.push(businessObject);
    }
  });
  return diagramsToImport;
}
function selfAndAllFlowElements(elements) {
  var result = [];
  forEach$1(elements, function(element) {
    if (!element) {
      return;
    }
    result.push(element);
    result = result.concat(selfAndAllFlowElements(element.flowElements));
  });
  return result;
}
function findRootProcess(element) {
  var parent = element;
  while (parent) {
    if (is$1(parent, "bpmn:Process")) {
      return parent;
    }
    parent = parent.$parent;
  }
}
var BPMNIO_LOGO_SVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14.02 5.57" width="53" height="21"><path fill="currentColor" d="M1.88.92v.14c0 .41-.13.68-.4.8.33.14.46.44.46.86v.33c0 .61-.33.95-.95.95H0V0h.95c.65 0 .93.3.93.92zM.63.57v1.06h.24c.24 0 .38-.1.38-.43V.98c0-.28-.1-.4-.32-.4zm0 1.63v1.22h.36c.2 0 .32-.1.32-.39v-.35c0-.37-.12-.48-.4-.48H.63zM4.18.99v.52c0 .64-.31.98-.94.98h-.3V4h-.62V0h.92c.63 0 .94.35.94.99zM2.94.57v1.35h.3c.2 0 .3-.09.3-.37v-.6c0-.29-.1-.38-.3-.38h-.3zm2.89 2.27L6.25 0h.88v4h-.6V1.12L6.1 3.99h-.6l-.46-2.82v2.82h-.55V0h.87zM8.14 1.1V4h-.56V0h.79L9 2.4V0h.56v4h-.64zm2.49 2.29v.6h-.6v-.6zM12.12 1c0-.63.33-1 .95-1 .61 0 .95.37.95 1v2.04c0 .64-.34 1-.95 1-.62 0-.95-.37-.95-1zm.62 2.08c0 .28.13.39.33.39s.32-.1.32-.4V.98c0-.29-.12-.4-.32-.4s-.33.11-.33.4z"/><path fill="currentColor" d="M0 4.53h14.02v1.04H0zM11.08 0h.63v.62h-.63zm.63 4V1h-.63v2.98z"/></svg>';
var BPMNIO_IMG = BPMNIO_LOGO_SVG;
var LOGO_STYLES = {
  verticalAlign: "middle"
};
var LINK_STYLES = {
  "color": "#404040"
};
var LIGHTBOX_STYLES = {
  "zIndex": "1001",
  "position": "fixed",
  "top": "0",
  "left": "0",
  "right": "0",
  "bottom": "0"
};
var BACKDROP_STYLES = {
  "width": "100%",
  "height": "100%",
  "background": "rgba(40,40,40,0.2)"
};
var NOTICE_STYLES = {
  "position": "absolute",
  "left": "50%",
  "top": "40%",
  "transform": "translate(-50%)",
  "width": "260px",
  "padding": "10px",
  "background": "white",
  "boxShadow": "0 1px 4px rgba(0,0,0,0.3)",
  "fontFamily": "Helvetica, Arial, sans-serif",
  "fontSize": "14px",
  "display": "flex",
  "lineHeight": "1.3"
};
var LIGHTBOX_MARKUP = '<div class="bjs-powered-by-lightbox"><div class="backdrop"></div><div class="notice"><a href="https://bpmn.io" target="_blank" rel="noopener" class="link">' + BPMNIO_IMG + '</a><span>Web-based tooling for BPMN, DMN and forms powered by <a href="https://bpmn.io" target="_blank" rel="noopener">bpmn.io</a>.</span></div></div>';
var lightbox;
function createLightbox() {
  lightbox = domify$1(LIGHTBOX_MARKUP);
  assign(lightbox, LIGHTBOX_STYLES);
  assign(query("svg", lightbox), LOGO_STYLES);
  assign(query(".backdrop", lightbox), BACKDROP_STYLES);
  assign(query(".notice", lightbox), NOTICE_STYLES);
  assign(query(".link", lightbox), LINK_STYLES, {
    "margin": "15px 20px 15px 10px",
    "alignSelf": "center"
  });
}
function open() {
  if (!lightbox) {
    createLightbox();
    delegate.bind(lightbox, ".backdrop", "click", function(event2) {
      document.body.removeChild(lightbox);
    });
  }
  document.body.appendChild(lightbox);
}
function BaseViewer(options) {
  options = assign$1({}, DEFAULT_OPTIONS, options);
  this._moddle = this._createModdle(options);
  this._container = this._createContainer(options);
  addProjectLogo(this._container);
  this._init(this._container, this._moddle, options);
}
e$3(BaseViewer, Diagram);
BaseViewer.prototype.importXML = async function importXML(xml2, bpmnDiagram) {
  const self2 = this;
  function ParseCompleteEvent(data) {
    return self2.get("eventBus").createEvent(data);
  }
  let aggregatedWarnings = [];
  try {
    xml2 = this._emit("import.parse.start", { xml: xml2 }) || xml2;
    let parseResult;
    try {
      parseResult = await this._moddle.fromXML(xml2, "bpmn:Definitions");
    } catch (error2) {
      this._emit("import.parse.complete", {
        error: error2
      });
      throw error2;
    }
    let definitions = parseResult.rootElement;
    const references = parseResult.references;
    const parseWarnings = parseResult.warnings;
    const elementsById = parseResult.elementsById;
    aggregatedWarnings = aggregatedWarnings.concat(parseWarnings);
    definitions = this._emit("import.parse.complete", ParseCompleteEvent({
      error: null,
      definitions,
      elementsById,
      references,
      warnings: aggregatedWarnings
    })) || definitions;
    const importResult = await this.importDefinitions(definitions, bpmnDiagram);
    aggregatedWarnings = aggregatedWarnings.concat(importResult.warnings);
    this._emit("import.done", { error: null, warnings: aggregatedWarnings });
    return { warnings: aggregatedWarnings };
  } catch (err) {
    let error2 = err;
    aggregatedWarnings = aggregatedWarnings.concat(error2.warnings || []);
    addWarningsToError(error2, aggregatedWarnings);
    error2 = checkValidationError(error2);
    this._emit("import.done", { error: error2, warnings: error2.warnings });
    throw error2;
  }
};
BaseViewer.prototype.importDefinitions = async function importDefinitions(definitions, bpmnDiagram) {
  this._setDefinitions(definitions);
  const result = await this.open(bpmnDiagram);
  return { warnings: result.warnings };
};
BaseViewer.prototype.open = async function open2(bpmnDiagramOrId) {
  const definitions = this._definitions;
  let bpmnDiagram = bpmnDiagramOrId;
  if (!definitions) {
    const error2 = new Error("no XML imported");
    addWarningsToError(error2, []);
    throw error2;
  }
  if (typeof bpmnDiagramOrId === "string") {
    bpmnDiagram = findBPMNDiagram(definitions, bpmnDiagramOrId);
    if (!bpmnDiagram) {
      const error2 = new Error("BPMNDiagram <" + bpmnDiagramOrId + "> not found");
      addWarningsToError(error2, []);
      throw error2;
    }
  }
  try {
    this.clear();
  } catch (error2) {
    addWarningsToError(error2, []);
    throw error2;
  }
  const { warnings } = await importBpmnDiagram(this, definitions, bpmnDiagram);
  return { warnings };
};
BaseViewer.prototype.saveXML = async function saveXML(options) {
  options = options || {};
  let definitions = this._definitions, error2, xml2;
  try {
    if (!definitions) {
      throw new Error("no definitions loaded");
    }
    definitions = this._emit("saveXML.start", {
      definitions
    }) || definitions;
    const result2 = await this._moddle.toXML(definitions, options);
    xml2 = result2.xml;
    xml2 = this._emit("saveXML.serialized", {
      xml: xml2
    }) || xml2;
  } catch (err) {
    error2 = err;
  }
  const result = error2 ? { error: error2 } : { xml: xml2 };
  this._emit("saveXML.done", result);
  if (error2) {
    throw error2;
  }
  return result;
};
BaseViewer.prototype.saveSVG = async function saveSVG() {
  this._emit("saveSVG.start");
  let svg, err;
  try {
    const canvas = this.get("canvas");
    const contentNode = canvas.getActiveLayer(), defsNode = query("defs", canvas._svg);
    const contents = innerSVG(contentNode), defs = defsNode ? "<defs>" + innerSVG(defsNode) + "</defs>" : "";
    const bbox = contentNode.getBBox();
    svg = '<?xml version="1.0" encoding="utf-8"?>\n<!-- created with bpmn-js / http://bpmn.io -->\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="' + bbox.width + '" height="' + bbox.height + '" viewBox="' + bbox.x + " " + bbox.y + " " + bbox.width + " " + bbox.height + '" version="1.1">' + defs + contents + "</svg>";
  } catch (e2) {
    err = e2;
  }
  this._emit("saveSVG.done", {
    error: err,
    svg
  });
  if (err) {
    throw err;
  }
  return { svg };
};
BaseViewer.prototype._setDefinitions = function(definitions) {
  this._definitions = definitions;
};
BaseViewer.prototype.getModules = function() {
  return this._modules;
};
BaseViewer.prototype.clear = function() {
  if (!this.getDefinitions()) {
    return;
  }
  Diagram.prototype.clear.call(this);
};
BaseViewer.prototype.destroy = function() {
  Diagram.prototype.destroy.call(this);
  remove$2(this._container);
};
BaseViewer.prototype.on = function(events, priority, callback, that) {
  return this.get("eventBus").on(events, priority, callback, that);
};
BaseViewer.prototype.off = function(events, callback) {
  this.get("eventBus").off(events, callback);
};
BaseViewer.prototype.attachTo = function(parentNode) {
  if (!parentNode) {
    throw new Error("parentNode required");
  }
  this.detach();
  if (parentNode.get && parentNode.constructor.prototype.jquery) {
    parentNode = parentNode.get(0);
  }
  if (typeof parentNode === "string") {
    parentNode = query(parentNode);
  }
  parentNode.appendChild(this._container);
  this._emit("attach", {});
  this.get("canvas").resized();
};
BaseViewer.prototype.getDefinitions = function() {
  return this._definitions;
};
BaseViewer.prototype.detach = function() {
  const container = this._container, parentNode = container.parentNode;
  if (!parentNode) {
    return;
  }
  this._emit("detach", {});
  parentNode.removeChild(container);
};
BaseViewer.prototype._init = function(container, moddle, options) {
  const baseModules = options.modules || this.getModules(options), additionalModules = options.additionalModules || [], staticModules = [
    {
      bpmnjs: ["value", this],
      moddle: ["value", moddle]
    }
  ];
  const diagramModules = [].concat(staticModules, baseModules, additionalModules);
  const diagramOptions = assign$1(omit(options, ["additionalModules"]), {
    canvas: assign$1({}, options.canvas, { container }),
    modules: diagramModules
  });
  Diagram.call(this, diagramOptions);
  if (options && options.container) {
    this.attachTo(options.container);
  }
};
BaseViewer.prototype._emit = function(type, event2) {
  return this.get("eventBus").fire(type, event2);
};
BaseViewer.prototype._createContainer = function(options) {
  const container = domify$1('<div class="bjs-container"></div>');
  assign(container, {
    width: ensureUnit(options.width),
    height: ensureUnit(options.height),
    position: options.position
  });
  return container;
};
BaseViewer.prototype._createModdle = function(options) {
  const moddleOptions = assign$1({}, this._moddleExtensions, options.moddleExtensions);
  return new simple(moddleOptions);
};
BaseViewer.prototype._modules = [];
function addWarningsToError(err, warningsAry) {
  err.warnings = warningsAry;
  return err;
}
function checkValidationError(err) {
  const pattern = /unparsable content <([^>]+)> detected([\s\S]*)$/;
  const match = pattern.exec(err.message);
  if (match) {
    err.message = "unparsable content <" + match[1] + "> detected; this may indicate an invalid BPMN 2.0 diagram file" + match[2];
  }
  return err;
}
const DEFAULT_OPTIONS = {
  width: "100%",
  height: "100%",
  position: "relative"
};
function ensureUnit(val) {
  return val + (isNumber(val) ? "px" : "");
}
function findBPMNDiagram(definitions, diagramId) {
  if (!diagramId) {
    return null;
  }
  return find(definitions.diagrams, function(element) {
    return element.id === diagramId;
  }) || null;
}
function addProjectLogo(container) {
  const img = BPMNIO_IMG;
  const linkMarkup = '<a href="http://bpmn.io" target="_blank" class="bjs-powered-by" title="Powered by bpmn.io" >' + img + "</a>";
  const linkElement = domify$1(linkMarkup);
  assign(query("svg", linkElement), LOGO_STYLES);
  assign(linkElement, LINK_STYLES, {
    position: "absolute",
    bottom: "15px",
    right: "15px",
    zIndex: "100"
  });
  container.appendChild(linkElement);
  event.bind(linkElement, "click", function(event2) {
    open();
    event2.preventDefault();
  });
}
function BaseModeler(options) {
  BaseViewer.call(this, options);
  this.on("import.parse.complete", function(event2) {
    if (!event2.error) {
      this._collectIds(event2.definitions, event2.elementsById);
    }
  }, this);
  this.on("diagram.destroy", function() {
    this.get("moddle").ids.clear();
  }, this);
}
e$3(BaseModeler, BaseViewer);
BaseModeler.prototype._createModdle = function(options) {
  var moddle = BaseViewer.prototype._createModdle.call(this, options);
  moddle.ids = new Ids([32, 36, 1]);
  return moddle;
};
BaseModeler.prototype._collectIds = function(definitions, elementsById) {
  var moddle = definitions.$model, ids2 = moddle.ids, id;
  ids2.clear();
  for (id in elementsById) {
    ids2.claim(id, elementsById[id]);
  }
};
function isExpanded(element, di) {
  if (is$1(element, "bpmn:CallActivity")) {
    return false;
  }
  if (is$1(element, "bpmn:SubProcess")) {
    di = di || getDi(element);
    if (di && is$1(di, "bpmndi:BPMNPlane")) {
      return true;
    }
    return di && !!di.isExpanded;
  }
  if (is$1(element, "bpmn:Participant")) {
    return !!getBusinessObject(element).processRef;
  }
  return true;
}
function isHorizontal$3(element) {
  if (!is$1(element, "bpmn:Participant") && !is$1(element, "bpmn:Lane")) {
    return void 0;
  }
  var isHorizontal2 = getDi(element).isHorizontal;
  if (isHorizontal2 === void 0) {
    return true;
  }
  return isHorizontal2;
}
function isInterrupting(element) {
  return element && getBusinessObject(element).isInterrupting !== false;
}
function isEventSubProcess(element) {
  return element && !!getBusinessObject(element).triggeredByEvent;
}
function hasEventDefinition$2(element, eventType) {
  var eventDefinitions = getBusinessObject(element).eventDefinitions;
  return some(eventDefinitions, function(event2) {
    return is$1(event2, eventType);
  });
}
function hasErrorEventDefinition(element) {
  return hasEventDefinition$2(element, "bpmn:ErrorEventDefinition");
}
function hasEscalationEventDefinition(element) {
  return hasEventDefinition$2(element, "bpmn:EscalationEventDefinition");
}
function hasCompensateEventDefinition(element) {
  return hasEventDefinition$2(element, "bpmn:CompensateEventDefinition");
}
var DEFAULT_LABEL_SIZE$1 = {
  width: 90,
  height: 20
};
var FLOW_LABEL_INDENT = 15;
function isLabelExternal(semantic) {
  return is$1(semantic, "bpmn:Event") || is$1(semantic, "bpmn:Gateway") || is$1(semantic, "bpmn:DataStoreReference") || is$1(semantic, "bpmn:DataObjectReference") || is$1(semantic, "bpmn:DataInput") || is$1(semantic, "bpmn:DataOutput") || is$1(semantic, "bpmn:SequenceFlow") || is$1(semantic, "bpmn:MessageFlow") || is$1(semantic, "bpmn:Group");
}
function hasExternalLabel(element) {
  return isLabel(element.label);
}
function getFlowLabelPosition(waypoints) {
  var mid2 = waypoints.length / 2 - 1;
  var first = waypoints[Math.floor(mid2)];
  var second = waypoints[Math.ceil(mid2 + 0.01)];
  var position = getWaypointsMid(waypoints);
  var angle = Math.atan((second.y - first.y) / (second.x - first.x));
  var x2 = position.x, y2 = position.y;
  if (Math.abs(angle) < Math.PI / 2) {
    y2 -= FLOW_LABEL_INDENT;
  } else {
    x2 += FLOW_LABEL_INDENT;
  }
  return { x: x2, y: y2 };
}
function getWaypointsMid(waypoints) {
  var mid2 = waypoints.length / 2 - 1;
  var first = waypoints[Math.floor(mid2)];
  var second = waypoints[Math.ceil(mid2 + 0.01)];
  return {
    x: first.x + (second.x - first.x) / 2,
    y: first.y + (second.y - first.y) / 2
  };
}
function getExternalLabelMid(element) {
  if (element.waypoints) {
    return getFlowLabelPosition(element.waypoints);
  } else if (is$1(element, "bpmn:Group")) {
    return {
      x: element.x + element.width / 2,
      y: element.y + DEFAULT_LABEL_SIZE$1.height / 2
    };
  } else {
    return {
      x: element.x + element.width / 2,
      y: element.y + element.height + DEFAULT_LABEL_SIZE$1.height / 2
    };
  }
}
function getExternalLabelBounds(di, element) {
  var mid2, size2, bounds, label = di.label;
  if (label && label.bounds) {
    bounds = label.bounds;
    size2 = {
      width: Math.max(DEFAULT_LABEL_SIZE$1.width, bounds.width),
      height: bounds.height
    };
    mid2 = {
      x: bounds.x + bounds.width / 2,
      y: bounds.y + bounds.height / 2
    };
  } else {
    mid2 = getExternalLabelMid(element);
    size2 = DEFAULT_LABEL_SIZE$1;
  }
  return assign$1({
    x: mid2.x - size2.width / 2,
    y: mid2.y - size2.height / 2
  }, size2);
}
function getLabelAttr(semantic) {
  if (is$1(semantic, "bpmn:FlowElement") || is$1(semantic, "bpmn:Participant") || is$1(semantic, "bpmn:Lane") || is$1(semantic, "bpmn:SequenceFlow") || is$1(semantic, "bpmn:MessageFlow") || is$1(semantic, "bpmn:DataInput") || is$1(semantic, "bpmn:DataOutput")) {
    return "name";
  }
  if (is$1(semantic, "bpmn:TextAnnotation")) {
    return "text";
  }
  if (is$1(semantic, "bpmn:Group")) {
    return "categoryValueRef";
  }
}
function getCategoryValue(semantic) {
  var categoryValueRef = semantic["categoryValueRef"];
  if (!categoryValueRef) {
    return "";
  }
  return categoryValueRef.value || "";
}
function getLabel(element) {
  var semantic = element.businessObject, attr2 = getLabelAttr(semantic);
  if (attr2) {
    if (attr2 === "categoryValueRef") {
      return getCategoryValue(semantic);
    }
    return semantic[attr2] || "";
  }
}
function setLabel(element, text) {
  var semantic = element.businessObject, attr2 = getLabelAttr(semantic);
  if (attr2) {
    if (attr2 === "categoryValueRef") {
      semantic["categoryValueRef"].value = text;
    } else {
      semantic[attr2] = text;
    }
  }
  return element;
}
var black = "hsl(225, 10%, 15%)";
var white = "white";
function isTypedEvent(event2, eventDefinitionType) {
  return some(event2.eventDefinitions, function(definition) {
    return definition.$type === eventDefinitionType;
  });
}
function isThrowEvent(event2) {
  return event2.$type === "bpmn:IntermediateThrowEvent" || event2.$type === "bpmn:EndEvent";
}
function isCollection(element) {
  var dataObject = element.dataObjectRef;
  return element.isCollection || dataObject && dataObject.isCollection;
}
function getFillColor(element, defaultColor, overrideColor) {
  var di = getDi(element);
  return overrideColor || di.get("color:background-color") || di.get("bioc:fill") || defaultColor || white;
}
function getStrokeColor$1(element, defaultColor, overrideColor) {
  var di = getDi(element);
  return overrideColor || di.get("color:border-color") || di.get("bioc:stroke") || defaultColor || black;
}
function getLabelColor(element, defaultColor, defaultStrokeColor, overrideColor) {
  var di = getDi(element), label = di.get("label");
  return overrideColor || label && label.get("color:color") || defaultColor || getStrokeColor$1(element, defaultStrokeColor);
}
function getCirclePath(shape) {
  var cx = shape.x + shape.width / 2, cy = shape.y + shape.height / 2, radius = shape.width / 2;
  var circlePath2 = [
    ["M", cx, cy],
    ["m", 0, -radius],
    ["a", radius, radius, 0, 1, 1, 0, 2 * radius],
    ["a", radius, radius, 0, 1, 1, 0, -2 * radius],
    ["z"]
  ];
  return componentsToPath(circlePath2);
}
function getRoundRectPath(shape, borderRadius) {
  var x2 = shape.x, y2 = shape.y, width = shape.width, height = shape.height;
  var roundRectPath = [
    ["M", x2 + borderRadius, y2],
    ["l", width - borderRadius * 2, 0],
    ["a", borderRadius, borderRadius, 0, 0, 1, borderRadius, borderRadius],
    ["l", 0, height - borderRadius * 2],
    ["a", borderRadius, borderRadius, 0, 0, 1, -borderRadius, borderRadius],
    ["l", borderRadius * 2 - width, 0],
    ["a", borderRadius, borderRadius, 0, 0, 1, -borderRadius, -borderRadius],
    ["l", 0, borderRadius * 2 - height],
    ["a", borderRadius, borderRadius, 0, 0, 1, borderRadius, -borderRadius],
    ["z"]
  ];
  return componentsToPath(roundRectPath);
}
function getDiamondPath(shape) {
  var width = shape.width, height = shape.height, x2 = shape.x, y2 = shape.y, halfWidth = width / 2, halfHeight = height / 2;
  var diamondPath = [
    ["M", x2 + halfWidth, y2],
    ["l", halfWidth, halfHeight],
    ["l", -halfWidth, halfHeight],
    ["l", -halfWidth, -halfHeight],
    ["z"]
  ];
  return componentsToPath(diamondPath);
}
function getRectPath(shape) {
  var x2 = shape.x, y2 = shape.y, width = shape.width, height = shape.height;
  var rectPath = [
    ["M", x2, y2],
    ["l", width, 0],
    ["l", 0, height],
    ["l", -width, 0],
    ["z"]
  ];
  return componentsToPath(rectPath);
}
function getBounds$1(bounds, overrides = {}) {
  return {
    width: getWidth(bounds, overrides),
    height: getHeight(bounds, overrides)
  };
}
function getWidth(bounds, overrides = {}) {
  return has$1(overrides, "width") ? overrides.width : bounds.width;
}
function getHeight(bounds, overrides = {}) {
  return has$1(overrides, "height") ? overrides.height : bounds.height;
}
var rendererIds = new Ids();
var ELEMENT_LABEL_DISTANCE$1 = 10, INNER_OUTER_DIST = 3, PARTICIPANT_STROKE_WIDTH = 1.5, TASK_BORDER_RADIUS = 10;
var DEFAULT_OPACITY = 0.95, FULL_OPACITY = 1, LOW_OPACITY = 0.25;
function BpmnRenderer(config, eventBus, styles, pathMap, canvas, textRenderer, priority) {
  BaseRenderer.call(this, eventBus, priority);
  var defaultFillColor = config && config.defaultFillColor, defaultStrokeColor = config && config.defaultStrokeColor, defaultLabelColor = config && config.defaultLabelColor;
  var rendererId = rendererIds.next();
  var markers = {};
  function shapeStyle(attrs) {
    return styles.computeStyle(attrs, {
      strokeLinecap: "round",
      strokeLinejoin: "round",
      stroke: black,
      strokeWidth: 2,
      fill: "white"
    });
  }
  function lineStyle(attrs) {
    return styles.computeStyle(attrs, ["no-fill"], {
      strokeLinecap: "round",
      strokeLinejoin: "round",
      stroke: black,
      strokeWidth: 2
    });
  }
  function addMarker(id, options) {
    var {
      ref = { x: 0, y: 0 },
      scale = 1,
      element
    } = options;
    var marker2 = create$1("marker", {
      id,
      viewBox: "0 0 20 20",
      refX: ref.x,
      refY: ref.y,
      markerWidth: 20 * scale,
      markerHeight: 20 * scale,
      orient: "auto"
    });
    append(marker2, element);
    var defs = query("defs", canvas._svg);
    if (!defs) {
      defs = create$1("defs");
      append(canvas._svg, defs);
    }
    append(defs, marker2);
    markers[id] = marker2;
  }
  function colorEscape(str) {
    return str.replace(/[^0-9a-zA-Z]+/g, "_");
  }
  function marker(type, fill, stroke) {
    var id = type + "-" + colorEscape(fill) + "-" + colorEscape(stroke) + "-" + rendererId;
    if (!markers[id]) {
      createMarker(id, type, fill, stroke);
    }
    return "url(#" + id + ")";
  }
  function createMarker(id, type, fill, stroke) {
    if (type === "sequenceflow-end") {
      var sequenceflowEnd = create$1("path", {
        d: "M 1 5 L 11 10 L 1 15 Z",
        ...shapeStyle({
          fill: stroke,
          stroke,
          strokeWidth: 1
        })
      });
      addMarker(id, {
        element: sequenceflowEnd,
        ref: { x: 11, y: 10 },
        scale: 0.5
      });
    }
    if (type === "messageflow-start") {
      var messageflowStart = create$1("circle", {
        cx: 6,
        cy: 6,
        r: 3.5,
        ...shapeStyle({
          fill,
          stroke,
          strokeWidth: 1,
          // fix for safari / chrome / firefox bug not correctly
          // resetting stroke dash array
          strokeDasharray: [1e4, 1]
        })
      });
      addMarker(id, {
        element: messageflowStart,
        ref: { x: 6, y: 6 }
      });
    }
    if (type === "messageflow-end") {
      var messageflowEnd = create$1("path", {
        d: "m 1 5 l 0 -3 l 7 3 l -7 3 z",
        ...shapeStyle({
          fill,
          stroke,
          strokeWidth: 1,
          // fix for safari / chrome / firefox bug not correctly
          // resetting stroke dash array
          strokeDasharray: [1e4, 1]
        })
      });
      addMarker(id, {
        element: messageflowEnd,
        ref: { x: 8.5, y: 5 }
      });
    }
    if (type === "association-start") {
      var associationStart = create$1("path", {
        d: "M 11 5 L 1 10 L 11 15",
        ...lineStyle({
          fill: "none",
          stroke,
          strokeWidth: 1.5,
          // fix for safari / chrome / firefox bug not correctly
          // resetting stroke dash array
          strokeDasharray: [1e4, 1]
        })
      });
      addMarker(id, {
        element: associationStart,
        ref: { x: 1, y: 10 },
        scale: 0.5
      });
    }
    if (type === "association-end") {
      var associationEnd = create$1("path", {
        d: "M 1 5 L 11 10 L 1 15",
        ...lineStyle({
          fill: "none",
          stroke,
          strokeWidth: 1.5,
          // fix for safari / chrome / firefox bug not correctly
          // resetting stroke dash array
          strokeDasharray: [1e4, 1]
        })
      });
      addMarker(id, {
        element: associationEnd,
        ref: { x: 11, y: 10 },
        scale: 0.5
      });
    }
    if (type === "conditional-flow-marker") {
      var conditionalFlowMarker = create$1("path", {
        d: "M 0 10 L 8 6 L 16 10 L 8 14 Z",
        ...shapeStyle({
          fill,
          stroke
        })
      });
      addMarker(id, {
        element: conditionalFlowMarker,
        ref: { x: -1, y: 10 },
        scale: 0.5
      });
    }
    if (type === "conditional-default-flow-marker") {
      var defaultFlowMarker = create$1("path", {
        d: "M 6 4 L 10 16",
        ...shapeStyle({
          stroke
        })
      });
      addMarker(id, {
        element: defaultFlowMarker,
        ref: { x: 0, y: 10 },
        scale: 0.5
      });
    }
  }
  function drawCircle(parentGfx, width, height, offset, attrs = {}) {
    if (isObject(offset)) {
      attrs = offset;
      offset = 0;
    }
    offset = offset || 0;
    attrs = shapeStyle(attrs);
    var cx = width / 2, cy = height / 2;
    var circle = create$1("circle", {
      cx,
      cy,
      r: Math.round((width + height) / 4 - offset),
      ...attrs
    });
    append(parentGfx, circle);
    return circle;
  }
  function drawRect(parentGfx, width, height, r2, offset, attrs) {
    if (isObject(offset)) {
      attrs = offset;
      offset = 0;
    }
    offset = offset || 0;
    attrs = shapeStyle(attrs);
    var rect = create$1("rect", {
      x: offset,
      y: offset,
      width: width - offset * 2,
      height: height - offset * 2,
      rx: r2,
      ry: r2,
      ...attrs
    });
    append(parentGfx, rect);
    return rect;
  }
  function drawDiamond(parentGfx, width, height, attrs) {
    var x_2 = width / 2;
    var y_2 = height / 2;
    var points = [
      { x: x_2, y: 0 },
      { x: width, y: y_2 },
      { x: x_2, y: height },
      { x: 0, y: y_2 }
    ];
    var pointsString = points.map(function(point) {
      return point.x + "," + point.y;
    }).join(" ");
    attrs = shapeStyle(attrs);
    var polygon = create$1("polygon", {
      ...attrs,
      points: pointsString
    });
    append(parentGfx, polygon);
    return polygon;
  }
  function drawLine(parentGfx, waypoints, attrs, radius) {
    attrs = lineStyle(attrs);
    var line = createLine(waypoints, attrs, radius);
    append(parentGfx, line);
    return line;
  }
  function drawConnectionSegments(parentGfx, waypoints, attrs) {
    return drawLine(parentGfx, waypoints, attrs, 5);
  }
  function drawPath2(parentGfx, d2, attrs) {
    attrs = lineStyle(attrs);
    var path = create$1("path", {
      ...attrs,
      d: d2
    });
    append(parentGfx, path);
    return path;
  }
  function drawMarker(type, parentGfx, path, attrs) {
    return drawPath2(parentGfx, path, assign$1({ "data-marker": type }, attrs));
  }
  function renderer(type) {
    return handlers[type];
  }
  function as(type) {
    return function(parentGfx, element, attrs) {
      return renderer(type)(parentGfx, element, attrs);
    };
  }
  var eventIconRenderers = {
    "bpmn:MessageEventDefinition": function(parentGfx, element, attrs = {}, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_MESSAGE", {
        xScaleFactor: 0.9,
        yScaleFactor: 0.9,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.235,
          my: 0.315
        }
      });
      var fill = isThrowing ? getStrokeColor$1(element, defaultStrokeColor, attrs.stroke) : getFillColor(element, defaultFillColor, attrs.fill);
      var stroke = isThrowing ? getFillColor(element, defaultFillColor, attrs.fill) : getStrokeColor$1(element, defaultStrokeColor, attrs.stroke);
      var messagePath = drawPath2(parentGfx, pathData, {
        fill,
        stroke,
        strokeWidth: 1
      });
      return messagePath;
    },
    "bpmn:TimerEventDefinition": function(parentGfx, element, attrs = {}) {
      var circle = drawCircle(parentGfx, element.width, element.height, 0.2 * element.height, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 2
      });
      var pathData = pathMap.getScaledPath("EVENT_TIMER_WH", {
        xScaleFactor: 0.75,
        yScaleFactor: 0.75,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.5,
          my: 0.5
        }
      });
      drawPath2(parentGfx, pathData, {
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 2
      });
      for (var i2 = 0; i2 < 12; i2++) {
        var linePathData = pathMap.getScaledPath("EVENT_TIMER_LINE", {
          xScaleFactor: 0.75,
          yScaleFactor: 0.75,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.5,
            my: 0.5
          }
        });
        var width = element.width / 2, height = element.height / 2;
        drawPath2(parentGfx, linePathData, {
          strokeWidth: 1,
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          transform: "rotate(" + i2 * 30 + "," + height + "," + width + ")"
        });
      }
      return circle;
    },
    "bpmn:EscalationEventDefinition": function(parentGfx, event2, attrs = {}, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_ESCALATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.5,
          my: 0.2
        }
      });
      var fill = isThrowing ? getStrokeColor$1(event2, defaultStrokeColor, attrs.stroke) : getFillColor(event2, defaultFillColor, attrs.fill);
      return drawPath2(parentGfx, pathData, {
        fill,
        stroke: getStrokeColor$1(event2, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
    },
    "bpmn:ConditionalEventDefinition": function(parentGfx, event2, attrs = {}) {
      var pathData = pathMap.getScaledPath("EVENT_CONDITIONAL", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.5,
          my: 0.222
        }
      });
      return drawPath2(parentGfx, pathData, {
        fill: getFillColor(event2, defaultFillColor, attrs.fill),
        stroke: getStrokeColor$1(event2, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
    },
    "bpmn:LinkEventDefinition": function(parentGfx, event2, attrs = {}, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_LINK", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.57,
          my: 0.263
        }
      });
      var fill = isThrowing ? getStrokeColor$1(event2, defaultStrokeColor, attrs.stroke) : getFillColor(event2, defaultFillColor, attrs.fill);
      return drawPath2(parentGfx, pathData, {
        fill,
        stroke: getStrokeColor$1(event2, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
    },
    "bpmn:ErrorEventDefinition": function(parentGfx, event2, attrs = {}, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_ERROR", {
        xScaleFactor: 1.1,
        yScaleFactor: 1.1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.2,
          my: 0.722
        }
      });
      var fill = isThrowing ? getStrokeColor$1(event2, defaultStrokeColor, attrs.stroke) : getFillColor(event2, defaultFillColor, attrs.fill);
      return drawPath2(parentGfx, pathData, {
        fill,
        stroke: getStrokeColor$1(event2, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
    },
    "bpmn:CancelEventDefinition": function(parentGfx, event2, attrs = {}, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_CANCEL_45", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.638,
          my: -0.055
        }
      });
      var fill = isThrowing ? getStrokeColor$1(event2, defaultStrokeColor, attrs.stroke) : "none";
      var path = drawPath2(parentGfx, pathData, {
        fill,
        stroke: getStrokeColor$1(event2, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
      rotate(path, 45);
      return path;
    },
    "bpmn:CompensateEventDefinition": function(parentGfx, event2, attrs = {}, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_COMPENSATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.22,
          my: 0.5
        }
      });
      var fill = isThrowing ? getStrokeColor$1(event2, defaultStrokeColor, attrs.stroke) : getFillColor(event2, defaultFillColor, attrs.fill);
      return drawPath2(parentGfx, pathData, {
        fill,
        stroke: getStrokeColor$1(event2, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
    },
    "bpmn:SignalEventDefinition": function(parentGfx, event2, attrs = {}, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_SIGNAL", {
        xScaleFactor: 0.9,
        yScaleFactor: 0.9,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.5,
          my: 0.2
        }
      });
      var fill = isThrowing ? getStrokeColor$1(event2, defaultStrokeColor, attrs.stroke) : getFillColor(event2, defaultFillColor, attrs.fill);
      return drawPath2(parentGfx, pathData, {
        strokeWidth: 1,
        fill,
        stroke: getStrokeColor$1(event2, defaultStrokeColor, attrs.stroke)
      });
    },
    "bpmn:MultipleEventDefinition": function(parentGfx, event2, attrs = {}, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_MULTIPLE", {
        xScaleFactor: 1.1,
        yScaleFactor: 1.1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.222,
          my: 0.36
        }
      });
      var fill = isThrowing ? getStrokeColor$1(event2, defaultStrokeColor, attrs.stroke) : getFillColor(event2, defaultFillColor, attrs.fill);
      return drawPath2(parentGfx, pathData, {
        fill,
        strokeWidth: 1
      });
    },
    "bpmn:ParallelMultipleEventDefinition": function(parentGfx, event2, attrs = {}) {
      var pathData = pathMap.getScaledPath("EVENT_PARALLEL_MULTIPLE", {
        xScaleFactor: 1.2,
        yScaleFactor: 1.2,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.458,
          my: 0.194
        }
      });
      return drawPath2(parentGfx, pathData, {
        fill: getFillColor(event2, defaultFillColor, attrs.fill),
        stroke: getStrokeColor$1(event2, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
    },
    "bpmn:TerminateEventDefinition": function(parentGfx, element, attrs = {}) {
      var circle = drawCircle(parentGfx, element.width, element.height, 8, {
        fill: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 4
      });
      return circle;
    }
  };
  function renderEventIcon(element, parentGfx, attrs = {}) {
    var semantic = getBusinessObject(element), isThrowing = isThrowEvent(semantic);
    if (semantic.get("eventDefinitions") && semantic.get("eventDefinitions").length > 1) {
      if (semantic.get("parallelMultiple")) {
        return eventIconRenderers["bpmn:ParallelMultipleEventDefinition"](parentGfx, element, attrs, isThrowing);
      } else {
        return eventIconRenderers["bpmn:MultipleEventDefinition"](parentGfx, element, attrs, isThrowing);
      }
    }
    if (isTypedEvent(semantic, "bpmn:MessageEventDefinition")) {
      return eventIconRenderers["bpmn:MessageEventDefinition"](parentGfx, element, attrs, isThrowing);
    }
    if (isTypedEvent(semantic, "bpmn:TimerEventDefinition")) {
      return eventIconRenderers["bpmn:TimerEventDefinition"](parentGfx, element, attrs, isThrowing);
    }
    if (isTypedEvent(semantic, "bpmn:ConditionalEventDefinition")) {
      return eventIconRenderers["bpmn:ConditionalEventDefinition"](parentGfx, element, attrs, isThrowing);
    }
    if (isTypedEvent(semantic, "bpmn:SignalEventDefinition")) {
      return eventIconRenderers["bpmn:SignalEventDefinition"](parentGfx, element, attrs, isThrowing);
    }
    if (isTypedEvent(semantic, "bpmn:EscalationEventDefinition")) {
      return eventIconRenderers["bpmn:EscalationEventDefinition"](parentGfx, element, attrs, isThrowing);
    }
    if (isTypedEvent(semantic, "bpmn:LinkEventDefinition")) {
      return eventIconRenderers["bpmn:LinkEventDefinition"](parentGfx, element, attrs, isThrowing);
    }
    if (isTypedEvent(semantic, "bpmn:ErrorEventDefinition")) {
      return eventIconRenderers["bpmn:ErrorEventDefinition"](parentGfx, element, attrs, isThrowing);
    }
    if (isTypedEvent(semantic, "bpmn:CancelEventDefinition")) {
      return eventIconRenderers["bpmn:CancelEventDefinition"](parentGfx, element, attrs, isThrowing);
    }
    if (isTypedEvent(semantic, "bpmn:CompensateEventDefinition")) {
      return eventIconRenderers["bpmn:CompensateEventDefinition"](parentGfx, element, attrs, isThrowing);
    }
    if (isTypedEvent(semantic, "bpmn:TerminateEventDefinition")) {
      return eventIconRenderers["bpmn:TerminateEventDefinition"](parentGfx, element, attrs, isThrowing);
    }
    return null;
  }
  var taskMarkerRenderers = {
    "ParticipantMultiplicityMarker": function(parentGfx, element, attrs = {}) {
      var width = getWidth(element, attrs), height = getHeight(element, attrs);
      var markerPath = pathMap.getScaledPath("MARKER_PARALLEL", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: width,
        containerHeight: height,
        position: {
          mx: (width / 2 - 6) / width,
          my: (height - 15) / height
        }
      });
      drawMarker("participant-multiplicity", parentGfx, markerPath, {
        strokeWidth: 2,
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke)
      });
    },
    "SubProcessMarker": function(parentGfx, element, attrs = {}) {
      var markerRect = drawRect(parentGfx, 14, 14, 0, {
        strokeWidth: 1,
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke)
      });
      translate$2(markerRect, element.width / 2 - 7.5, element.height - 20);
      var markerPath = pathMap.getScaledPath("MARKER_SUB_PROCESS", {
        xScaleFactor: 1.5,
        yScaleFactor: 1.5,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: (element.width / 2 - 7.5) / element.width,
          my: (element.height - 20) / element.height
        }
      });
      drawMarker("sub-process", parentGfx, markerPath, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke)
      });
    },
    "ParallelMarker": function(parentGfx, element, attrs) {
      var width = getWidth(element, attrs), height = getHeight(element, attrs);
      var markerPath = pathMap.getScaledPath("MARKER_PARALLEL", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: width,
        containerHeight: height,
        position: {
          mx: (width / 2 + attrs.parallel) / width,
          my: (height - 20) / height
        }
      });
      drawMarker("parallel", parentGfx, markerPath, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke)
      });
    },
    "SequentialMarker": function(parentGfx, element, attrs) {
      var markerPath = pathMap.getScaledPath("MARKER_SEQUENTIAL", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: (element.width / 2 + attrs.seq) / element.width,
          my: (element.height - 19) / element.height
        }
      });
      drawMarker("sequential", parentGfx, markerPath, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke)
      });
    },
    "CompensationMarker": function(parentGfx, element, attrs) {
      var markerMath = pathMap.getScaledPath("MARKER_COMPENSATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: (element.width / 2 + attrs.compensation) / element.width,
          my: (element.height - 13) / element.height
        }
      });
      drawMarker("compensation", parentGfx, markerMath, {
        strokeWidth: 1,
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke)
      });
    },
    "LoopMarker": function(parentGfx, element, attrs) {
      var width = getWidth(element, attrs), height = getHeight(element, attrs);
      var markerPath = pathMap.getScaledPath("MARKER_LOOP", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: width,
        containerHeight: height,
        position: {
          mx: (width / 2 + attrs.loop) / width,
          my: (height - 7) / height
        }
      });
      drawMarker("loop", parentGfx, markerPath, {
        strokeWidth: 1.5,
        fill: "none",
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        strokeMiterlimit: 0.5
      });
    },
    "AdhocMarker": function(parentGfx, element, attrs) {
      var width = getWidth(element, attrs), height = getHeight(element, attrs);
      var markerPath = pathMap.getScaledPath("MARKER_ADHOC", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: width,
        containerHeight: height,
        position: {
          mx: (width / 2 + attrs.adhoc) / width,
          my: (height - 15) / height
        }
      });
      drawMarker("adhoc", parentGfx, markerPath, {
        strokeWidth: 1,
        fill: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke)
      });
    }
  };
  function renderTaskMarker(type, parentGfx, element, attrs) {
    taskMarkerRenderers[type](parentGfx, element, attrs);
  }
  function renderTaskMarkers(parentGfx, element, taskMarkers, attrs = {}) {
    attrs = {
      fill: attrs.fill,
      stroke: attrs.stroke,
      width: getWidth(element, attrs),
      height: getHeight(element, attrs)
    };
    var semantic = getBusinessObject(element);
    var subprocess = taskMarkers && taskMarkers.includes("SubProcessMarker");
    if (subprocess) {
      attrs = {
        ...attrs,
        seq: -21,
        parallel: -22,
        compensation: -42,
        loop: -18,
        adhoc: 10
      };
    } else {
      attrs = {
        ...attrs,
        seq: -5,
        parallel: -6,
        compensation: -27,
        loop: 0,
        adhoc: 10
      };
    }
    forEach$1(taskMarkers, function(marker2) {
      renderTaskMarker(marker2, parentGfx, element, attrs);
    });
    if (semantic.get("isForCompensation")) {
      renderTaskMarker("CompensationMarker", parentGfx, element, attrs);
    }
    if (is$1(semantic, "bpmn:AdHocSubProcess")) {
      renderTaskMarker("AdhocMarker", parentGfx, element, attrs);
    }
    var loopCharacteristics = semantic.get("loopCharacteristics"), isSequential = loopCharacteristics && loopCharacteristics.get("isSequential");
    if (loopCharacteristics) {
      if (isSequential === void 0) {
        renderTaskMarker("LoopMarker", parentGfx, element, attrs);
      }
      if (isSequential === false) {
        renderTaskMarker("ParallelMarker", parentGfx, element, attrs);
      }
      if (isSequential === true) {
        renderTaskMarker("SequentialMarker", parentGfx, element, attrs);
      }
    }
  }
  function renderLabel(parentGfx, label, attrs = {}) {
    attrs = assign$1({
      size: {
        width: 100
      }
    }, attrs);
    var text = textRenderer.createText(label || "", attrs);
    classes(text).add("djs-label");
    append(parentGfx, text);
    return text;
  }
  function renderEmbeddedLabel(parentGfx, element, align, attrs = {}) {
    var semantic = getBusinessObject(element);
    var box = getBounds$1({
      x: element.x,
      y: element.y,
      width: element.width,
      height: element.height
    }, attrs);
    return renderLabel(parentGfx, semantic.name, {
      align,
      box,
      padding: 7,
      style: {
        fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor, attrs.stroke)
      }
    });
  }
  function renderExternalLabel(parentGfx, element, attrs = {}) {
    var box = {
      width: 90,
      height: 30,
      x: element.width / 2 + element.x,
      y: element.height / 2 + element.y
    };
    return renderLabel(parentGfx, getLabel(element), {
      box,
      fitBox: true,
      style: assign$1(
        {},
        textRenderer.getExternalStyle(),
        {
          fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor, attrs.stroke)
        }
      )
    });
  }
  function renderLaneLabel(parentGfx, text, element, attrs = {}) {
    var isHorizontalLane = isHorizontal$3(element);
    var textBox = renderLabel(parentGfx, text, {
      box: {
        height: 30,
        width: isHorizontalLane ? getHeight(element, attrs) : getWidth(element, attrs)
      },
      align: "center-middle",
      style: {
        fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor, attrs.stroke)
      }
    });
    if (isHorizontalLane) {
      var top = -1 * getHeight(element, attrs);
      transform(textBox, 0, -top, 270);
    }
  }
  function renderActivity(parentGfx, element, attrs = {}) {
    var {
      width,
      height
    } = getBounds$1(element, attrs);
    return drawRect(parentGfx, width, height, TASK_BORDER_RADIUS, {
      ...attrs,
      fill: getFillColor(element, defaultFillColor, attrs.fill),
      fillOpacity: DEFAULT_OPACITY,
      stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke)
    });
  }
  function renderAssociation(parentGfx, element, attrs = {}) {
    var semantic = getBusinessObject(element);
    var fill = getFillColor(element, defaultFillColor, attrs.fill), stroke = getStrokeColor$1(element, defaultStrokeColor, attrs.stroke);
    if (semantic.get("associationDirection") === "One" || semantic.get("associationDirection") === "Both") {
      attrs.markerEnd = marker("association-end", fill, stroke);
    }
    if (semantic.get("associationDirection") === "Both") {
      attrs.markerStart = marker("association-start", fill, stroke);
    }
    attrs = pickAttrs(attrs, [
      "markerStart",
      "markerEnd"
    ]);
    return drawConnectionSegments(parentGfx, element.waypoints, {
      ...attrs,
      stroke,
      strokeDasharray: "0, 5"
    });
  }
  function renderDataObject(parentGfx, element, attrs = {}) {
    var fill = getFillColor(element, defaultFillColor, attrs.fill), stroke = getStrokeColor$1(element, defaultStrokeColor, attrs.stroke);
    var pathData = pathMap.getScaledPath("DATA_OBJECT_PATH", {
      xScaleFactor: 1,
      yScaleFactor: 1,
      containerWidth: element.width,
      containerHeight: element.height,
      position: {
        mx: 0.474,
        my: 0.296
      }
    });
    var dataObject = drawPath2(parentGfx, pathData, {
      fill,
      fillOpacity: DEFAULT_OPACITY,
      stroke
    });
    var semantic = getBusinessObject(element);
    if (isCollection(semantic)) {
      var collectionPathData = pathMap.getScaledPath("DATA_OBJECT_COLLECTION_PATH", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.33,
          my: (element.height - 18) / element.height
        }
      });
      drawPath2(parentGfx, collectionPathData, {
        strokeWidth: 2,
        fill,
        stroke
      });
    }
    return dataObject;
  }
  function renderEvent(parentGfx, element, attrs = {}) {
    return drawCircle(parentGfx, element.width, element.height, {
      fillOpacity: DEFAULT_OPACITY,
      ...attrs,
      fill: getFillColor(element, defaultFillColor, attrs.fill),
      stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke)
    });
  }
  function renderGateway(parentGfx, element, attrs = {}) {
    return drawDiamond(parentGfx, element.width, element.height, {
      fill: getFillColor(element, defaultFillColor, attrs.fill),
      fillOpacity: DEFAULT_OPACITY,
      stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke)
    });
  }
  function renderLane(parentGfx, element, attrs = {}) {
    var lane = drawRect(parentGfx, getWidth(element, attrs), getHeight(element, attrs), 0, {
      fill: getFillColor(element, defaultFillColor, attrs.fill),
      fillOpacity: attrs.fillOpacity || DEFAULT_OPACITY,
      stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
      strokeWidth: 1.5
    });
    var semantic = getBusinessObject(element);
    if (is$1(semantic, "bpmn:Lane")) {
      var text = semantic.get("name");
      renderLaneLabel(parentGfx, text, element, attrs);
    }
    return lane;
  }
  function renderSubProcess(parentGfx, element, attrs = {}) {
    var activity = renderActivity(parentGfx, element, attrs);
    if (isEventSubProcess(element)) {
      attr(activity, {
        strokeDasharray: "0, 5.5",
        strokeWidth: 2.5
      });
    }
    var expanded = isExpanded(element);
    renderEmbeddedLabel(parentGfx, element, expanded ? "center-top" : "center-middle", attrs);
    if (expanded) {
      renderTaskMarkers(parentGfx, element, void 0, attrs);
    } else {
      renderTaskMarkers(parentGfx, element, ["SubProcessMarker"], attrs);
    }
    return activity;
  }
  function renderTask(parentGfx, element, attrs = {}) {
    var activity = renderActivity(parentGfx, element, attrs);
    renderEmbeddedLabel(parentGfx, element, "center-middle", attrs);
    renderTaskMarkers(parentGfx, element, void 0, attrs);
    return activity;
  }
  var handlers = this.handlers = {
    "bpmn:AdHocSubProcess": function(parentGfx, element, attrs = {}) {
      if (isExpanded(element)) {
        attrs = pickAttrs(attrs, [
          "fill",
          "stroke",
          "width",
          "height"
        ]);
      } else {
        attrs = pickAttrs(attrs, [
          "fill",
          "stroke"
        ]);
      }
      return renderSubProcess(parentGfx, element, attrs);
    },
    "bpmn:Association": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      return renderAssociation(parentGfx, element, attrs);
    },
    "bpmn:BoundaryEvent": function(parentGfx, element, attrs = {}) {
      var { renderIcon = true } = attrs;
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var semantic = getBusinessObject(element), cancelActivity = semantic.get("cancelActivity");
      attrs = {
        strokeWidth: 1.5,
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        fillOpacity: FULL_OPACITY,
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke)
      };
      if (!cancelActivity) {
        attrs.strokeDasharray = "6";
      }
      var event2 = renderEvent(parentGfx, element, attrs);
      drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST, {
        ...attrs,
        fill: "none"
      });
      if (renderIcon) {
        renderEventIcon(element, parentGfx, attrs);
      }
      return event2;
    },
    "bpmn:BusinessRuleTask": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var task = renderTask(parentGfx, element, attrs);
      var headerData = pathMap.getScaledPath("TASK_TYPE_BUSINESS_RULE_MAIN", {
        abspos: {
          x: 8,
          y: 8
        }
      });
      var businessPath = drawPath2(parentGfx, headerData);
      attr(businessPath, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
      var headerPathData = pathMap.getScaledPath("TASK_TYPE_BUSINESS_RULE_HEADER", {
        abspos: {
          x: 8,
          y: 8
        }
      });
      var businessHeaderPath = drawPath2(parentGfx, headerPathData);
      attr(businessHeaderPath, {
        fill: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
      return task;
    },
    "bpmn:CallActivity": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      return renderSubProcess(parentGfx, element, {
        strokeWidth: 5,
        ...attrs
      });
    },
    "bpmn:ComplexGateway": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var gateway = renderGateway(parentGfx, element, attrs);
      var pathData = pathMap.getScaledPath("GATEWAY_COMPLEX", {
        xScaleFactor: 0.5,
        yScaleFactor: 0.5,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.46,
          my: 0.26
        }
      });
      drawPath2(parentGfx, pathData, {
        fill: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
      return gateway;
    },
    "bpmn:DataInput": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var arrowPathData = pathMap.getRawPath("DATA_ARROW");
      var dataObject = renderDataObject(parentGfx, element, attrs);
      drawPath2(parentGfx, arrowPathData, {
        fill: "none",
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
      return dataObject;
    },
    "bpmn:DataInputAssociation": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      return renderAssociation(parentGfx, element, {
        ...attrs,
        markerEnd: marker("association-end", getFillColor(element, defaultFillColor, attrs.fill), getStrokeColor$1(element, defaultStrokeColor, attrs.stroke))
      });
    },
    "bpmn:DataObject": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      return renderDataObject(parentGfx, element, attrs);
    },
    "bpmn:DataObjectReference": as("bpmn:DataObject"),
    "bpmn:DataOutput": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var arrowPathData = pathMap.getRawPath("DATA_ARROW");
      var dataObject = renderDataObject(parentGfx, element, attrs);
      drawPath2(parentGfx, arrowPathData, {
        strokeWidth: 1,
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke)
      });
      return dataObject;
    },
    "bpmn:DataOutputAssociation": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      return renderAssociation(parentGfx, element, {
        ...attrs,
        markerEnd: marker("association-end", getFillColor(element, defaultFillColor, attrs.fill), getStrokeColor$1(element, defaultStrokeColor, attrs.stroke))
      });
    },
    "bpmn:DataStoreReference": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var dataStorePath = pathMap.getScaledPath("DATA_STORE", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0,
          my: 0.133
        }
      });
      return drawPath2(parentGfx, dataStorePath, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        fillOpacity: DEFAULT_OPACITY,
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 2
      });
    },
    "bpmn:EndEvent": function(parentGfx, element, attrs = {}) {
      var { renderIcon = true } = attrs;
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var event2 = renderEvent(parentGfx, element, {
        ...attrs,
        strokeWidth: 4
      });
      if (renderIcon) {
        renderEventIcon(element, parentGfx, attrs);
      }
      return event2;
    },
    "bpmn:EventBasedGateway": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var semantic = getBusinessObject(element);
      var diamond = renderGateway(parentGfx, element, attrs);
      drawCircle(parentGfx, element.width, element.height, element.height * 0.2, {
        fill: getFillColor(element, "none", attrs.fill),
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
      var type = semantic.get("eventGatewayType"), instantiate = !!semantic.get("instantiate");
      function drawEvent() {
        var pathData2 = pathMap.getScaledPath("GATEWAY_EVENT_BASED", {
          xScaleFactor: 0.18,
          yScaleFactor: 0.18,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.36,
            my: 0.44
          }
        });
        drawPath2(parentGfx, pathData2, {
          fill: "none",
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 2
        });
      }
      if (type === "Parallel") {
        var pathData = pathMap.getScaledPath("GATEWAY_PARALLEL", {
          xScaleFactor: 0.4,
          yScaleFactor: 0.4,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.474,
            my: 0.296
          }
        });
        drawPath2(parentGfx, pathData, {
          fill: "none",
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1
        });
      } else if (type === "Exclusive") {
        if (!instantiate) {
          drawCircle(parentGfx, element.width, element.height, element.height * 0.26, {
            fill: "none",
            stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
            strokeWidth: 1
          });
        }
        drawEvent();
      }
      return diamond;
    },
    "bpmn:ExclusiveGateway": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var gateway = renderGateway(parentGfx, element, attrs);
      var pathData = pathMap.getScaledPath("GATEWAY_EXCLUSIVE", {
        xScaleFactor: 0.4,
        yScaleFactor: 0.4,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.32,
          my: 0.3
        }
      });
      var di = getDi(element);
      if (di.get("isMarkerVisible")) {
        drawPath2(parentGfx, pathData, {
          fill: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1
        });
      }
      return gateway;
    },
    "bpmn:Gateway": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      return renderGateway(parentGfx, element, attrs);
    },
    "bpmn:Group": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke",
        "width",
        "height"
      ]);
      return drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS, {
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1.5,
        strokeDasharray: "10, 6, 0, 6",
        fill: "none",
        pointerEvents: "none",
        width: getWidth(element, attrs),
        height: getHeight(element, attrs)
      });
    },
    "bpmn:InclusiveGateway": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var gateway = renderGateway(parentGfx, element, attrs);
      drawCircle(parentGfx, element.width, element.height, element.height * 0.24, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 2.5
      });
      return gateway;
    },
    "bpmn:IntermediateEvent": function(parentGfx, element, attrs = {}) {
      var { renderIcon = true } = attrs;
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var outer = renderEvent(parentGfx, element, {
        ...attrs,
        strokeWidth: 1.5
      });
      drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST, {
        fill: "none",
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1.5
      });
      if (renderIcon) {
        renderEventIcon(element, parentGfx, attrs);
      }
      return outer;
    },
    "bpmn:IntermediateCatchEvent": as("bpmn:IntermediateEvent"),
    "bpmn:IntermediateThrowEvent": as("bpmn:IntermediateEvent"),
    "bpmn:Lane": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke",
        "width",
        "height"
      ]);
      return renderLane(parentGfx, element, {
        ...attrs,
        fillOpacity: LOW_OPACITY
      });
    },
    "bpmn:ManualTask": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var task = renderTask(parentGfx, element, attrs);
      var pathData = pathMap.getScaledPath("TASK_TYPE_MANUAL", {
        abspos: {
          x: 17,
          y: 15
        }
      });
      drawPath2(parentGfx, pathData, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 0.5
      });
      return task;
    },
    "bpmn:MessageFlow": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var semantic = getBusinessObject(element), di = getDi(element);
      var fill = getFillColor(element, defaultFillColor, attrs.fill), stroke = getStrokeColor$1(element, defaultStrokeColor, attrs.stroke);
      var path = drawConnectionSegments(parentGfx, element.waypoints, {
        markerEnd: marker("messageflow-end", fill, stroke),
        markerStart: marker("messageflow-start", fill, stroke),
        stroke,
        strokeDasharray: "10, 11",
        strokeWidth: 1.5
      });
      if (semantic.get("messageRef")) {
        var midPoint = path.getPointAtLength(path.getTotalLength() / 2);
        var markerPathData = pathMap.getScaledPath("MESSAGE_FLOW_MARKER", {
          abspos: {
            x: midPoint.x,
            y: midPoint.y
          }
        });
        var messageAttrs = {
          strokeWidth: 1
        };
        if (di.get("messageVisibleKind") === "initiating") {
          messageAttrs.fill = fill;
          messageAttrs.stroke = stroke;
        } else {
          messageAttrs.fill = stroke;
          messageAttrs.stroke = fill;
        }
        var message = drawPath2(parentGfx, markerPathData, messageAttrs);
        var messageRef = semantic.get("messageRef"), name2 = messageRef.get("name");
        var label = renderLabel(parentGfx, name2, {
          align: "center-top",
          fitBox: true,
          style: {
            fill: stroke
          }
        });
        var messageBounds = message.getBBox(), labelBounds = label.getBBox();
        var translateX = midPoint.x - labelBounds.width / 2, translateY = midPoint.y + messageBounds.height / 2 + ELEMENT_LABEL_DISTANCE$1;
        transform(label, translateX, translateY, 0);
      }
      return path;
    },
    "bpmn:ParallelGateway": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var diamond = renderGateway(parentGfx, element, attrs);
      var pathData = pathMap.getScaledPath("GATEWAY_PARALLEL", {
        xScaleFactor: 0.6,
        yScaleFactor: 0.6,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.46,
          my: 0.2
        }
      });
      drawPath2(parentGfx, pathData, {
        fill: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
      return diamond;
    },
    "bpmn:Participant": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke",
        "width",
        "height"
      ]);
      var participant = renderLane(parentGfx, element, attrs);
      var expandedParticipant = isExpanded(element);
      var horizontalParticipant = isHorizontal$3(element);
      var semantic = getBusinessObject(element), name2 = semantic.get("name");
      if (expandedParticipant) {
        var waypoints = horizontalParticipant ? [
          {
            x: 30,
            y: 0
          },
          {
            x: 30,
            y: getHeight(element, attrs)
          }
        ] : [
          {
            x: 0,
            y: 30
          },
          {
            x: getWidth(element, attrs),
            y: 30
          }
        ];
        drawLine(parentGfx, waypoints, {
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: PARTICIPANT_STROKE_WIDTH
        });
        renderLaneLabel(parentGfx, name2, element, attrs);
      } else {
        var bounds = getBounds$1(element, attrs);
        if (!horizontalParticipant) {
          bounds.height = getWidth(element, attrs);
          bounds.width = getHeight(element, attrs);
        }
        var textBox = renderLabel(parentGfx, name2, {
          box: bounds,
          align: "center-middle",
          style: {
            fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor, attrs.stroke)
          }
        });
        if (!horizontalParticipant) {
          var top = -1 * getHeight(element, attrs);
          transform(textBox, 0, -top, 270);
        }
      }
      if (semantic.get("participantMultiplicity")) {
        renderTaskMarker("ParticipantMultiplicityMarker", parentGfx, element, attrs);
      }
      return participant;
    },
    "bpmn:ReceiveTask": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var semantic = getBusinessObject(element);
      var task = renderTask(parentGfx, element, attrs);
      var pathData;
      if (semantic.get("instantiate")) {
        drawCircle(parentGfx, 28, 28, 20 * 0.22, {
          fill: getFillColor(element, defaultFillColor, attrs.fill),
          stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1
        });
        pathData = pathMap.getScaledPath("TASK_TYPE_INSTANTIATING_SEND", {
          abspos: {
            x: 7.77,
            y: 9.52
          }
        });
      } else {
        pathData = pathMap.getScaledPath("TASK_TYPE_SEND", {
          xScaleFactor: 0.9,
          yScaleFactor: 0.9,
          containerWidth: 21,
          containerHeight: 14,
          position: {
            mx: 0.3,
            my: 0.4
          }
        });
      }
      drawPath2(parentGfx, pathData, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
      return task;
    },
    "bpmn:ScriptTask": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var task = renderTask(parentGfx, element, attrs);
      var pathData = pathMap.getScaledPath("TASK_TYPE_SCRIPT", {
        abspos: {
          x: 15,
          y: 20
        }
      });
      drawPath2(parentGfx, pathData, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
      return task;
    },
    "bpmn:SendTask": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var task = renderTask(parentGfx, element, attrs);
      var pathData = pathMap.getScaledPath("TASK_TYPE_SEND", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: 21,
        containerHeight: 14,
        position: {
          mx: 0.285,
          my: 0.357
        }
      });
      drawPath2(parentGfx, pathData, {
        fill: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        stroke: getFillColor(element, defaultFillColor, attrs.fill),
        strokeWidth: 1
      });
      return task;
    },
    "bpmn:SequenceFlow": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var fill = getFillColor(element, defaultFillColor, attrs.fill), stroke = getStrokeColor$1(element, defaultStrokeColor, attrs.stroke);
      var connection = drawConnectionSegments(parentGfx, element.waypoints, {
        markerEnd: marker("sequenceflow-end", fill, stroke),
        stroke
      });
      var semantic = getBusinessObject(element);
      var { source } = element;
      if (source) {
        var sourceSemantic = getBusinessObject(source);
        if (semantic.get("conditionExpression") && is$1(sourceSemantic, "bpmn:Activity")) {
          attr(connection, {
            markerStart: marker("conditional-flow-marker", fill, stroke)
          });
        }
        if (sourceSemantic.get("default") && (is$1(sourceSemantic, "bpmn:Gateway") || is$1(sourceSemantic, "bpmn:Activity")) && sourceSemantic.get("default") === semantic) {
          attr(connection, {
            markerStart: marker("conditional-default-flow-marker", fill, stroke)
          });
        }
      }
      return connection;
    },
    "bpmn:ServiceTask": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var task = renderTask(parentGfx, element, attrs);
      drawCircle(parentGfx, 10, 10, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: "none",
        transform: "translate(6, 6)"
      });
      var pathDataService1 = pathMap.getScaledPath("TASK_TYPE_SERVICE", {
        abspos: {
          x: 12,
          y: 18
        }
      });
      drawPath2(parentGfx, pathDataService1, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
      drawCircle(parentGfx, 10, 10, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: "none",
        transform: "translate(11, 10)"
      });
      var pathDataService2 = pathMap.getScaledPath("TASK_TYPE_SERVICE", {
        abspos: {
          x: 17,
          y: 22
        }
      });
      drawPath2(parentGfx, pathDataService2, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
      return task;
    },
    "bpmn:StartEvent": function(parentGfx, element, attrs = {}) {
      var { renderIcon = true } = attrs;
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var semantic = getBusinessObject(element);
      if (!semantic.get("isInterrupting")) {
        attrs = {
          ...attrs,
          strokeDasharray: "6"
        };
      }
      var event2 = renderEvent(parentGfx, element, attrs);
      if (renderIcon) {
        renderEventIcon(element, parentGfx, attrs);
      }
      return event2;
    },
    "bpmn:SubProcess": function(parentGfx, element, attrs = {}) {
      if (isExpanded(element)) {
        attrs = pickAttrs(attrs, [
          "fill",
          "stroke",
          "width",
          "height"
        ]);
      } else {
        attrs = pickAttrs(attrs, [
          "fill",
          "stroke"
        ]);
      }
      return renderSubProcess(parentGfx, element, attrs);
    },
    "bpmn:Task": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      return renderTask(parentGfx, element, attrs);
    },
    "bpmn:TextAnnotation": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke",
        "width",
        "height"
      ]);
      var {
        width,
        height
      } = getBounds$1(element, attrs);
      var textElement = drawRect(parentGfx, width, height, 0, 0, {
        fill: "none",
        stroke: "none"
      });
      var textPathData = pathMap.getScaledPath("TEXT_ANNOTATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: width,
        containerHeight: height,
        position: {
          mx: 0,
          my: 0
        }
      });
      drawPath2(parentGfx, textPathData, {
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke)
      });
      var semantic = getBusinessObject(element), text = semantic.get("text") || "";
      renderLabel(parentGfx, text, {
        align: "left-top",
        box: getBounds$1(element, attrs),
        padding: 7,
        style: {
          fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor, attrs.stroke)
        }
      });
      return textElement;
    },
    "bpmn:Transaction": function(parentGfx, element, attrs = {}) {
      if (isExpanded(element)) {
        attrs = pickAttrs(attrs, [
          "fill",
          "stroke",
          "width",
          "height"
        ]);
      } else {
        attrs = pickAttrs(attrs, [
          "fill",
          "stroke"
        ]);
      }
      var outer = renderSubProcess(parentGfx, element, {
        strokeWidth: 1.5,
        ...attrs
      });
      var innerAttrs = styles.style(["no-fill", "no-events"], {
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1.5
      });
      var expanded = isExpanded(element);
      if (!expanded) {
        attrs = {};
      }
      drawRect(
        parentGfx,
        getWidth(element, attrs),
        getHeight(element, attrs),
        TASK_BORDER_RADIUS - INNER_OUTER_DIST,
        INNER_OUTER_DIST,
        innerAttrs
      );
      return outer;
    },
    "bpmn:UserTask": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var task = renderTask(parentGfx, element, attrs);
      var x2 = 15;
      var y2 = 12;
      var pathDataUser1 = pathMap.getScaledPath("TASK_TYPE_USER_1", {
        abspos: {
          x: x2,
          y: y2
        }
      });
      drawPath2(parentGfx, pathDataUser1, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 0.5
      });
      var pathDataUser2 = pathMap.getScaledPath("TASK_TYPE_USER_2", {
        abspos: {
          x: x2,
          y: y2
        }
      });
      drawPath2(parentGfx, pathDataUser2, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 0.5
      });
      var pathDataUser3 = pathMap.getScaledPath("TASK_TYPE_USER_3", {
        abspos: {
          x: x2,
          y: y2
        }
      });
      drawPath2(parentGfx, pathDataUser3, {
        fill: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        stroke: getStrokeColor$1(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 0.5
      });
      return task;
    },
    "label": function(parentGfx, element, attrs = {}) {
      return renderExternalLabel(parentGfx, element, attrs);
    }
  };
  this._drawPath = drawPath2;
  this._renderer = renderer;
}
e$3(BpmnRenderer, BaseRenderer);
BpmnRenderer.$inject = [
  "config.bpmnRenderer",
  "eventBus",
  "styles",
  "pathMap",
  "canvas",
  "textRenderer"
];
BpmnRenderer.prototype.canRender = function(element) {
  return is$1(element, "bpmn:BaseElement");
};
BpmnRenderer.prototype.drawShape = function(parentGfx, element, attrs = {}) {
  var { type } = element;
  var handler = this._renderer(type);
  return handler(parentGfx, element, attrs);
};
BpmnRenderer.prototype.drawConnection = function(parentGfx, element, attrs = {}) {
  var { type } = element;
  var handler = this._renderer(type);
  return handler(parentGfx, element, attrs);
};
BpmnRenderer.prototype.getShapePath = function(element) {
  if (is$1(element, "bpmn:Event")) {
    return getCirclePath(element);
  }
  if (is$1(element, "bpmn:Activity")) {
    return getRoundRectPath(element, TASK_BORDER_RADIUS);
  }
  if (is$1(element, "bpmn:Gateway")) {
    return getDiamondPath(element);
  }
  return getRectPath(element);
};
function pickAttrs(attrs, keys2 = []) {
  return keys2.reduce((pickedAttrs, key) => {
    if (attrs[key]) {
      pickedAttrs[key] = attrs[key];
    }
    return pickedAttrs;
  }, {});
}
var DEFAULT_BOX_PADDING = 0;
var DEFAULT_LABEL_SIZE = {
  width: 150,
  height: 50
};
function parseAlign(align) {
  var parts = align.split("-");
  return {
    horizontal: parts[0] || "center",
    vertical: parts[1] || "top"
  };
}
function parsePadding(padding) {
  if (isObject(padding)) {
    return assign$1({ top: 0, left: 0, right: 0, bottom: 0 }, padding);
  } else {
    return {
      top: padding,
      left: padding,
      right: padding,
      bottom: padding
    };
  }
}
function getTextBBox(text, fakeText) {
  fakeText.textContent = text;
  var textBBox;
  try {
    var bbox, emptyLine = text === "";
    fakeText.textContent = emptyLine ? "dummy" : text;
    textBBox = fakeText.getBBox();
    bbox = {
      width: textBBox.width + textBBox.x * 2,
      height: textBBox.height
    };
    if (emptyLine) {
      bbox.width = 0;
    }
    return bbox;
  } catch (e2) {
    return { width: 0, height: 0 };
  }
}
function layoutNext(lines, maxWidth, fakeText) {
  var originalLine = lines.shift(), fitLine = originalLine;
  var textBBox;
  for (; ; ) {
    textBBox = getTextBBox(fitLine, fakeText);
    textBBox.width = fitLine ? textBBox.width : 0;
    if (fitLine === " " || fitLine === "" || textBBox.width < Math.round(maxWidth) || fitLine.length < 2) {
      return fit(lines, fitLine, originalLine, textBBox);
    }
    fitLine = shortenLine(fitLine, textBBox.width, maxWidth);
  }
}
function fit(lines, fitLine, originalLine, textBBox) {
  if (fitLine.length < originalLine.length) {
    var remainder = originalLine.slice(fitLine.length).trim();
    lines.unshift(remainder);
  }
  return {
    width: textBBox.width,
    height: textBBox.height,
    text: fitLine
  };
}
var SOFT_BREAK = "­";
function semanticShorten(line, maxLength) {
  var parts = line.split(/(\s|-|\u00AD)/g), part, shortenedParts = [], length2 = 0;
  if (parts.length > 1) {
    while (part = parts.shift()) {
      if (part.length + length2 < maxLength) {
        shortenedParts.push(part);
        length2 += part.length;
      } else {
        if (part === "-" || part === SOFT_BREAK) {
          shortenedParts.pop();
        }
        break;
      }
    }
  }
  var last2 = shortenedParts[shortenedParts.length - 1];
  if (last2 && last2 === SOFT_BREAK) {
    shortenedParts[shortenedParts.length - 1] = "-";
  }
  return shortenedParts.join("");
}
function shortenLine(line, width, maxWidth) {
  var length2 = Math.max(line.length * (maxWidth / width), 1);
  var shortenedLine = semanticShorten(line, length2);
  if (!shortenedLine) {
    shortenedLine = line.slice(0, Math.max(Math.round(length2 - 1), 1));
  }
  return shortenedLine;
}
function getHelperSvg() {
  var helperSvg = document.getElementById("helper-svg");
  if (!helperSvg) {
    helperSvg = create$1("svg");
    attr(helperSvg, {
      id: "helper-svg"
    });
    assign(helperSvg, {
      visibility: "hidden",
      position: "fixed",
      width: 0,
      height: 0
    });
    document.body.appendChild(helperSvg);
  }
  return helperSvg;
}
function Text(config) {
  this._config = assign$1({}, {
    size: DEFAULT_LABEL_SIZE,
    padding: DEFAULT_BOX_PADDING,
    style: {},
    align: "center-top"
  }, config || {});
}
Text.prototype.createText = function(text, options) {
  return this.layoutText(text, options).element;
};
Text.prototype.getDimensions = function(text, options) {
  return this.layoutText(text, options).dimensions;
};
Text.prototype.layoutText = function(text, options) {
  var box = assign$1({}, this._config.size, options.box), style = assign$1({}, this._config.style, options.style), align = parseAlign(options.align || this._config.align), padding = parsePadding(options.padding !== void 0 ? options.padding : this._config.padding), fitBox = options.fitBox || false;
  var lineHeight = getLineHeight(style);
  var lines = text.split(/\u00AD?\r?\n/), layouted = [];
  var maxWidth = box.width - padding.left - padding.right;
  var helperText = create$1("text");
  attr(helperText, { x: 0, y: 0 });
  attr(helperText, style);
  var helperSvg = getHelperSvg();
  append(helperSvg, helperText);
  while (lines.length) {
    layouted.push(layoutNext(lines, maxWidth, helperText));
  }
  if (align.vertical === "middle") {
    padding.top = padding.bottom = 0;
  }
  var totalHeight = reduce(layouted, function(sum, line, idx) {
    return sum + (lineHeight || line.height);
  }, 0) + padding.top + padding.bottom;
  var maxLineWidth = reduce(layouted, function(sum, line, idx) {
    return line.width > sum ? line.width : sum;
  }, 0);
  var y2 = padding.top;
  if (align.vertical === "middle") {
    y2 += (box.height - totalHeight) / 2;
  }
  y2 -= (lineHeight || layouted[0].height) / 4;
  var textElement = create$1("text");
  attr(textElement, style);
  forEach$1(layouted, function(line) {
    var x2;
    y2 += lineHeight || line.height;
    switch (align.horizontal) {
      case "left":
        x2 = padding.left;
        break;
      case "right":
        x2 = (fitBox ? maxLineWidth : maxWidth) - padding.right - line.width;
        break;
      default:
        x2 = Math.max(((fitBox ? maxLineWidth : maxWidth) - line.width) / 2 + padding.left, 0);
    }
    var tspan = create$1("tspan");
    attr(tspan, { x: x2, y: y2 });
    tspan.textContent = line.text;
    append(textElement, tspan);
  });
  remove$1(helperText);
  var dimensions = {
    width: maxLineWidth,
    height: totalHeight
  };
  return {
    dimensions,
    element: textElement
  };
};
function getLineHeight(style) {
  if ("fontSize" in style && "lineHeight" in style) {
    return style.lineHeight * parseInt(style.fontSize, 10);
  }
}
var DEFAULT_FONT_SIZE = 12;
var LINE_HEIGHT_RATIO = 1.2;
var MIN_TEXT_ANNOTATION_HEIGHT = 30;
function TextRenderer(config) {
  var defaultStyle = assign$1({
    fontFamily: "Arial, sans-serif",
    fontSize: DEFAULT_FONT_SIZE,
    fontWeight: "normal",
    lineHeight: LINE_HEIGHT_RATIO
  }, config && config.defaultStyle || {});
  var fontSize = parseInt(defaultStyle.fontSize, 10) - 1;
  var externalStyle = assign$1({}, defaultStyle, {
    fontSize
  }, config && config.externalStyle || {});
  var textUtil = new Text({
    style: defaultStyle
  });
  this.getExternalLabelBounds = function(bounds, text) {
    var layoutedDimensions = textUtil.getDimensions(text, {
      box: {
        width: 90,
        height: 30
      },
      style: externalStyle
    });
    return {
      x: Math.round(bounds.x + bounds.width / 2 - layoutedDimensions.width / 2),
      y: Math.round(bounds.y),
      width: Math.ceil(layoutedDimensions.width),
      height: Math.ceil(layoutedDimensions.height)
    };
  };
  this.getTextAnnotationBounds = function(bounds, text) {
    var layoutedDimensions = textUtil.getDimensions(text, {
      box: bounds,
      style: defaultStyle,
      align: "left-top",
      padding: 5
    });
    return {
      x: bounds.x,
      y: bounds.y,
      width: bounds.width,
      height: Math.max(MIN_TEXT_ANNOTATION_HEIGHT, Math.round(layoutedDimensions.height))
    };
  };
  this.createText = function(text, options) {
    return textUtil.createText(text, options || {});
  };
  this.getDefaultStyle = function() {
    return defaultStyle;
  };
  this.getExternalStyle = function() {
    return externalStyle;
  };
}
TextRenderer.$inject = [
  "config.textRenderer"
];
function PathMap() {
  this.pathMap = {
    "EVENT_MESSAGE": {
      d: "m {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}",
      height: 36,
      width: 36,
      heightElements: [6, 14],
      widthElements: [10.5, 21]
    },
    "EVENT_SIGNAL": {
      d: "M {mx},{my} l {e.x0},{e.y0} l -{e.x1},0 Z",
      height: 36,
      width: 36,
      heightElements: [18],
      widthElements: [10, 20]
    },
    "EVENT_ESCALATION": {
      d: "M {mx},{my} l {e.x0},{e.y0} l -{e.x0},-{e.y1} l -{e.x0},{e.y1} Z",
      height: 36,
      width: 36,
      heightElements: [20, 7],
      widthElements: [8]
    },
    "EVENT_CONDITIONAL": {
      d: "M {e.x0},{e.y0} l {e.x1},0 l 0,{e.y2} l -{e.x1},0 Z M {e.x2},{e.y3} l {e.x0},0 M {e.x2},{e.y4} l {e.x0},0 M {e.x2},{e.y5} l {e.x0},0 M {e.x2},{e.y6} l {e.x0},0 M {e.x2},{e.y7} l {e.x0},0 M {e.x2},{e.y8} l {e.x0},0 ",
      height: 36,
      width: 36,
      heightElements: [8.5, 14.5, 18, 11.5, 14.5, 17.5, 20.5, 23.5, 26.5],
      widthElements: [10.5, 14.5, 12.5]
    },
    "EVENT_LINK": {
      d: "m {mx},{my} 0,{e.y0} -{e.x1},0 0,{e.y1} {e.x1},0 0,{e.y0} {e.x0},-{e.y2} -{e.x0},-{e.y2} z",
      height: 36,
      width: 36,
      heightElements: [4.4375, 6.75, 7.8125],
      widthElements: [9.84375, 13.5]
    },
    "EVENT_ERROR": {
      d: "m {mx},{my} {e.x0},-{e.y0} {e.x1},-{e.y1} {e.x2},{e.y2} {e.x3},-{e.y3} -{e.x4},{e.y4} -{e.x5},-{e.y5} z",
      height: 36,
      width: 36,
      heightElements: [0.023, 8.737, 8.151, 16.564, 10.591, 8.714],
      widthElements: [0.085, 6.672, 6.97, 4.273, 5.337, 6.636]
    },
    "EVENT_CANCEL_45": {
      d: "m {mx},{my} -{e.x1},0 0,{e.x0} {e.x1},0 0,{e.y1} {e.x0},0 0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z",
      height: 36,
      width: 36,
      heightElements: [4.75, 8.5],
      widthElements: [4.75, 8.5]
    },
    "EVENT_COMPENSATION": {
      d: "m {mx},{my} {e.x0},-{e.y0} 0,{e.y1} z m {e.x1},-{e.y2} {e.x2},-{e.y3} 0,{e.y1} -{e.x2},-{e.y3} z",
      height: 36,
      width: 36,
      heightElements: [6.5, 13, 0.4, 6.1],
      widthElements: [9, 9.3, 8.7]
    },
    "EVENT_TIMER_WH": {
      d: "M {mx},{my} l {e.x0},-{e.y0} m -{e.x0},{e.y0} l {e.x1},{e.y1} ",
      height: 36,
      width: 36,
      heightElements: [10, 2],
      widthElements: [3, 7]
    },
    "EVENT_TIMER_LINE": {
      d: "M {mx},{my} m {e.x0},{e.y0} l -{e.x1},{e.y1} ",
      height: 36,
      width: 36,
      heightElements: [10, 3],
      widthElements: [0, 0]
    },
    "EVENT_MULTIPLE": {
      d: "m {mx},{my} {e.x1},-{e.y0} {e.x1},{e.y0} -{e.x0},{e.y1} -{e.x2},0 z",
      height: 36,
      width: 36,
      heightElements: [6.28099, 12.56199],
      widthElements: [3.1405, 9.42149, 12.56198]
    },
    "EVENT_PARALLEL_MULTIPLE": {
      d: "m {mx},{my} {e.x0},0 0,{e.y1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} -{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z",
      height: 36,
      width: 36,
      heightElements: [2.56228, 7.68683],
      widthElements: [2.56228, 7.68683]
    },
    "GATEWAY_EXCLUSIVE": {
      d: "m {mx},{my} {e.x0},{e.y0} {e.x1},{e.y0} {e.x2},0 {e.x4},{e.y2} {e.x4},{e.y1} {e.x2},0 {e.x1},{e.y3} {e.x0},{e.y3} {e.x3},0 {e.x5},{e.y1} {e.x5},{e.y2} {e.x3},0 z",
      height: 17.5,
      width: 17.5,
      heightElements: [8.5, 6.5312, -6.5312, -8.5],
      widthElements: [6.5, -6.5, 3, -3, 5, -5]
    },
    "GATEWAY_PARALLEL": {
      d: "m {mx},{my} 0,{e.y1} -{e.x1},0 0,{e.y0} {e.x1},0 0,{e.y1} {e.x0},0 0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z",
      height: 30,
      width: 30,
      heightElements: [5, 12.5],
      widthElements: [5, 12.5]
    },
    "GATEWAY_EVENT_BASED": {
      d: "m {mx},{my} {e.x0},{e.y0} {e.x0},{e.y1} {e.x1},{e.y2} {e.x2},0 z",
      height: 11,
      width: 11,
      heightElements: [-6, 6, 12, -12],
      widthElements: [9, -3, -12]
    },
    "GATEWAY_COMPLEX": {
      d: "m {mx},{my} 0,{e.y0} -{e.x0},-{e.y1} -{e.x1},{e.y2} {e.x0},{e.y1} -{e.x2},0 0,{e.y3} {e.x2},0  -{e.x0},{e.y1} l {e.x1},{e.y2} {e.x0},-{e.y1} 0,{e.y0} {e.x3},0 0,-{e.y0} {e.x0},{e.y1} {e.x1},-{e.y2} -{e.x0},-{e.y1} {e.x2},0 0,-{e.y3} -{e.x2},0 {e.x0},-{e.y1} -{e.x1},-{e.y2} -{e.x0},{e.y1} 0,-{e.y0} -{e.x3},0 z",
      height: 17.125,
      width: 17.125,
      heightElements: [4.875, 3.4375, 2.125, 3],
      widthElements: [3.4375, 2.125, 4.875, 3]
    },
    "DATA_OBJECT_PATH": {
      d: "m 0,0 {e.x1},0 {e.x0},{e.y0} 0,{e.y1} -{e.x2},0 0,-{e.y2} {e.x1},0 0,{e.y0} {e.x0},0",
      height: 61,
      width: 51,
      heightElements: [10, 50, 60],
      widthElements: [10, 40, 50, 60]
    },
    "DATA_OBJECT_COLLECTION_PATH": {
      d: "m{mx},{my} m 3,2 l 0,10 m 3,-10 l 0,10 m 3,-10 l 0,10",
      height: 10,
      width: 10,
      heightElements: [],
      widthElements: []
    },
    "DATA_ARROW": {
      d: "m 5,9 9,0 0,-3 5,5 -5,5 0,-3 -9,0 z",
      height: 61,
      width: 51,
      heightElements: [],
      widthElements: []
    },
    "DATA_STORE": {
      d: "m  {mx},{my} l  0,{e.y2} c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 l  0,-{e.y2} c -{e.x0},-{e.y1} -{e.x1},-{e.y1} -{e.x2},0c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 m  -{e.x2},{e.y0}c  {e.x0},{e.y1} {e.x1},{e.y1} {e.x2},0m  -{e.x2},{e.y0}c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0",
      height: 61,
      width: 61,
      heightElements: [7, 10, 45],
      widthElements: [2, 58, 60]
    },
    "TEXT_ANNOTATION": {
      d: "m {mx}, {my} m 10,0 l -10,0 l 0,{e.y0} l 10,0",
      height: 30,
      width: 10,
      heightElements: [30],
      widthElements: [10]
    },
    "MARKER_SUB_PROCESS": {
      d: "m{mx},{my} m 7,2 l 0,10 m -5,-5 l 10,0",
      height: 10,
      width: 10,
      heightElements: [],
      widthElements: []
    },
    "MARKER_PARALLEL": {
      d: "m{mx},{my} m 3,2 l 0,10 m 3,-10 l 0,10 m 3,-10 l 0,10",
      height: 10,
      width: 10,
      heightElements: [],
      widthElements: []
    },
    "MARKER_SEQUENTIAL": {
      d: "m{mx},{my} m 0,3 l 10,0 m -10,3 l 10,0 m -10,3 l 10,0",
      height: 10,
      width: 10,
      heightElements: [],
      widthElements: []
    },
    "MARKER_COMPENSATION": {
      d: "m {mx},{my} 7,-5 0,10 z m 7.1,-0.3 6.9,-4.7 0,10 -6.9,-4.7 z",
      height: 10,
      width: 21,
      heightElements: [],
      widthElements: []
    },
    "MARKER_LOOP": {
      d: "m {mx},{my} c 3.526979,0 6.386161,-2.829858 6.386161,-6.320661 0,-3.490806 -2.859182,-6.320661 -6.386161,-6.320661 -3.526978,0 -6.38616,2.829855 -6.38616,6.320661 0,1.745402 0.714797,3.325567 1.870463,4.469381 0.577834,0.571908 1.265885,1.034728 2.029916,1.35457 l -0.718163,-3.909793 m 0.718163,3.909793 -3.885211,0.802902",
      height: 13.9,
      width: 13.7,
      heightElements: [],
      widthElements: []
    },
    "MARKER_ADHOC": {
      d: "m {mx},{my} m 0.84461,2.64411 c 1.05533,-1.23780996 2.64337,-2.07882 4.29653,-1.97997996 2.05163,0.0805 3.85579,1.15803 5.76082,1.79107 1.06385,0.34139996 2.24454,0.1438 3.18759,-0.43767 0.61743,-0.33642 1.2775,-0.64078 1.7542,-1.17511 0,0.56023 0,1.12046 0,1.6807 -0.98706,0.96237996 -2.29792,1.62393996 -3.6918,1.66181996 -1.24459,0.0927 -2.46671,-0.2491 -3.59505,-0.74812 -1.35789,-0.55965 -2.75133,-1.33436996 -4.27027,-1.18121996 -1.37741,0.14601 -2.41842,1.13685996 -3.44288,1.96782996 z",
      height: 4,
      width: 15,
      heightElements: [],
      widthElements: []
    },
    "TASK_TYPE_SEND": {
      d: "m {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}",
      height: 14,
      width: 21,
      heightElements: [6, 14],
      widthElements: [10.5, 21]
    },
    "TASK_TYPE_SCRIPT": {
      d: "m {mx},{my} c 9.966553,-6.27276 -8.000926,-7.91932 2.968968,-14.938 l -8.802728,0 c -10.969894,7.01868 6.997585,8.66524 -2.968967,14.938 z m -7,-12 l 5,0 m -4.5,3 l 4.5,0 m -3,3 l 5,0m -4,3 l 5,0",
      height: 15,
      width: 12.6,
      heightElements: [6, 14],
      widthElements: [10.5, 21]
    },
    "TASK_TYPE_USER_1": {
      d: "m {mx},{my} c 0.909,-0.845 1.594,-2.049 1.594,-3.385 0,-2.554 -1.805,-4.62199999 -4.357,-4.62199999 -2.55199998,0 -4.28799998,2.06799999 -4.28799998,4.62199999 0,1.348 0.974,2.562 1.89599998,3.405 -0.52899998,0.187 -5.669,2.097 -5.794,4.7560005 v 6.718 h 17 v -6.718 c 0,-2.2980005 -5.5279996,-4.5950005 -6.0509996,-4.7760005 zm -8,6 l 0,5.5 m 11,0 l 0,-5"
    },
    "TASK_TYPE_USER_2": {
      d: "m {mx},{my} m 2.162,1.009 c 0,2.4470005 -2.158,4.4310005 -4.821,4.4310005 -2.66499998,0 -4.822,-1.981 -4.822,-4.4310005 "
    },
    "TASK_TYPE_USER_3": {
      d: "m {mx},{my} m -6.9,-3.80 c 0,0 2.25099998,-2.358 4.27399998,-1.177 2.024,1.181 4.221,1.537 4.124,0.965 -0.098,-0.57 -0.117,-3.79099999 -4.191,-4.13599999 -3.57499998,0.001 -4.20799998,3.36699999 -4.20699998,4.34799999 z"
    },
    "TASK_TYPE_MANUAL": {
      d: "m {mx},{my} c 0.234,-0.01 5.604,0.008 8.029,0.004 0.808,0 1.271,-0.172 1.417,-0.752 0.227,-0.898 -0.334,-1.314 -1.338,-1.316 -2.467,-0.01 -7.886,-0.004 -8.108,-0.004 -0.014,-0.079 0.016,-0.533 0,-0.61 0.195,-0.042 8.507,0.006 9.616,0.002 0.877,-0.007 1.35,-0.438 1.353,-1.208 0.003,-0.768 -0.479,-1.09 -1.35,-1.091 -2.968,-0.002 -9.619,-0.013 -9.619,-0.013 v -0.591 c 0,0 5.052,-0.016 7.225,-0.016 0.888,-0.002 1.354,-0.416 1.351,-1.193 -0.006,-0.761 -0.492,-1.196 -1.361,-1.196 -3.473,-0.005 -10.86,-0.003 -11.0829995,-0.003 -0.022,-0.047 -0.045,-0.094 -0.069,-0.139 0.3939995,-0.319 2.0409995,-1.626 2.4149995,-2.017 0.469,-0.4870005 0.519,-1.1650005 0.162,-1.6040005 -0.414,-0.511 -0.973,-0.5 -1.48,-0.236 -1.4609995,0.764 -6.5999995,3.6430005 -7.7329995,4.2710005 -0.9,0.499 -1.516,1.253 -1.882,2.19 -0.37000002,0.95 -0.17,2.01 -0.166,2.979 0.004,0.718 -0.27300002,1.345 -0.055,2.063 0.629,2.087 2.425,3.312 4.859,3.318 4.6179995,0.014 9.2379995,-0.139 13.8569995,-0.158 0.755,-0.004 1.171,-0.301 1.182,-1.033 0.012,-0.754 -0.423,-0.969 -1.183,-0.973 -1.778,-0.01 -5.824,-0.004 -6.04,-0.004 10e-4,-0.084 0.003,-0.586 10e-4,-0.67 z"
    },
    "TASK_TYPE_INSTANTIATING_SEND": {
      d: "m {mx},{my} l 0,8.4 l 12.6,0 l 0,-8.4 z l 6.3,3.6 l 6.3,-3.6"
    },
    "TASK_TYPE_SERVICE": {
      d: "m {mx},{my} v -1.71335 c 0.352326,-0.0705 0.703932,-0.17838 1.047628,-0.32133 0.344416,-0.14465 0.665822,-0.32133 0.966377,-0.52145 l 1.19431,1.18005 1.567487,-1.57688 -1.195028,-1.18014 c 0.403376,-0.61394 0.683079,-1.29908 0.825447,-2.01824 l 1.622133,-0.01 v -2.2196 l -1.636514,0.01 c -0.07333,-0.35153 -0.178319,-0.70024 -0.323564,-1.04372 -0.145244,-0.34406 -0.321407,-0.6644 -0.522735,-0.96217 l 1.131035,-1.13631 -1.583305,-1.56293 -1.129598,1.13589 c -0.614052,-0.40108 -1.302883,-0.68093 -2.022633,-0.82247 l 0.0093,-1.61852 h -2.241173 l 0.0042,1.63124 c -0.353763,0.0736 -0.705369,0.17977 -1.049785,0.32371 -0.344415,0.14437 -0.665102,0.32092 -0.9635006,0.52046 l -1.1698628,-1.15823 -1.5667691,1.5792 1.1684265,1.15669 c -0.4026573,0.61283 -0.68308,1.29797 -0.8247287,2.01713 l -1.6588041,0.003 v 2.22174 l 1.6724648,-0.006 c 0.073327,0.35077 0.1797598,0.70243 0.3242851,1.04472 0.1452428,0.34448 0.3214064,0.6644 0.5227339,0.96066 l -1.1993431,1.19723 1.5840256,1.56011 1.1964668,-1.19348 c 0.6140517,0.40346 1.3028827,0.68232 2.0233517,0.82331 l 7.19e-4,1.69892 h 2.226848 z m 0.221462,-3.9957 c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z"
    },
    "TASK_TYPE_SERVICE_FILL": {
      d: "m {mx},{my} c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z"
    },
    "TASK_TYPE_BUSINESS_RULE_HEADER": {
      d: "m {mx},{my} 0,4 20,0 0,-4 z"
    },
    "TASK_TYPE_BUSINESS_RULE_MAIN": {
      d: "m {mx},{my} 0,12 20,0 0,-12 zm 0,8 l 20,0 m -13,-4 l 0,8"
    },
    "MESSAGE_FLOW_MARKER": {
      d: "m {mx},{my} m -10.5 ,-7 l 0,14 l 21,0 l 0,-14 z l 10.5,6 l 10.5,-6"
    }
  };
  this.getRawPath = function getRawPath(pathId) {
    return this.pathMap[pathId].d;
  };
  this.getScaledPath = function getScaledPath(pathId, param) {
    var rawPath = this.pathMap[pathId];
    var mx, my;
    if (param.abspos) {
      mx = param.abspos.x;
      my = param.abspos.y;
    } else {
      mx = param.containerWidth * param.position.mx;
      my = param.containerHeight * param.position.my;
    }
    var coordinates = {};
    if (param.position) {
      var heightRatio = param.containerHeight / rawPath.height * param.yScaleFactor;
      var widthRatio = param.containerWidth / rawPath.width * param.xScaleFactor;
      for (var heightIndex = 0; heightIndex < rawPath.heightElements.length; heightIndex++) {
        coordinates["y" + heightIndex] = rawPath.heightElements[heightIndex] * heightRatio;
      }
      for (var widthIndex = 0; widthIndex < rawPath.widthElements.length; widthIndex++) {
        coordinates["x" + widthIndex] = rawPath.widthElements[widthIndex] * widthRatio;
      }
    }
    var path = format(
      rawPath.d,
      {
        mx,
        my,
        e: coordinates
      }
    );
    return path;
  };
}
var tokenRegex = /\{([^{}]+)\}/g, objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g;
function replacer(all2, key, obj) {
  var res = obj;
  key.replace(objNotationRegex, function(all3, name2, quote, quotedName, isFunc) {
    name2 = name2 || quotedName;
    if (res) {
      if (name2 in res) {
        res = res[name2];
      }
      typeof res == "function" && isFunc && (res = res());
    }
  });
  res = (res == null || res == obj ? all2 : res) + "";
  return res;
}
function format(str, obj) {
  return String(str).replace(tokenRegex, function(all2, key) {
    return replacer(all2, key, obj);
  });
}
const DrawModule = {
  __init__: ["bpmnRenderer"],
  bpmnRenderer: ["type", BpmnRenderer],
  textRenderer: ["type", TextRenderer],
  pathMap: ["type", PathMap]
};
function translate$1(template, replacements) {
  replacements = replacements || {};
  return template.replace(/{([^}]+)}/g, function(_2, key) {
    return replacements[key] || "{" + key + "}";
  });
}
const translate = {
  translate: ["value", translate$1]
};
function elementData(semantic, di, attrs) {
  return assign$1({
    id: semantic.id,
    type: semantic.$type,
    businessObject: semantic,
    di
  }, attrs);
}
function getWaypoints(di, source, target) {
  var waypoints = di.waypoint;
  if (!waypoints || waypoints.length < 2) {
    return [getMid(source), getMid(target)];
  }
  return waypoints.map(function(p2) {
    return { x: p2.x, y: p2.y };
  });
}
function notYetDrawn(translate2, semantic, refSemantic, property) {
  return new Error(translate2("element {element} referenced by {referenced}#{property} not yet drawn", {
    element: elementToString(refSemantic),
    referenced: elementToString(semantic),
    property
  }));
}
function BpmnImporter(eventBus, canvas, elementFactory, elementRegistry, translate2, textRenderer) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._elementFactory = elementFactory;
  this._elementRegistry = elementRegistry;
  this._translate = translate2;
  this._textRenderer = textRenderer;
}
BpmnImporter.$inject = [
  "eventBus",
  "canvas",
  "elementFactory",
  "elementRegistry",
  "translate",
  "textRenderer"
];
BpmnImporter.prototype.add = function(semantic, di, parentElement) {
  var element, translate2 = this._translate, hidden;
  var parentIndex;
  if (is$1(di, "bpmndi:BPMNPlane")) {
    var attrs = is$1(semantic, "bpmn:SubProcess") ? { id: semantic.id + "_plane" } : {};
    element = this._elementFactory.createRoot(elementData(semantic, di, attrs));
    this._canvas.addRootElement(element);
  } else if (is$1(di, "bpmndi:BPMNShape")) {
    var collapsed = !isExpanded(semantic, di), isFrame = isFrameElement(semantic);
    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);
    var bounds = di.bounds;
    element = this._elementFactory.createShape(elementData(semantic, di, {
      collapsed,
      hidden,
      x: Math.round(bounds.x),
      y: Math.round(bounds.y),
      width: Math.round(bounds.width),
      height: Math.round(bounds.height),
      isFrame
    }));
    if (is$1(semantic, "bpmn:BoundaryEvent")) {
      this._attachBoundary(semantic, element);
    }
    if (is$1(semantic, "bpmn:Lane")) {
      parentIndex = 0;
    }
    if (is$1(semantic, "bpmn:DataStoreReference")) {
      if (!isPointInsideBBox$1(parentElement, getMid(bounds))) {
        parentElement = this._canvas.findRoot(parentElement);
      }
    }
    this._canvas.addShape(element, parentElement, parentIndex);
  } else if (is$1(di, "bpmndi:BPMNEdge")) {
    var source = this._getSource(semantic), target = this._getTarget(semantic);
    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);
    element = this._elementFactory.createConnection(elementData(semantic, di, {
      hidden,
      source,
      target,
      waypoints: getWaypoints(di, source, target)
    }));
    if (is$1(semantic, "bpmn:DataAssociation")) {
      parentElement = this._canvas.findRoot(parentElement);
    }
    this._canvas.addConnection(element, parentElement, parentIndex);
  } else {
    throw new Error(translate2("unknown di {di} for element {semantic}", {
      di: elementToString(di),
      semantic: elementToString(semantic)
    }));
  }
  if (isLabelExternal(semantic) && getLabel(element)) {
    this.addLabel(semantic, di, element);
  }
  this._eventBus.fire("bpmnElement.added", { element });
  return element;
};
BpmnImporter.prototype._attachBoundary = function(boundarySemantic, boundaryElement) {
  var translate2 = this._translate;
  var hostSemantic = boundarySemantic.attachedToRef;
  if (!hostSemantic) {
    throw new Error(translate2("missing {semantic}#attachedToRef", {
      semantic: elementToString(boundarySemantic)
    }));
  }
  var host = this._elementRegistry.get(hostSemantic.id), attachers = host && host.attachers;
  if (!host) {
    throw notYetDrawn(translate2, boundarySemantic, hostSemantic, "attachedToRef");
  }
  boundaryElement.host = host;
  if (!attachers) {
    host.attachers = attachers = [];
  }
  if (attachers.indexOf(boundaryElement) === -1) {
    attachers.push(boundaryElement);
  }
};
BpmnImporter.prototype.addLabel = function(semantic, di, element) {
  var bounds, text, label;
  bounds = getExternalLabelBounds(di, element);
  text = getLabel(element);
  if (text) {
    bounds = this._textRenderer.getExternalLabelBounds(bounds, text);
  }
  label = this._elementFactory.createLabel(elementData(semantic, di, {
    id: semantic.id + "_label",
    labelTarget: element,
    type: "label",
    hidden: element.hidden || !getLabel(element),
    x: Math.round(bounds.x),
    y: Math.round(bounds.y),
    width: Math.round(bounds.width),
    height: Math.round(bounds.height)
  }));
  return this._canvas.addShape(label, element.parent);
};
BpmnImporter.prototype._getConnectedElement = function(semantic, side) {
  var element, refSemantic, type = semantic.$type, translate2 = this._translate;
  refSemantic = semantic[side + "Ref"];
  if (side === "source" && type === "bpmn:DataInputAssociation") {
    refSemantic = refSemantic && refSemantic[0];
  }
  if (side === "source" && type === "bpmn:DataOutputAssociation" || side === "target" && type === "bpmn:DataInputAssociation") {
    refSemantic = semantic.$parent;
  }
  element = refSemantic && this._getElement(refSemantic);
  if (element) {
    return element;
  }
  if (refSemantic) {
    throw notYetDrawn(translate2, semantic, refSemantic, side + "Ref");
  } else {
    throw new Error(translate2("{semantic}#{side} Ref not specified", {
      semantic: elementToString(semantic),
      side
    }));
  }
};
BpmnImporter.prototype._getSource = function(semantic) {
  return this._getConnectedElement(semantic, "source");
};
BpmnImporter.prototype._getTarget = function(semantic) {
  return this._getConnectedElement(semantic, "target");
};
BpmnImporter.prototype._getElement = function(semantic) {
  return this._elementRegistry.get(semantic.id);
};
function isPointInsideBBox$1(bbox, point) {
  var x2 = point.x, y2 = point.y;
  return x2 >= bbox.x && x2 <= bbox.x + bbox.width && y2 >= bbox.y && y2 <= bbox.y + bbox.height;
}
function isFrameElement(semantic) {
  return is$1(semantic, "bpmn:Group");
}
const ImportModule = {
  __depends__: [
    translate
  ],
  bpmnImporter: ["type", BpmnImporter]
};
const CoreModule = {
  __depends__: [
    DrawModule,
    ImportModule
  ]
};
function __stopPropagation(event2) {
  if (!event2 || typeof event2.stopPropagation !== "function") {
    return;
  }
  event2.stopPropagation();
}
function getOriginal$1(event2) {
  return event2.originalEvent || event2.srcEvent;
}
function stopPropagation$1(event2) {
  __stopPropagation(event2);
  __stopPropagation(getOriginal$1(event2));
}
function toPoint(event2) {
  if (event2.pointers && event2.pointers.length) {
    event2 = event2.pointers[0];
  }
  if (event2.touches && event2.touches.length) {
    event2 = event2.touches[0];
  }
  return event2 ? {
    x: event2.clientX,
    y: event2.clientY
  } : null;
}
function isMac() {
  return /mac/i.test(navigator.platform);
}
function isButton$1(event2, button) {
  return (getOriginal$1(event2) || event2).button === button;
}
function isPrimaryButton(event2) {
  return isButton$1(event2, 0);
}
function isAuxiliaryButton(event2) {
  return isButton$1(event2, 1);
}
function hasPrimaryModifier(event2) {
  var originalEvent = getOriginal$1(event2) || event2;
  if (!isPrimaryButton(event2)) {
    return false;
  }
  if (isMac()) {
    return originalEvent.metaKey;
  } else {
    return originalEvent.ctrlKey;
  }
}
function hasSecondaryModifier(event2) {
  var originalEvent = getOriginal$1(event2) || event2;
  return isPrimaryButton(event2) && originalEvent.shiftKey;
}
function allowAll(event2) {
  return true;
}
function allowPrimaryAndAuxiliary(event2) {
  return isPrimaryButton(event2) || isAuxiliaryButton(event2);
}
var LOW_PRIORITY$q = 500;
function InteractionEvents(eventBus, elementRegistry, styles) {
  var self2 = this;
  function fire(type, event2, element) {
    if (isIgnored(type, event2)) {
      return;
    }
    var target, gfx, returnValue;
    if (!element) {
      target = event2.delegateTarget || event2.target;
      if (target) {
        gfx = target;
        element = elementRegistry.get(gfx);
      }
    } else {
      gfx = elementRegistry.getGraphics(element);
    }
    if (!gfx || !element) {
      return;
    }
    returnValue = eventBus.fire(type, {
      element,
      gfx,
      originalEvent: event2
    });
    if (returnValue === false) {
      event2.stopPropagation();
      event2.preventDefault();
    }
  }
  var handlers = {};
  function mouseHandler(localEventName) {
    return handlers[localEventName];
  }
  function isIgnored(localEventName, event2) {
    var filter2 = ignoredFilters[localEventName] || isPrimaryButton;
    return !filter2(event2);
  }
  var bindings = {
    click: "element.click",
    contextmenu: "element.contextmenu",
    dblclick: "element.dblclick",
    mousedown: "element.mousedown",
    mousemove: "element.mousemove",
    mouseover: "element.hover",
    mouseout: "element.out",
    mouseup: "element.mouseup"
  };
  var ignoredFilters = {
    "element.contextmenu": allowAll,
    "element.mousedown": allowPrimaryAndAuxiliary,
    "element.mouseup": allowPrimaryAndAuxiliary,
    "element.click": allowPrimaryAndAuxiliary,
    "element.dblclick": allowPrimaryAndAuxiliary
  };
  function triggerMouseEvent(eventName, event2, targetElement) {
    var localEventName = bindings[eventName];
    if (!localEventName) {
      throw new Error("unmapped DOM event name <" + eventName + ">");
    }
    return fire(localEventName, event2, targetElement);
  }
  var ELEMENT_SELECTOR2 = "svg, .djs-element";
  function registerEvent(node2, event2, localEvent, ignoredFilter) {
    var handler = handlers[localEvent] = function(event3) {
      fire(localEvent, event3);
    };
    if (ignoredFilter) {
      ignoredFilters[localEvent] = ignoredFilter;
    }
    handler.$delegate = delegate.bind(node2, ELEMENT_SELECTOR2, event2, handler);
  }
  function unregisterEvent(node2, event2, localEvent) {
    var handler = mouseHandler(localEvent);
    if (!handler) {
      return;
    }
    delegate.unbind(node2, event2, handler.$delegate);
  }
  function registerEvents(svg) {
    forEach$1(bindings, function(val, key) {
      registerEvent(svg, key, val);
    });
  }
  function unregisterEvents(svg) {
    forEach$1(bindings, function(val, key) {
      unregisterEvent(svg, key, val);
    });
  }
  eventBus.on("canvas.destroy", function(event2) {
    unregisterEvents(event2.svg);
  });
  eventBus.on("canvas.init", function(event2) {
    registerEvents(event2.svg);
  });
  eventBus.on(["shape.added", "connection.added"], function(event2) {
    var element = event2.element, gfx = event2.gfx;
    eventBus.fire("interactionEvents.createHit", { element, gfx });
  });
  eventBus.on([
    "shape.changed",
    "connection.changed"
  ], LOW_PRIORITY$q, function(event2) {
    var element = event2.element, gfx = event2.gfx;
    eventBus.fire("interactionEvents.updateHit", { element, gfx });
  });
  eventBus.on("interactionEvents.createHit", LOW_PRIORITY$q, function(event2) {
    var element = event2.element, gfx = event2.gfx;
    self2.createDefaultHit(element, gfx);
  });
  eventBus.on("interactionEvents.updateHit", function(event2) {
    var element = event2.element, gfx = event2.gfx;
    self2.updateDefaultHit(element, gfx);
  });
  var STROKE_HIT_STYLE = createHitStyle("djs-hit djs-hit-stroke");
  var CLICK_STROKE_HIT_STYLE = createHitStyle("djs-hit djs-hit-click-stroke");
  var ALL_HIT_STYLE = createHitStyle("djs-hit djs-hit-all");
  var NO_MOVE_HIT_STYLE = createHitStyle("djs-hit djs-hit-no-move");
  var HIT_TYPES = {
    "all": ALL_HIT_STYLE,
    "click-stroke": CLICK_STROKE_HIT_STYLE,
    "stroke": STROKE_HIT_STYLE,
    "no-move": NO_MOVE_HIT_STYLE
  };
  function createHitStyle(classNames, attrs) {
    attrs = assign$1({
      stroke: "white",
      strokeWidth: 15
    }, attrs || {});
    return styles.cls(classNames, ["no-fill", "no-border"], attrs);
  }
  function applyStyle(hit, type) {
    var attrs = HIT_TYPES[type];
    if (!attrs) {
      throw new Error("invalid hit type <" + type + ">");
    }
    attr(hit, attrs);
    return hit;
  }
  function appendHit(gfx, hit) {
    append(gfx, hit);
  }
  this.removeHits = function(gfx) {
    var hits = all(".djs-hit", gfx);
    forEach$1(hits, remove$1);
  };
  this.createDefaultHit = function(element, gfx) {
    var waypoints = element.waypoints, isFrame = element.isFrame, boxType;
    if (waypoints) {
      return this.createWaypointsHit(gfx, waypoints);
    } else {
      boxType = isFrame ? "stroke" : "all";
      return this.createBoxHit(gfx, boxType, {
        width: element.width,
        height: element.height
      });
    }
  };
  this.createWaypointsHit = function(gfx, waypoints) {
    var hit = createLine(waypoints);
    applyStyle(hit, "stroke");
    appendHit(gfx, hit);
    return hit;
  };
  this.createBoxHit = function(gfx, type, attrs) {
    attrs = assign$1({
      x: 0,
      y: 0
    }, attrs);
    var hit = create$1("rect");
    applyStyle(hit, type);
    attr(hit, attrs);
    appendHit(gfx, hit);
    return hit;
  };
  this.updateDefaultHit = function(element, gfx) {
    var hit = query(".djs-hit", gfx);
    if (!hit) {
      return;
    }
    if (element.waypoints) {
      updateLine(hit, element.waypoints);
    } else {
      attr(hit, {
        width: element.width,
        height: element.height
      });
    }
    return hit;
  };
  this.fire = fire;
  this.triggerMouseEvent = triggerMouseEvent;
  this.mouseHandler = mouseHandler;
  this.registerEvent = registerEvent;
  this.unregisterEvent = unregisterEvent;
}
InteractionEvents.$inject = [
  "eventBus",
  "elementRegistry",
  "styles"
];
const InteractionEventsModule$1 = {
  __init__: ["interactionEvents"],
  interactionEvents: ["type", InteractionEvents]
};
var LOW_PRIORITY$p = 500;
var DEFAULT_PRIORITY$5 = 1e3;
function Outline(eventBus, styles) {
  this._eventBus = eventBus;
  this.offset = 5;
  var OUTLINE_STYLE = styles.cls("djs-outline", ["no-fill"]);
  var self2 = this;
  function createOutline(gfx) {
    var outline = create$1("rect");
    attr(outline, assign$1({
      x: 0,
      y: 0,
      rx: 4,
      width: 100,
      height: 100
    }, OUTLINE_STYLE));
    return outline;
  }
  eventBus.on(["shape.added", "shape.changed"], LOW_PRIORITY$p, function(event2) {
    var element = event2.element, gfx = event2.gfx;
    var outline = query(".djs-outline", gfx);
    if (!outline) {
      outline = self2.getOutline(element) || createOutline();
      append(gfx, outline);
    }
    self2.updateShapeOutline(outline, element);
  });
  eventBus.on(["connection.added", "connection.changed"], function(event2) {
    var element = event2.element, gfx = event2.gfx;
    var outline = query(".djs-outline", gfx);
    if (!outline) {
      outline = createOutline();
      append(gfx, outline);
    }
    self2.updateConnectionOutline(outline, element);
  });
}
Outline.prototype.updateShapeOutline = function(outline, element) {
  var updated = false;
  var providers = this._getProviders();
  if (providers.length) {
    forEach$1(providers, function(provider) {
      updated = updated || provider.updateOutline(element, outline);
    });
  }
  if (!updated) {
    attr(outline, {
      x: -this.offset,
      y: -this.offset,
      width: element.width + this.offset * 2,
      height: element.height + this.offset * 2
    });
  }
};
Outline.prototype.updateConnectionOutline = function(outline, connection) {
  var bbox = getBBox(connection);
  attr(outline, {
    x: bbox.x - this.offset,
    y: bbox.y - this.offset,
    width: bbox.width + this.offset * 2,
    height: bbox.height + this.offset * 2
  });
};
Outline.prototype.registerProvider = function(priority, provider) {
  if (!provider) {
    provider = priority;
    priority = DEFAULT_PRIORITY$5;
  }
  this._eventBus.on("outline.getProviders", priority, function(event2) {
    event2.providers.push(provider);
  });
};
Outline.prototype._getProviders = function() {
  var event2 = this._eventBus.createEvent({
    type: "outline.getProviders",
    providers: []
  });
  this._eventBus.fire(event2);
  return event2.providers;
};
Outline.prototype.getOutline = function(element) {
  var outline;
  var providers = this._getProviders();
  forEach$1(providers, function(provider) {
    if (!isFunction(provider.getOutline)) {
      return;
    }
    outline = outline || provider.getOutline(element);
  });
  return outline;
};
Outline.$inject = ["eventBus", "styles", "elementRegistry"];
const Ouline = {
  __init__: ["outline"],
  outline: ["type", Outline]
};
function Selection(eventBus, canvas) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._selectedElements = [];
  var self2 = this;
  eventBus.on(["shape.remove", "connection.remove"], function(e2) {
    var element = e2.element;
    self2.deselect(element);
  });
  eventBus.on(["diagram.clear", "root.set"], function(e2) {
    self2.select(null);
  });
}
Selection.$inject = ["eventBus", "canvas"];
Selection.prototype.deselect = function(element) {
  var selectedElements = this._selectedElements;
  var idx = selectedElements.indexOf(element);
  if (idx !== -1) {
    var oldSelection = selectedElements.slice();
    selectedElements.splice(idx, 1);
    this._eventBus.fire("selection.changed", { oldSelection, newSelection: selectedElements });
  }
};
Selection.prototype.get = function() {
  return this._selectedElements;
};
Selection.prototype.isSelected = function(element) {
  return this._selectedElements.indexOf(element) !== -1;
};
Selection.prototype.select = function(elements, add2) {
  var selectedElements = this._selectedElements, oldSelection = selectedElements.slice();
  if (!isArray$3(elements)) {
    elements = elements ? [elements] : [];
  }
  var canvas = this._canvas;
  var rootElement = canvas.getRootElement();
  elements = elements.filter(function(element) {
    var elementRoot = canvas.findRoot(element);
    return rootElement === elementRoot;
  });
  if (add2) {
    forEach$1(elements, function(element) {
      if (selectedElements.indexOf(element) !== -1) {
        return;
      } else {
        selectedElements.push(element);
      }
    });
  } else {
    this._selectedElements = selectedElements = elements.slice();
  }
  this._eventBus.fire("selection.changed", { oldSelection, newSelection: selectedElements });
};
var MARKER_HOVER = "hover", MARKER_SELECTED = "selected";
var SELECTION_OUTLINE_PADDING = 6;
function SelectionVisuals(canvas, eventBus, selection) {
  this._canvas = canvas;
  var self2 = this;
  this._multiSelectionBox = null;
  function addMarker(e2, cls) {
    canvas.addMarker(e2, cls);
  }
  function removeMarker(e2, cls) {
    canvas.removeMarker(e2, cls);
  }
  eventBus.on("element.hover", function(event2) {
    addMarker(event2.element, MARKER_HOVER);
  });
  eventBus.on("element.out", function(event2) {
    removeMarker(event2.element, MARKER_HOVER);
  });
  eventBus.on("selection.changed", function(event2) {
    function deselect(s2) {
      removeMarker(s2, MARKER_SELECTED);
    }
    function select(s2) {
      addMarker(s2, MARKER_SELECTED);
    }
    var oldSelection = event2.oldSelection, newSelection = event2.newSelection;
    forEach$1(oldSelection, function(e2) {
      if (newSelection.indexOf(e2) === -1) {
        deselect(e2);
      }
    });
    forEach$1(newSelection, function(e2) {
      if (oldSelection.indexOf(e2) === -1) {
        select(e2);
      }
    });
    self2._updateSelectionOutline(newSelection);
  });
  eventBus.on("element.changed", function(event2) {
    if (selection.isSelected(event2.element)) {
      self2._updateSelectionOutline(selection.get());
    }
  });
}
SelectionVisuals.$inject = [
  "canvas",
  "eventBus",
  "selection"
];
SelectionVisuals.prototype._updateSelectionOutline = function(selection) {
  var layer = this._canvas.getLayer("selectionOutline");
  clear(layer);
  var enabled = selection.length > 1;
  var container = this._canvas.getContainer();
  classes(container)[enabled ? "add" : "remove"]("djs-multi-select");
  if (!enabled) {
    return;
  }
  var bBox = addSelectionOutlinePadding(getBBox(selection));
  var rect = create$1("rect");
  attr(rect, assign$1({
    rx: 3
  }, bBox));
  classes(rect).add("djs-selection-outline");
  append(layer, rect);
};
function addSelectionOutlinePadding(bBox) {
  return {
    x: bBox.x - SELECTION_OUTLINE_PADDING,
    y: bBox.y - SELECTION_OUTLINE_PADDING,
    width: bBox.width + SELECTION_OUTLINE_PADDING * 2,
    height: bBox.height + SELECTION_OUTLINE_PADDING * 2
  };
}
function SelectionBehavior(eventBus, selection, canvas, elementRegistry) {
  eventBus.on("create.end", 500, function(event2) {
    var context = event2.context, canExecute = context.canExecute, elements = context.elements, hints = context.hints || {}, autoSelect = hints.autoSelect;
    if (canExecute) {
      if (autoSelect === false) {
        return;
      }
      if (isArray$3(autoSelect)) {
        selection.select(autoSelect);
      } else {
        selection.select(elements.filter(isShown));
      }
    }
  });
  eventBus.on("connect.end", 500, function(event2) {
    var context = event2.context, connection = context.connection;
    if (connection) {
      selection.select(connection);
    }
  });
  eventBus.on("shape.move.end", 500, function(event2) {
    var previousSelection = event2.previousSelection || [];
    var shape = elementRegistry.get(event2.context.shape.id);
    var isSelected = find(previousSelection, function(selectedShape) {
      return shape.id === selectedShape.id;
    });
    if (!isSelected) {
      selection.select(shape);
    }
  });
  eventBus.on("element.click", function(event2) {
    if (!isPrimaryButton(event2)) {
      return;
    }
    var element = event2.element;
    if (element === canvas.getRootElement()) {
      element = null;
    }
    var isSelected = selection.isSelected(element), isMultiSelect = selection.get().length > 1;
    var add2 = hasSecondaryModifier(event2);
    if (isSelected && isMultiSelect) {
      if (add2) {
        return selection.deselect(element);
      } else {
        return selection.select(element);
      }
    } else if (!isSelected) {
      selection.select(element, add2);
    } else {
      selection.deselect(element);
    }
  });
}
SelectionBehavior.$inject = [
  "eventBus",
  "selection",
  "canvas",
  "elementRegistry"
];
function isShown(element) {
  return !element.hidden;
}
const SelectionModule = {
  __init__: ["selectionVisuals", "selectionBehavior"],
  __depends__: [
    InteractionEventsModule$1,
    Ouline
  ],
  selection: ["type", Selection],
  selectionVisuals: ["type", SelectionVisuals],
  selectionBehavior: ["type", SelectionBehavior]
};
function IdGenerator(prefix2) {
  this._counter = 0;
  this._prefix = (prefix2 ? prefix2 + "-" : "") + Math.floor(Math.random() * 1e9) + "-";
}
IdGenerator.prototype.next = function() {
  return this._prefix + ++this._counter;
};
var ids$1 = new IdGenerator("ov");
var LOW_PRIORITY$o = 500;
function Overlays(config, eventBus, canvas, elementRegistry) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._elementRegistry = elementRegistry;
  this._ids = ids$1;
  this._overlayDefaults = assign$1({
    // no show constraints
    show: null,
    // always scale
    scale: true
  }, config && config.defaults);
  this._overlays = {};
  this._overlayContainers = [];
  this._overlayRoot = createRoot$1(canvas.getContainer());
  this._init();
}
Overlays.$inject = [
  "config.overlays",
  "eventBus",
  "canvas",
  "elementRegistry"
];
Overlays.prototype.get = function(search) {
  if (isString(search)) {
    search = { id: search };
  }
  if (isString(search.element)) {
    search.element = this._elementRegistry.get(search.element);
  }
  if (search.element) {
    var container = this._getOverlayContainer(search.element, true);
    if (container) {
      return search.type ? filter(container.overlays, matchPattern({ type: search.type })) : container.overlays.slice();
    } else {
      return [];
    }
  } else if (search.type) {
    return filter(this._overlays, matchPattern({ type: search.type }));
  } else {
    return search.id ? this._overlays[search.id] : null;
  }
};
Overlays.prototype.add = function(element, type, overlay) {
  if (isObject(type)) {
    overlay = type;
    type = null;
  }
  if (!element.id) {
    element = this._elementRegistry.get(element);
  }
  if (!overlay.position) {
    throw new Error("must specifiy overlay position");
  }
  if (!overlay.html) {
    throw new Error("must specifiy overlay html");
  }
  if (!element) {
    throw new Error("invalid element specified");
  }
  var id = this._ids.next();
  overlay = assign$1({}, this._overlayDefaults, overlay, {
    id,
    type,
    element,
    html: overlay.html
  });
  this._addOverlay(overlay);
  return id;
};
Overlays.prototype.remove = function(filter2) {
  var overlays = this.get(filter2) || [];
  if (!isArray$3(overlays)) {
    overlays = [overlays];
  }
  var self2 = this;
  forEach$1(overlays, function(overlay) {
    var container = self2._getOverlayContainer(overlay.element, true);
    if (overlay) {
      remove$2(overlay.html);
      remove$2(overlay.htmlContainer);
      delete overlay.htmlContainer;
      delete overlay.element;
      delete self2._overlays[overlay.id];
    }
    if (container) {
      var idx = container.overlays.indexOf(overlay);
      if (idx !== -1) {
        container.overlays.splice(idx, 1);
      }
    }
  });
};
Overlays.prototype.isShown = function() {
  return this._overlayRoot.style.display !== "none";
};
Overlays.prototype.show = function() {
  setVisible$1(this._overlayRoot);
};
Overlays.prototype.hide = function() {
  setVisible$1(this._overlayRoot, false);
};
Overlays.prototype.clear = function() {
  this._overlays = {};
  this._overlayContainers = [];
  clear$1(this._overlayRoot);
};
Overlays.prototype._updateOverlayContainer = function(container) {
  var element = container.element, html = container.html;
  var x2 = element.x, y2 = element.y;
  if (element.waypoints) {
    var bbox = getBBox(element);
    x2 = bbox.x;
    y2 = bbox.y;
  }
  setPosition$1(html, x2, y2);
  attr$1(container.html, "data-container-id", element.id);
};
Overlays.prototype._updateOverlay = function(overlay) {
  var position = overlay.position, htmlContainer = overlay.htmlContainer, element = overlay.element;
  var left = position.left, top = position.top;
  if (position.right !== void 0) {
    var width;
    if (element.waypoints) {
      width = getBBox(element).width;
    } else {
      width = element.width;
    }
    left = position.right * -1 + width;
  }
  if (position.bottom !== void 0) {
    var height;
    if (element.waypoints) {
      height = getBBox(element).height;
    } else {
      height = element.height;
    }
    top = position.bottom * -1 + height;
  }
  setPosition$1(htmlContainer, left || 0, top || 0);
  this._updateOverlayVisibilty(overlay, this._canvas.viewbox());
};
Overlays.prototype._createOverlayContainer = function(element) {
  var html = domify$1('<div class="djs-overlays" />');
  assign(html, { position: "absolute" });
  this._overlayRoot.appendChild(html);
  var container = {
    html,
    element,
    overlays: []
  };
  this._updateOverlayContainer(container);
  this._overlayContainers.push(container);
  return container;
};
Overlays.prototype._updateRoot = function(viewbox) {
  var scale = viewbox.scale || 1;
  var matrix = "matrix(" + [
    scale,
    0,
    0,
    scale,
    -1 * viewbox.x * scale,
    -1 * viewbox.y * scale
  ].join(",") + ")";
  setTransform(this._overlayRoot, matrix);
};
Overlays.prototype._getOverlayContainer = function(element, raw) {
  var container = find(this._overlayContainers, function(c2) {
    return c2.element === element;
  });
  if (!container && !raw) {
    return this._createOverlayContainer(element);
  }
  return container;
};
Overlays.prototype._addOverlay = function(overlay) {
  var id = overlay.id, element = overlay.element, html = overlay.html, htmlContainer, overlayContainer;
  if (html.get && html.constructor.prototype.jquery) {
    html = html.get(0);
  }
  if (isString(html)) {
    html = domify$1(html);
  }
  overlayContainer = this._getOverlayContainer(element);
  htmlContainer = domify$1('<div class="djs-overlay" data-overlay-id="' + id + '">');
  assign(htmlContainer, { position: "absolute" });
  htmlContainer.appendChild(html);
  if (overlay.type) {
    classes$1(htmlContainer).add("djs-overlay-" + overlay.type);
  }
  var elementRoot = this._canvas.findRoot(element);
  var activeRoot = this._canvas.getRootElement();
  setVisible$1(htmlContainer, elementRoot === activeRoot);
  overlay.htmlContainer = htmlContainer;
  overlayContainer.overlays.push(overlay);
  overlayContainer.html.appendChild(htmlContainer);
  this._overlays[id] = overlay;
  this._updateOverlay(overlay);
  this._updateOverlayVisibilty(overlay, this._canvas.viewbox());
};
Overlays.prototype._updateOverlayVisibilty = function(overlay, viewbox) {
  var show = overlay.show, rootElement = this._canvas.findRoot(overlay.element), minZoom = show && show.minZoom, maxZoom = show && show.maxZoom, htmlContainer = overlay.htmlContainer, activeRootElement = this._canvas.getRootElement(), visible = true;
  if (rootElement !== activeRootElement) {
    visible = false;
  } else if (show) {
    if (isDefined(minZoom) && minZoom > viewbox.scale || isDefined(maxZoom) && maxZoom < viewbox.scale) {
      visible = false;
    }
  }
  setVisible$1(htmlContainer, visible);
  this._updateOverlayScale(overlay, viewbox);
};
Overlays.prototype._updateOverlayScale = function(overlay, viewbox) {
  var shouldScale = overlay.scale, minScale, maxScale, htmlContainer = overlay.htmlContainer;
  var scale, transform2 = "";
  if (shouldScale !== true) {
    if (shouldScale === false) {
      minScale = 1;
      maxScale = 1;
    } else {
      minScale = shouldScale.min;
      maxScale = shouldScale.max;
    }
    if (isDefined(minScale) && viewbox.scale < minScale) {
      scale = (1 / viewbox.scale || 1) * minScale;
    }
    if (isDefined(maxScale) && viewbox.scale > maxScale) {
      scale = (1 / viewbox.scale || 1) * maxScale;
    }
  }
  if (isDefined(scale)) {
    transform2 = "scale(" + scale + "," + scale + ")";
  }
  setTransform(htmlContainer, transform2);
};
Overlays.prototype._updateOverlaysVisibilty = function(viewbox) {
  var self2 = this;
  forEach$1(this._overlays, function(overlay) {
    self2._updateOverlayVisibilty(overlay, viewbox);
  });
};
Overlays.prototype._init = function() {
  var eventBus = this._eventBus;
  var self2 = this;
  function updateViewbox(viewbox) {
    self2._updateRoot(viewbox);
    self2._updateOverlaysVisibilty(viewbox);
    self2.show();
  }
  eventBus.on("canvas.viewbox.changing", function(event2) {
    self2.hide();
  });
  eventBus.on("canvas.viewbox.changed", function(event2) {
    updateViewbox(event2.viewbox);
  });
  eventBus.on(["shape.remove", "connection.remove"], function(e2) {
    var element = e2.element;
    var overlays = self2.get({ element });
    forEach$1(overlays, function(o2) {
      self2.remove(o2.id);
    });
    var container = self2._getOverlayContainer(element);
    if (container) {
      remove$2(container.html);
      var i2 = self2._overlayContainers.indexOf(container);
      if (i2 !== -1) {
        self2._overlayContainers.splice(i2, 1);
      }
    }
  });
  eventBus.on("element.changed", LOW_PRIORITY$o, function(e2) {
    var element = e2.element;
    var container = self2._getOverlayContainer(element, true);
    if (container) {
      forEach$1(container.overlays, function(overlay) {
        self2._updateOverlay(overlay);
      });
      self2._updateOverlayContainer(container);
    }
  });
  eventBus.on("element.marker.update", function(e2) {
    var container = self2._getOverlayContainer(e2.element, true);
    if (container) {
      classes$1(container.html)[e2.add ? "add" : "remove"](e2.marker);
    }
  });
  eventBus.on("root.set", function() {
    self2._updateOverlaysVisibilty(self2._canvas.viewbox());
  });
  eventBus.on("diagram.clear", this.clear, this);
};
function createRoot$1(parentNode) {
  var root = domify$1(
    '<div class="djs-overlay-container" />'
  );
  assign(root, {
    position: "absolute",
    width: 0,
    height: 0
  });
  parentNode.insertBefore(root, parentNode.firstChild);
  return root;
}
function setPosition$1(el, x2, y2) {
  assign(el, { left: x2 + "px", top: y2 + "px" });
}
function setVisible$1(el, visible) {
  el.style.display = visible === false ? "none" : "";
}
function setTransform(el, transform2) {
  el.style["transform-origin"] = "top left";
  ["", "-ms-", "-webkit-"].forEach(function(prefix2) {
    el.style[prefix2 + "transform"] = transform2;
  });
}
const OverlaysModule = {
  __init__: ["overlays"],
  overlays: ["type", Overlays]
};
function ChangeSupport(eventBus, canvas, elementRegistry, graphicsFactory) {
  eventBus.on("element.changed", function(event2) {
    var element = event2.element;
    if (element.parent || element === canvas.getRootElement()) {
      event2.gfx = elementRegistry.getGraphics(element);
    }
    if (!event2.gfx) {
      return;
    }
    eventBus.fire(getType(element) + ".changed", event2);
  });
  eventBus.on("elements.changed", function(event2) {
    var elements = event2.elements;
    elements.forEach(function(e2) {
      eventBus.fire("element.changed", { element: e2 });
    });
    graphicsFactory.updateContainments(elements);
  });
  eventBus.on("shape.changed", function(event2) {
    graphicsFactory.update("shape", event2.element, event2.gfx);
  });
  eventBus.on("connection.changed", function(event2) {
    graphicsFactory.update("connection", event2.element, event2.gfx);
  });
}
ChangeSupport.$inject = [
  "eventBus",
  "canvas",
  "elementRegistry",
  "graphicsFactory"
];
const ChangeSupportModule = {
  __init__: ["changeSupport"],
  changeSupport: ["type", ChangeSupport]
};
var DEFAULT_PRIORITY$4 = 1e3;
function CommandInterceptor(eventBus) {
  this._eventBus = eventBus;
}
CommandInterceptor.$inject = ["eventBus"];
function unwrapEvent(fn, that) {
  return function(event2) {
    return fn.call(that || null, event2.context, event2.command, event2);
  };
}
CommandInterceptor.prototype.on = function(events, hook, priority, handlerFn, unwrap, that) {
  if (isFunction(hook) || isNumber(hook)) {
    that = unwrap;
    unwrap = handlerFn;
    handlerFn = priority;
    priority = hook;
    hook = null;
  }
  if (isFunction(priority)) {
    that = unwrap;
    unwrap = handlerFn;
    handlerFn = priority;
    priority = DEFAULT_PRIORITY$4;
  }
  if (isObject(unwrap)) {
    that = unwrap;
    unwrap = false;
  }
  if (!isFunction(handlerFn)) {
    throw new Error("handlerFn must be a function");
  }
  if (!isArray$3(events)) {
    events = [events];
  }
  var eventBus = this._eventBus;
  forEach$1(events, function(event2) {
    var fullEvent = ["commandStack", event2, hook].filter(function(e2) {
      return e2;
    }).join(".");
    eventBus.on(fullEvent, priority, unwrap ? unwrapEvent(handlerFn, that) : handlerFn, that);
  });
};
CommandInterceptor.prototype.canExecute = createHook("canExecute");
CommandInterceptor.prototype.preExecute = createHook("preExecute");
CommandInterceptor.prototype.preExecuted = createHook("preExecuted");
CommandInterceptor.prototype.execute = createHook("execute");
CommandInterceptor.prototype.executed = createHook("executed");
CommandInterceptor.prototype.postExecute = createHook("postExecute");
CommandInterceptor.prototype.postExecuted = createHook("postExecuted");
CommandInterceptor.prototype.revert = createHook("revert");
CommandInterceptor.prototype.reverted = createHook("reverted");
function createHook(hook) {
  const hookFn = function(events, priority, handlerFn, unwrap, that) {
    if (isFunction(events) || isNumber(events)) {
      that = unwrap;
      unwrap = handlerFn;
      handlerFn = priority;
      priority = events;
      events = null;
    }
    this.on(events, hook, priority, handlerFn, unwrap, that);
  };
  return hookFn;
}
function RootElementsBehavior(canvas, injector) {
  injector.invoke(CommandInterceptor, this);
  this.executed(function(event2) {
    var context = event2.context;
    if (context.rootElement) {
      canvas.setRootElement(context.rootElement);
    } else {
      context.rootElement = canvas.getRootElement();
    }
  });
  this.revert(function(event2) {
    var context = event2.context;
    if (context.rootElement) {
      canvas.setRootElement(context.rootElement);
    }
  });
}
e$3(RootElementsBehavior, CommandInterceptor);
RootElementsBehavior.$inject = ["canvas", "injector"];
const RootElementsModule = {
  __init__: ["rootElementsBehavior"],
  rootElementsBehavior: ["type", RootElementsBehavior]
};
function escapeCSS(str) {
  return CSS.escape(str);
}
var HTML_ESCAPE_MAP = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function escapeHTML(str) {
  str = "" + str;
  return str && str.replace(/[&<>"']/g, function(match) {
    return HTML_ESCAPE_MAP[match];
  });
}
var planeSuffix = "_plane";
function getShapeIdFromPlane(element) {
  var id = element.id;
  return removePlaneSuffix(id);
}
function getPlaneIdFromShape(element) {
  var id = element.id;
  if (is$1(element, "bpmn:SubProcess")) {
    return addPlaneSuffix(id);
  }
  return id;
}
function toPlaneId(id) {
  return addPlaneSuffix(id);
}
function isPlane(element) {
  var di = getDi(element);
  return is$1(di, "bpmndi:BPMNPlane");
}
function addPlaneSuffix(id) {
  return id + planeSuffix;
}
function removePlaneSuffix(id) {
  return id.replace(new RegExp(planeSuffix + "$"), "");
}
var OPEN_CLASS = "bjs-breadcrumbs-shown";
function DrilldownBreadcrumbs(eventBus, elementRegistry, canvas) {
  var breadcrumbs = domify$1('<ul class="bjs-breadcrumbs"></ul>');
  var container = canvas.getContainer();
  var containerClasses = classes$1(container);
  container.appendChild(breadcrumbs);
  var businessObjectParents = [];
  eventBus.on("element.changed", function(event2) {
    var shape = event2.element, businessObject = getBusinessObject(shape);
    var isPresent = find(businessObjectParents, function(element) {
      return element === businessObject;
    });
    if (!isPresent) {
      return;
    }
    updateBreadcrumbs();
  });
  function updateBreadcrumbs(element) {
    if (element) {
      businessObjectParents = getBusinessObjectParentChain(element);
    }
    var path = businessObjectParents.map(function(parent) {
      var title = escapeHTML(parent.name || parent.id);
      var link = domify$1('<li><span class="bjs-crumb"><a title="' + title + '">' + title + "</a></span></li>");
      var parentPlane = canvas.findRoot(getPlaneIdFromShape(parent)) || canvas.findRoot(parent.id);
      if (!parentPlane && is$1(parent, "bpmn:Process")) {
        var participant = elementRegistry.find(function(element2) {
          var businessObject = getBusinessObject(element2);
          return businessObject && businessObject.get("processRef") && businessObject.get("processRef") === parent;
        });
        parentPlane = canvas.findRoot(participant.id);
      }
      link.addEventListener("click", function() {
        canvas.setRootElement(parentPlane);
      });
      return link;
    });
    breadcrumbs.innerHTML = "";
    var visible = path.length > 1;
    containerClasses.toggle(OPEN_CLASS, visible);
    path.forEach(function(element2) {
      breadcrumbs.appendChild(element2);
    });
  }
  eventBus.on("root.set", function(event2) {
    updateBreadcrumbs(event2.element);
  });
}
DrilldownBreadcrumbs.$inject = ["eventBus", "elementRegistry", "canvas"];
function getBusinessObjectParentChain(child) {
  var businessObject = getBusinessObject(child);
  var parents = [];
  for (var element = businessObject; element; element = element.$parent) {
    if (is$1(element, "bpmn:SubProcess") || is$1(element, "bpmn:Process")) {
      parents.push(element);
    }
  }
  return parents.reverse();
}
function DrilldownCentering(eventBus, canvas) {
  var currentRoot = null;
  var positionMap = new Map$1();
  eventBus.on("root.set", function(event2) {
    var newRoot = event2.element;
    var currentViewbox = canvas.viewbox();
    var storedViewbox = positionMap.get(newRoot);
    positionMap.set(currentRoot, {
      x: currentViewbox.x,
      y: currentViewbox.y,
      zoom: currentViewbox.scale
    });
    currentRoot = newRoot;
    if (is$1(newRoot, "bpmn:Collaboration") && !storedViewbox) {
      return;
    }
    storedViewbox = storedViewbox || { x: 0, y: 0, zoom: 1 };
    var dx = (currentViewbox.x - storedViewbox.x) * currentViewbox.scale, dy = (currentViewbox.y - storedViewbox.y) * currentViewbox.scale;
    if (dx !== 0 || dy !== 0) {
      canvas.scroll({
        dx,
        dy
      });
    }
    if (storedViewbox.zoom !== currentViewbox.scale) {
      canvas.zoom(storedViewbox.zoom, { x: 0, y: 0 });
    }
  });
  eventBus.on("diagram.clear", function() {
    positionMap.clear();
    currentRoot = null;
  });
}
DrilldownCentering.$inject = ["eventBus", "canvas"];
function Map$1() {
  this._entries = [];
  this.set = function(key, value) {
    var found = false;
    for (var k2 in this._entries) {
      if (this._entries[k2][0] === key) {
        this._entries[k2][1] = value;
        found = true;
        break;
      }
    }
    if (!found) {
      this._entries.push([key, value]);
    }
  };
  this.get = function(key) {
    for (var k2 in this._entries) {
      if (this._entries[k2][0] === key) {
        return this._entries[k2][1];
      }
    }
    return null;
  };
  this.clear = function() {
    this._entries.length = 0;
  };
  this.remove = function(key) {
    var idx = -1;
    for (var k2 in this._entries) {
      if (this._entries[k2][0] === key) {
        idx = k2;
        break;
      }
    }
    if (idx !== -1) {
      this._entries.splice(idx, 1);
    }
  };
}
var DEFAULT_POSITION$1 = {
  x: 180,
  y: 160
};
function SubprocessCompatibility(eventBus, moddle) {
  this._eventBus = eventBus;
  this._moddle = moddle;
  var self2 = this;
  eventBus.on("import.render.start", 1500, function(e2, context) {
    self2._handleImport(context.definitions);
  });
}
SubprocessCompatibility.prototype._handleImport = function(definitions) {
  if (!definitions.diagrams) {
    return;
  }
  var self2 = this;
  this._definitions = definitions;
  this._processToDiagramMap = {};
  definitions.diagrams.forEach(function(diagram) {
    if (!diagram.plane || !diagram.plane.bpmnElement) {
      return;
    }
    self2._processToDiagramMap[diagram.plane.bpmnElement.id] = diagram;
  });
  var newDiagrams = [];
  definitions.diagrams.forEach(function(diagram) {
    var createdDiagrams = self2._createNewDiagrams(diagram.plane);
    Array.prototype.push.apply(newDiagrams, createdDiagrams);
  });
  newDiagrams.forEach(function(diagram) {
    self2._movePlaneElementsToOrigin(diagram.plane);
  });
};
SubprocessCompatibility.prototype._createNewDiagrams = function(plane) {
  var self2 = this;
  var collapsedElements = [];
  var elementsToMove = [];
  plane.get("planeElement").forEach(function(diElement) {
    var businessObject = diElement.bpmnElement;
    if (!businessObject) {
      return;
    }
    var parent = businessObject.$parent;
    if (is$1(businessObject, "bpmn:SubProcess") && !diElement.isExpanded) {
      collapsedElements.push(businessObject);
    }
    if (shouldMoveToPlane(businessObject, plane)) {
      elementsToMove.push({ diElement, parent });
    }
  });
  var newDiagrams = [];
  collapsedElements.forEach(function(element) {
    if (!self2._processToDiagramMap[element.id]) {
      var diagram = self2._createDiagram(element);
      self2._processToDiagramMap[element.id] = diagram;
      newDiagrams.push(diagram);
    }
  });
  elementsToMove.forEach(function(element) {
    var diElement = element.diElement;
    var parent = element.parent;
    while (parent && collapsedElements.indexOf(parent) === -1) {
      parent = parent.$parent;
    }
    if (!parent) {
      return;
    }
    var diagram = self2._processToDiagramMap[parent.id];
    self2._moveToDiPlane(diElement, diagram.plane);
  });
  return newDiagrams;
};
SubprocessCompatibility.prototype._movePlaneElementsToOrigin = function(plane) {
  var elements = plane.get("planeElement");
  var planeBounds = getPlaneBounds(plane);
  var offset = {
    x: planeBounds.x - DEFAULT_POSITION$1.x,
    y: planeBounds.y - DEFAULT_POSITION$1.y
  };
  elements.forEach(function(diElement) {
    if (diElement.waypoint) {
      diElement.waypoint.forEach(function(waypoint) {
        waypoint.x = waypoint.x - offset.x;
        waypoint.y = waypoint.y - offset.y;
      });
    } else if (diElement.bounds) {
      diElement.bounds.x = diElement.bounds.x - offset.x;
      diElement.bounds.y = diElement.bounds.y - offset.y;
    }
  });
};
SubprocessCompatibility.prototype._moveToDiPlane = function(diElement, newPlane) {
  var containingDiagram = findRootDiagram(diElement);
  var parentPlaneElement = containingDiagram.plane.get("planeElement");
  parentPlaneElement.splice(parentPlaneElement.indexOf(diElement), 1);
  newPlane.get("planeElement").push(diElement);
};
SubprocessCompatibility.prototype._createDiagram = function(businessObject) {
  var plane = this._moddle.create("bpmndi:BPMNPlane", {
    bpmnElement: businessObject
  });
  var diagram = this._moddle.create("bpmndi:BPMNDiagram", {
    plane
  });
  plane.$parent = diagram;
  plane.bpmnElement = businessObject;
  diagram.$parent = this._definitions;
  this._definitions.diagrams.push(diagram);
  return diagram;
};
SubprocessCompatibility.$inject = ["eventBus", "moddle"];
function findRootDiagram(element) {
  if (is$1(element, "bpmndi:BPMNDiagram")) {
    return element;
  } else {
    return findRootDiagram(element.$parent);
  }
}
function getPlaneBounds(plane) {
  var planeTrbl = {
    top: Infinity,
    right: -Infinity,
    bottom: -Infinity,
    left: Infinity
  };
  plane.planeElement.forEach(function(element) {
    if (!element.bounds) {
      return;
    }
    var trbl = asTRBL(element.bounds);
    planeTrbl.top = Math.min(trbl.top, planeTrbl.top);
    planeTrbl.left = Math.min(trbl.left, planeTrbl.left);
  });
  return asBounds(planeTrbl);
}
function shouldMoveToPlane(businessObject, plane) {
  var parent = businessObject.$parent;
  if (!is$1(parent, "bpmn:SubProcess") || parent === plane.bpmnElement) {
    return false;
  }
  if (isAny(businessObject, ["bpmn:DataInputAssociation", "bpmn:DataOutputAssociation"])) {
    return false;
  }
  return true;
}
var LOW_PRIORITY$n = 250;
var ARROW_DOWN_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4.81801948,3.50735931 L10.4996894,9.1896894 L10.5,4 L12,4 L12,12 L4,12 L4,10.5 L9.6896894,10.4996894 L3.75735931,4.56801948 C3.46446609,4.27512627 3.46446609,3.80025253 3.75735931,3.50735931 C4.05025253,3.21446609 4.52512627,3.21446609 4.81801948,3.50735931 Z"/></svg>';
var EMPTY_MARKER = "bjs-drilldown-empty";
function DrilldownOverlayBehavior(canvas, eventBus, elementRegistry, overlays) {
  CommandInterceptor.call(this, eventBus);
  this._canvas = canvas;
  this._eventBus = eventBus;
  this._elementRegistry = elementRegistry;
  this._overlays = overlays;
  var self2 = this;
  this.executed("shape.toggleCollapse", LOW_PRIORITY$n, function(context) {
    var shape = context.shape;
    if (self2._canDrillDown(shape)) {
      self2._addOverlay(shape);
    } else {
      self2._removeOverlay(shape);
    }
  }, true);
  this.reverted("shape.toggleCollapse", LOW_PRIORITY$n, function(context) {
    var shape = context.shape;
    if (self2._canDrillDown(shape)) {
      self2._addOverlay(shape);
    } else {
      self2._removeOverlay(shape);
    }
  }, true);
  this.executed(
    ["shape.create", "shape.move", "shape.delete"],
    LOW_PRIORITY$n,
    function(context) {
      var oldParent = context.oldParent, newParent = context.newParent || context.parent, shape = context.shape;
      if (self2._canDrillDown(shape)) {
        self2._addOverlay(shape);
      }
      self2._updateDrilldownOverlay(oldParent);
      self2._updateDrilldownOverlay(newParent);
      self2._updateDrilldownOverlay(shape);
    },
    true
  );
  this.reverted(
    ["shape.create", "shape.move", "shape.delete"],
    LOW_PRIORITY$n,
    function(context) {
      var oldParent = context.oldParent, newParent = context.newParent || context.parent, shape = context.shape;
      if (self2._canDrillDown(shape)) {
        self2._addOverlay(shape);
      }
      self2._updateDrilldownOverlay(oldParent);
      self2._updateDrilldownOverlay(newParent);
      self2._updateDrilldownOverlay(shape);
    },
    true
  );
  eventBus.on("import.render.complete", function() {
    elementRegistry.filter(function(e2) {
      return self2._canDrillDown(e2);
    }).map(function(el) {
      self2._addOverlay(el);
    });
  });
}
e$3(DrilldownOverlayBehavior, CommandInterceptor);
DrilldownOverlayBehavior.prototype._updateDrilldownOverlay = function(shape) {
  var canvas = this._canvas;
  if (!shape) {
    return;
  }
  var root = canvas.findRoot(shape);
  if (root) {
    this._updateOverlayVisibility(root);
  }
};
DrilldownOverlayBehavior.prototype._canDrillDown = function(element) {
  var canvas = this._canvas;
  return is$1(element, "bpmn:SubProcess") && canvas.findRoot(getPlaneIdFromShape(element));
};
DrilldownOverlayBehavior.prototype._updateOverlayVisibility = function(element) {
  var overlays = this._overlays;
  var businessObject = getBusinessObject(element);
  var overlay = overlays.get({ element: businessObject.id, type: "drilldown" })[0];
  if (!overlay) {
    return;
  }
  var hasFlowElements = businessObject && businessObject.get("flowElements") && businessObject.get("flowElements").length;
  classes$1(overlay.html).toggle(EMPTY_MARKER, !hasFlowElements);
};
DrilldownOverlayBehavior.prototype._addOverlay = function(element) {
  var canvas = this._canvas, overlays = this._overlays;
  var existingOverlays = overlays.get({ element, type: "drilldown" });
  if (existingOverlays.length) {
    this._removeOverlay(element);
  }
  var button = domify$1('<button class="bjs-drilldown">' + ARROW_DOWN_SVG + "</button>");
  button.addEventListener("click", function() {
    canvas.setRootElement(canvas.findRoot(getPlaneIdFromShape(element)));
  });
  overlays.add(element, "drilldown", {
    position: {
      bottom: -7,
      right: -8
    },
    html: button
  });
  this._updateOverlayVisibility(element);
};
DrilldownOverlayBehavior.prototype._removeOverlay = function(element) {
  var overlays = this._overlays;
  overlays.remove({
    element,
    type: "drilldown"
  });
};
DrilldownOverlayBehavior.$inject = [
  "canvas",
  "eventBus",
  "elementRegistry",
  "overlays"
];
const DrilldownModdule = {
  __depends__: [OverlaysModule, ChangeSupportModule, RootElementsModule],
  __init__: ["drilldownBreadcrumbs", "drilldownOverlayBehavior", "drilldownCentering", "subprocessCompatibility"],
  drilldownBreadcrumbs: ["type", DrilldownBreadcrumbs],
  drilldownCentering: ["type", DrilldownCentering],
  drilldownOverlayBehavior: ["type", DrilldownOverlayBehavior],
  subprocessCompatibility: ["type", SubprocessCompatibility]
};
function Viewer(options) {
  BaseViewer.call(this, options);
}
e$3(Viewer, BaseViewer);
Viewer.prototype._modules = [
  CoreModule,
  translate,
  SelectionModule,
  OverlaysModule,
  DrilldownModdule
];
Viewer.prototype._moddleExtensions = {};
var KEYS_COPY = ["c", "C"];
var KEYS_PASTE = ["v", "V"];
var KEYS_REDO = ["y", "Y"];
var KEYS_UNDO = ["z", "Z"];
function hasModifier(event2) {
  return event2.ctrlKey || event2.metaKey || event2.shiftKey || event2.altKey;
}
function isCmd(event2) {
  if (event2.altKey) {
    return false;
  }
  return event2.ctrlKey || event2.metaKey;
}
function isKey(keys2, event2) {
  keys2 = isArray$3(keys2) ? keys2 : [keys2];
  return keys2.indexOf(event2.key) !== -1 || keys2.indexOf(event2.code) !== -1;
}
function isShift(event2) {
  return event2.shiftKey;
}
function isCopy(event2) {
  return isCmd(event2) && isKey(KEYS_COPY, event2);
}
function isPaste(event2) {
  return isCmd(event2) && isKey(KEYS_PASTE, event2);
}
function isUndo(event2) {
  return isCmd(event2) && !isShift(event2) && isKey(KEYS_UNDO, event2);
}
function isRedo(event2) {
  return isCmd(event2) && (isKey(KEYS_REDO, event2) || isKey(KEYS_UNDO, event2) && isShift(event2));
}
var KEYDOWN_EVENT = "keyboard.keydown", KEYUP_EVENT = "keyboard.keyup";
var HANDLE_MODIFIER_ATTRIBUTE = "input-handle-modified-keys";
var DEFAULT_PRIORITY$3 = 1e3;
function Keyboard(config, eventBus) {
  var self2 = this;
  this._config = config || {};
  this._eventBus = eventBus;
  this._keydownHandler = this._keydownHandler.bind(this);
  this._keyupHandler = this._keyupHandler.bind(this);
  eventBus.on("diagram.destroy", function() {
    self2._fire("destroy");
    self2.unbind();
  });
  eventBus.on("diagram.init", function() {
    self2._fire("init");
  });
  eventBus.on("attach", function() {
    if (config && config.bindTo) {
      self2.bind(config.bindTo);
    }
  });
  eventBus.on("detach", function() {
    self2.unbind();
  });
}
Keyboard.$inject = [
  "config.keyboard",
  "eventBus"
];
Keyboard.prototype._keydownHandler = function(event2) {
  this._keyHandler(event2, KEYDOWN_EVENT);
};
Keyboard.prototype._keyupHandler = function(event2) {
  this._keyHandler(event2, KEYUP_EVENT);
};
Keyboard.prototype._keyHandler = function(event2, type) {
  var eventBusResult;
  if (this._isEventIgnored(event2)) {
    return;
  }
  var context = {
    keyEvent: event2
  };
  eventBusResult = this._eventBus.fire(type || KEYDOWN_EVENT, context);
  if (eventBusResult) {
    event2.preventDefault();
  }
};
Keyboard.prototype._isEventIgnored = function(event2) {
  if (event2.defaultPrevented) {
    return true;
  }
  return (isInput(event2.target) || isButton(event2.target) && isKey([" ", "Enter"], event2)) && this._isModifiedKeyIgnored(event2);
};
Keyboard.prototype._isModifiedKeyIgnored = function(event2) {
  if (!isCmd(event2)) {
    return true;
  }
  var allowedModifiers = this._getAllowedModifiers(event2.target);
  return allowedModifiers.indexOf(event2.key) === -1;
};
Keyboard.prototype._getAllowedModifiers = function(element) {
  var modifierContainer = closest(element, "[" + HANDLE_MODIFIER_ATTRIBUTE + "]", true);
  if (!modifierContainer || this._node && !this._node.contains(modifierContainer)) {
    return [];
  }
  return modifierContainer.getAttribute(HANDLE_MODIFIER_ATTRIBUTE).split(",");
};
Keyboard.prototype.bind = function(node2) {
  this.unbind();
  this._node = node2;
  event.bind(node2, "keydown", this._keydownHandler);
  event.bind(node2, "keyup", this._keyupHandler);
  this._fire("bind");
};
Keyboard.prototype.getBinding = function() {
  return this._node;
};
Keyboard.prototype.unbind = function() {
  var node2 = this._node;
  if (node2) {
    this._fire("unbind");
    event.unbind(node2, "keydown", this._keydownHandler);
    event.unbind(node2, "keyup", this._keyupHandler);
  }
  this._node = null;
};
Keyboard.prototype._fire = function(event2) {
  this._eventBus.fire("keyboard." + event2, { node: this._node });
};
Keyboard.prototype.addListener = function(priority, listener, type) {
  if (isFunction(priority)) {
    type = listener;
    listener = priority;
    priority = DEFAULT_PRIORITY$3;
  }
  this._eventBus.on(type || KEYDOWN_EVENT, priority, listener);
};
Keyboard.prototype.removeListener = function(listener, type) {
  this._eventBus.off(type || KEYDOWN_EVENT, listener);
};
Keyboard.prototype.hasModifier = hasModifier;
Keyboard.prototype.isCmd = isCmd;
Keyboard.prototype.isShift = isShift;
Keyboard.prototype.isKey = isKey;
function isInput(target) {
  return target && (matches(target, "input, textarea") || target.contentEditable === "true");
}
function isButton(target) {
  return target && matches(target, "button, input[type=submit], input[type=button], a[href], [aria-role=button]");
}
var LOW_PRIORITY$m = 500;
function KeyboardBindings(eventBus, keyboard) {
  var self2 = this;
  eventBus.on("editorActions.init", LOW_PRIORITY$m, function(event2) {
    var editorActions = event2.editorActions;
    self2.registerBindings(keyboard, editorActions);
  });
}
KeyboardBindings.$inject = [
  "eventBus",
  "keyboard"
];
KeyboardBindings.prototype.registerBindings = function(keyboard, editorActions) {
  function addListener(action, fn) {
    if (editorActions.isRegistered(action)) {
      keyboard.addListener(fn);
    }
  }
  addListener("undo", function(context) {
    var event2 = context.keyEvent;
    if (isUndo(event2)) {
      editorActions.trigger("undo");
      return true;
    }
  });
  addListener("redo", function(context) {
    var event2 = context.keyEvent;
    if (isRedo(event2)) {
      editorActions.trigger("redo");
      return true;
    }
  });
  addListener("copy", function(context) {
    var event2 = context.keyEvent;
    if (isCopy(event2)) {
      editorActions.trigger("copy");
      return true;
    }
  });
  addListener("paste", function(context) {
    var event2 = context.keyEvent;
    if (isPaste(event2)) {
      editorActions.trigger("paste");
      return true;
    }
  });
  addListener("stepZoom", function(context) {
    var event2 = context.keyEvent;
    if (isKey(["+", "Add", "="], event2) && isCmd(event2)) {
      editorActions.trigger("stepZoom", { value: 1 });
      return true;
    }
  });
  addListener("stepZoom", function(context) {
    var event2 = context.keyEvent;
    if (isKey(["-", "Subtract"], event2) && isCmd(event2)) {
      editorActions.trigger("stepZoom", { value: -1 });
      return true;
    }
  });
  addListener("zoom", function(context) {
    var event2 = context.keyEvent;
    if (isKey("0", event2) && isCmd(event2)) {
      editorActions.trigger("zoom", { value: 1 });
      return true;
    }
  });
  addListener("removeSelection", function(context) {
    var event2 = context.keyEvent;
    if (isKey(["Backspace", "Delete", "Del"], event2)) {
      editorActions.trigger("removeSelection");
      return true;
    }
  });
};
const KeyboardModule$1 = {
  __init__: ["keyboard", "keyboardBindings"],
  keyboard: ["type", Keyboard],
  keyboardBindings: ["type", KeyboardBindings]
};
var DEFAULT_CONFIG$1 = {
  moveSpeed: 50,
  moveSpeedAccelerated: 200
};
function KeyboardMove(config, keyboard, canvas) {
  var self2 = this;
  this._config = assign$1({}, DEFAULT_CONFIG$1, config || {});
  keyboard.addListener(arrowsListener);
  function arrowsListener(context) {
    var event2 = context.keyEvent, config2 = self2._config;
    if (!keyboard.isCmd(event2)) {
      return;
    }
    if (keyboard.isKey([
      "ArrowLeft",
      "Left",
      "ArrowUp",
      "Up",
      "ArrowDown",
      "Down",
      "ArrowRight",
      "Right"
    ], event2)) {
      var speed = keyboard.isShift(event2) ? config2.moveSpeedAccelerated : config2.moveSpeed;
      var direction;
      switch (event2.key) {
        case "ArrowLeft":
        case "Left":
          direction = "left";
          break;
        case "ArrowUp":
        case "Up":
          direction = "up";
          break;
        case "ArrowRight":
        case "Right":
          direction = "right";
          break;
        case "ArrowDown":
        case "Down":
          direction = "down";
          break;
      }
      self2.moveCanvas({
        speed,
        direction
      });
      return true;
    }
  }
  this.moveCanvas = function(options) {
    var dx = 0, dy = 0, speed = options.speed;
    var actualSpeed = speed / Math.min(Math.sqrt(canvas.viewbox().scale), 1);
    switch (options.direction) {
      case "left":
        dx = actualSpeed;
        break;
      case "up":
        dy = actualSpeed;
        break;
      case "right":
        dx = -actualSpeed;
        break;
      case "down":
        dy = -actualSpeed;
        break;
    }
    canvas.scroll({
      dx,
      dy
    });
  };
}
KeyboardMove.$inject = [
  "config.keyboardMove",
  "keyboard",
  "canvas"
];
const KeyboardMoveModule = {
  __depends__: [
    KeyboardModule$1
  ],
  __init__: ["keyboardMove"],
  keyboardMove: ["type", KeyboardMove]
};
var CURSOR_CLS_PATTERN = /^djs-cursor-.*$/;
function set(mode) {
  var classes2 = classes$1(document.body);
  classes2.removeMatching(CURSOR_CLS_PATTERN);
  if (mode) {
    classes2.add("djs-cursor-" + mode);
  }
}
function unset() {
  set(null);
}
var TRAP_PRIORITY = 5e3;
function install$1(eventBus, eventName) {
  eventName = eventName || "element.click";
  function trap() {
    return false;
  }
  eventBus.once(eventName, TRAP_PRIORITY, trap);
  return function() {
    eventBus.off(eventName, trap);
  };
}
function center(bounds) {
  return {
    x: bounds.x + bounds.width / 2,
    y: bounds.y + bounds.height / 2
  };
}
function delta(a2, b2) {
  return {
    x: a2.x - b2.x,
    y: a2.y - b2.y
  };
}
var THRESHOLD$1 = 15;
function MoveCanvas(eventBus, canvas) {
  var context;
  eventBus.on("element.mousedown", 500, function(e2) {
    return handleStart(e2.originalEvent);
  });
  function handleMove(event2) {
    var start = context.start, button = context.button, position = toPoint(event2), delta$1 = delta(position, start);
    if (!context.dragging && length(delta$1) > THRESHOLD$1) {
      context.dragging = true;
      if (button === 0) {
        install$1(eventBus);
      }
      set("grab");
    }
    if (context.dragging) {
      var lastPosition = context.last || context.start;
      delta$1 = delta(position, lastPosition);
      canvas.scroll({
        dx: delta$1.x,
        dy: delta$1.y
      });
      context.last = position;
    }
    event2.preventDefault();
  }
  function handleEnd(event$1) {
    event.unbind(document, "mousemove", handleMove);
    event.unbind(document, "mouseup", handleEnd);
    context = null;
    unset();
  }
  function handleStart(event$1) {
    if (closest(event$1.target, ".djs-draggable")) {
      return;
    }
    var button = event$1.button;
    if (button >= 2 || event$1.ctrlKey || event$1.shiftKey || event$1.altKey) {
      return;
    }
    context = {
      button,
      start: toPoint(event$1)
    };
    event.bind(document, "mousemove", handleMove);
    event.bind(document, "mouseup", handleEnd);
    return true;
  }
  this.isActive = function() {
    return !!context;
  };
}
MoveCanvas.$inject = [
  "eventBus",
  "canvas"
];
function length(point) {
  return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
}
const MoveCanvasModule = {
  __init__: ["moveCanvas"],
  moveCanvas: ["type", MoveCanvas]
};
function log10(x2) {
  return Math.log(x2) / Math.log(10);
}
function getStepSize(range, steps) {
  var minLinearRange = log10(range.min), maxLinearRange = log10(range.max);
  var absoluteLinearRange = Math.abs(minLinearRange) + Math.abs(maxLinearRange);
  return absoluteLinearRange / steps;
}
function cap(range, scale) {
  return Math.max(range.min, Math.min(range.max, scale));
}
var sign = Math.sign || function(n2) {
  return n2 >= 0 ? 1 : -1;
};
var RANGE = { min: 0.2, max: 4 }, NUM_STEPS = 10;
var DELTA_THRESHOLD = 0.1;
var DEFAULT_SCALE = 0.75;
function ZoomScroll(config, eventBus, canvas) {
  config = config || {};
  this._enabled = false;
  this._canvas = canvas;
  this._container = canvas._container;
  this._handleWheel = bind$2(this._handleWheel, this);
  this._totalDelta = 0;
  this._scale = config.scale || DEFAULT_SCALE;
  var self2 = this;
  eventBus.on("canvas.init", function(e2) {
    self2._init(config.enabled !== false);
  });
}
ZoomScroll.$inject = [
  "config.zoomScroll",
  "eventBus",
  "canvas"
];
ZoomScroll.prototype.scroll = function scroll(delta2) {
  this._canvas.scroll(delta2);
};
ZoomScroll.prototype.reset = function reset() {
  this._canvas.zoom("fit-viewport");
};
ZoomScroll.prototype.zoom = function zoom(delta2, position) {
  var stepSize = getStepSize(RANGE, NUM_STEPS * 2);
  this._totalDelta += delta2;
  if (Math.abs(this._totalDelta) > DELTA_THRESHOLD) {
    this._zoom(delta2, position, stepSize);
    this._totalDelta = 0;
  }
};
ZoomScroll.prototype._handleWheel = function handleWheel(event2) {
  if (closest(event2.target, ".djs-scrollable", true)) {
    return;
  }
  var element = this._container;
  event2.preventDefault();
  var isZoom = event2.ctrlKey || isMac() && event2.metaKey;
  var isHorizontalScroll = event2.shiftKey;
  var factor = -1 * this._scale, delta2;
  if (isZoom) {
    factor *= event2.deltaMode === 0 ? 0.02 : 0.32;
  } else {
    factor *= event2.deltaMode === 0 ? 1 : 16;
  }
  if (isZoom) {
    var elementRect = element.getBoundingClientRect();
    var offset = {
      x: event2.clientX - elementRect.left,
      y: event2.clientY - elementRect.top
    };
    delta2 = Math.sqrt(
      Math.pow(event2.deltaY, 2) + Math.pow(event2.deltaX, 2)
    ) * sign(event2.deltaY) * factor;
    this.zoom(delta2, offset);
  } else {
    if (isHorizontalScroll) {
      delta2 = {
        dx: factor * event2.deltaY,
        dy: 0
      };
    } else {
      delta2 = {
        dx: factor * event2.deltaX,
        dy: factor * event2.deltaY
      };
    }
    this.scroll(delta2);
  }
};
ZoomScroll.prototype.stepZoom = function stepZoom(delta2, position) {
  var stepSize = getStepSize(RANGE, NUM_STEPS);
  this._zoom(delta2, position, stepSize);
};
ZoomScroll.prototype._zoom = function(delta2, position, stepSize) {
  var canvas = this._canvas;
  var direction = delta2 > 0 ? 1 : -1;
  var currentLinearZoomLevel = log10(canvas.zoom());
  var newLinearZoomLevel = Math.round(currentLinearZoomLevel / stepSize) * stepSize;
  newLinearZoomLevel += stepSize * direction;
  var newLogZoomLevel = Math.pow(10, newLinearZoomLevel);
  canvas.zoom(cap(RANGE, newLogZoomLevel), position);
};
ZoomScroll.prototype.toggle = function toggle(newEnabled) {
  var element = this._container;
  var handleWheel2 = this._handleWheel;
  var oldEnabled = this._enabled;
  if (typeof newEnabled === "undefined") {
    newEnabled = !oldEnabled;
  }
  if (oldEnabled !== newEnabled) {
    event[newEnabled ? "bind" : "unbind"](element, "wheel", handleWheel2, false);
  }
  this._enabled = newEnabled;
  return newEnabled;
};
ZoomScroll.prototype._init = function(newEnabled) {
  this.toggle(newEnabled);
};
const ZoomScrollModule = {
  __init__: ["zoomScroll"],
  zoomScroll: ["type", ZoomScroll]
};
function NavigatedViewer(options) {
  Viewer.call(this, options);
}
e$3(NavigatedViewer, Viewer);
NavigatedViewer.prototype._navigationModules = [
  KeyboardMoveModule,
  MoveCanvasModule,
  ZoomScrollModule
];
NavigatedViewer.prototype._modules = [].concat(
  Viewer.prototype._modules,
  NavigatedViewer.prototype._navigationModules
);
function last(arr) {
  return arr && arr[arr.length - 1];
}
function sortTopOrMiddle(element) {
  return element.y;
}
function sortLeftOrCenter(element) {
  return element.x;
}
var ALIGNMENT_SORTING = {
  left: sortLeftOrCenter,
  center: sortLeftOrCenter,
  right: function(element) {
    return element.x + element.width;
  },
  top: sortTopOrMiddle,
  middle: sortTopOrMiddle,
  bottom: function(element) {
    return element.y + element.height;
  }
};
function AlignElements$1(modeling, rules) {
  this._modeling = modeling;
  this._rules = rules;
}
AlignElements$1.$inject = ["modeling", "rules"];
AlignElements$1.prototype._getOrientationDetails = function(type) {
  var vertical = ["top", "bottom", "middle"], axis = "x", dimension = "width";
  if (vertical.indexOf(type) !== -1) {
    axis = "y";
    dimension = "height";
  }
  return {
    axis,
    dimension
  };
};
AlignElements$1.prototype._isType = function(type, types2) {
  return types2.indexOf(type) !== -1;
};
AlignElements$1.prototype._alignmentPosition = function(type, sortedElements) {
  var orientation = this._getOrientationDetails(type), axis = orientation.axis, dimension = orientation.dimension, alignment = {}, centers = {}, hasSharedCenters = false, centeredElements, firstElement, lastElement;
  function getMiddleOrTop(first, last2) {
    return Math.round((first[axis] + last2[axis] + last2[dimension]) / 2);
  }
  if (this._isType(type, ["left", "top"])) {
    alignment[type] = sortedElements[0][axis];
  } else if (this._isType(type, ["right", "bottom"])) {
    lastElement = last(sortedElements);
    alignment[type] = lastElement[axis] + lastElement[dimension];
  } else if (this._isType(type, ["center", "middle"])) {
    forEach$1(sortedElements, function(element) {
      var center2 = element[axis] + Math.round(element[dimension] / 2);
      if (centers[center2]) {
        centers[center2].elements.push(element);
      } else {
        centers[center2] = {
          elements: [element],
          center: center2
        };
      }
    });
    centeredElements = sortBy(centers, function(center2) {
      if (center2.elements.length > 1) {
        hasSharedCenters = true;
      }
      return center2.elements.length;
    });
    if (hasSharedCenters) {
      alignment[type] = last(centeredElements).center;
      return alignment;
    }
    firstElement = sortedElements[0];
    sortedElements = sortBy(sortedElements, function(element) {
      return element[axis] + element[dimension];
    });
    lastElement = last(sortedElements);
    alignment[type] = getMiddleOrTop(firstElement, lastElement);
  }
  return alignment;
};
AlignElements$1.prototype.trigger = function(elements, type) {
  var modeling = this._modeling, allowed;
  var filteredElements = filter(elements, function(element) {
    return !(element.waypoints || element.host || element.labelTarget);
  });
  allowed = this._rules.allowed("elements.align", { elements: filteredElements });
  if (isArray$3(allowed)) {
    filteredElements = allowed;
  }
  if (filteredElements.length < 2 || !allowed) {
    return;
  }
  var sortFn = ALIGNMENT_SORTING[type];
  var sortedElements = sortBy(filteredElements, sortFn);
  var alignment = this._alignmentPosition(type, sortedElements);
  modeling.alignElements(sortedElements, alignment);
};
const AlignElementsModule$1 = {
  __init__: ["alignElements"],
  alignElements: ["type", AlignElements$1]
};
var entrySelector = ".entry";
var DEFAULT_PRIORITY$2 = 1e3;
var CONTEXT_PAD_PADDING = 12;
var HOVER_DELAY = 300;
function ContextPad(canvas, config, eventBus, overlays) {
  this._canvas = canvas;
  this._eventBus = eventBus;
  this._overlays = overlays;
  var scale = isDefined(config && config.scale) ? config.scale : {
    min: 1,
    max: 1.5
  };
  this._overlaysConfig = {
    scale
  };
  this._current = null;
  this._init();
}
ContextPad.$inject = [
  "canvas",
  "config.contextPad",
  "eventBus",
  "overlays"
];
ContextPad.prototype._init = function() {
  var self2 = this;
  this._eventBus.on("selection.changed", function(event2) {
    var selection = event2.newSelection;
    var target = selection.length ? selection.length === 1 ? selection[0] : selection : null;
    if (target) {
      self2.open(target, true);
    } else {
      self2.close();
    }
  });
  this._eventBus.on("elements.changed", function(event2) {
    var elements = event2.elements, current = self2._current;
    if (!current) {
      return;
    }
    var currentTarget = current.target;
    var currentChanged = some(
      isArray$3(currentTarget) ? currentTarget : [currentTarget],
      function(element) {
        return includes$8(elements, element);
      }
    );
    if (currentChanged) {
      self2.open(currentTarget, true);
    }
  });
};
ContextPad.prototype.registerProvider = function(priority, provider) {
  if (!provider) {
    provider = priority;
    priority = DEFAULT_PRIORITY$2;
  }
  this._eventBus.on("contextPad.getProviders", priority, function(event2) {
    event2.providers.push(provider);
  });
};
ContextPad.prototype.getEntries = function(target) {
  var providers = this._getProviders();
  var provideFn = isArray$3(target) ? "getMultiElementContextPadEntries" : "getContextPadEntries";
  var entries = {};
  forEach$1(providers, function(provider) {
    if (!isFunction(provider[provideFn])) {
      return;
    }
    var entriesOrUpdater = provider[provideFn](target);
    if (isFunction(entriesOrUpdater)) {
      entries = entriesOrUpdater(entries);
    } else {
      forEach$1(entriesOrUpdater, function(entry, id) {
        entries[id] = entry;
      });
    }
  });
  return entries;
};
ContextPad.prototype.trigger = function(action, event2, autoActivate) {
  var entry, originalEvent, button = event2.delegateTarget || event2.target;
  if (!button) {
    return event2.preventDefault();
  }
  entry = attr$1(button, "data-action");
  originalEvent = event2.originalEvent || event2;
  if (action === "mouseover") {
    this._timeout = setTimeout(() => {
      this._mouseout = this.triggerEntry(entry, "hover", originalEvent, autoActivate);
    }, HOVER_DELAY);
  } else if (action === "mouseout") {
    clearTimeout(this._timeout);
    if (this._mouseout) {
      this._mouseout();
      this._mouseout = null;
    }
  }
  return this.triggerEntry(entry, action, originalEvent, autoActivate);
};
ContextPad.prototype.triggerEntry = function(entryId, action, event2, autoActivate) {
  if (!this.isShown()) {
    return;
  }
  var target = this._current.target, entries = this._current.entries;
  var entry = entries[entryId];
  if (!entry) {
    return;
  }
  var handler = entry.action;
  if (this._eventBus.fire("contextPad.trigger", { entry, event: event2 }) === false) {
    return;
  }
  if (isFunction(handler)) {
    if (action === "click") {
      return handler(event2, target, autoActivate);
    }
  } else {
    if (handler[action]) {
      return handler[action](event2, target, autoActivate);
    }
  }
  event2.preventDefault();
};
ContextPad.prototype.open = function(target, force) {
  if (!force && this.isOpen(target)) {
    return;
  }
  this.close();
  this._updateAndOpen(target);
};
ContextPad.prototype._getProviders = function() {
  var event2 = this._eventBus.createEvent({
    type: "contextPad.getProviders",
    providers: []
  });
  this._eventBus.fire(event2);
  return event2.providers;
};
ContextPad.prototype._updateAndOpen = function(target) {
  var entries = this.getEntries(target), pad = this.getPad(target), html = pad.html, image;
  forEach$1(entries, function(entry, id) {
    var grouping = entry.group || "default", control = domify$1(entry.html || '<div class="entry" draggable="true"></div>'), container;
    attr$1(control, "data-action", id);
    container = query("[data-group=" + escapeCSS(grouping) + "]", html);
    if (!container) {
      container = domify$1('<div class="group"></div>');
      attr$1(container, "data-group", grouping);
      html.appendChild(container);
    }
    container.appendChild(control);
    if (entry.className) {
      addClasses$1(control, entry.className);
    }
    if (entry.title) {
      attr$1(control, "title", entry.title);
    }
    if (entry.imageUrl) {
      image = domify$1("<img>");
      attr$1(image, "src", entry.imageUrl);
      image.style.width = "100%";
      image.style.height = "100%";
      control.appendChild(image);
    }
  });
  classes$1(html).add("open");
  this._current = {
    target,
    entries,
    pad
  };
  this._eventBus.fire("contextPad.open", { current: this._current });
};
ContextPad.prototype.getPad = function(target) {
  if (this.isOpen()) {
    return this._current.pad;
  }
  var self2 = this;
  var overlays = this._overlays;
  var html = domify$1('<div class="djs-context-pad"></div>');
  var position = this._getPosition(target);
  var overlaysConfig = assign$1({
    html
  }, this._overlaysConfig, position);
  delegate.bind(html, entrySelector, "click", function(event2) {
    self2.trigger("click", event2);
  });
  delegate.bind(html, entrySelector, "dragstart", function(event2) {
    self2.trigger("dragstart", event2);
  });
  delegate.bind(html, entrySelector, "mouseover", function(event2) {
    self2.trigger("mouseover", event2);
  });
  delegate.bind(html, entrySelector, "mouseout", function(event2) {
    self2.trigger("mouseout", event2);
  });
  event.bind(html, "mousedown", function(event2) {
    event2.stopPropagation();
  });
  var activeRootElement = this._canvas.getRootElement();
  this._overlayId = overlays.add(activeRootElement, "context-pad", overlaysConfig);
  var pad = overlays.get(this._overlayId);
  this._eventBus.fire("contextPad.create", {
    target,
    pad
  });
  return pad;
};
ContextPad.prototype.close = function() {
  if (!this.isOpen()) {
    return;
  }
  clearTimeout(this._timeout);
  this._overlays.remove(this._overlayId);
  this._overlayId = null;
  this._eventBus.fire("contextPad.close", { current: this._current });
  this._current = null;
};
ContextPad.prototype.isOpen = function(target) {
  var current = this._current;
  if (!current) {
    return false;
  }
  if (!target) {
    return true;
  }
  var currentTarget = current.target;
  if (isArray$3(target) !== isArray$3(currentTarget)) {
    return false;
  }
  if (isArray$3(target)) {
    return target.length === currentTarget.length && every(target, function(element) {
      return includes$8(currentTarget, element);
    });
  } else {
    return currentTarget === target;
  }
};
ContextPad.prototype.isShown = function() {
  return this.isOpen() && this._overlays.isShown();
};
ContextPad.prototype._getPosition = function(target) {
  target = isConnection(target) ? getLastWaypoint(target) : target;
  var elements = isArray$3(target) ? target : [target];
  var bBox = getBBox(elements);
  return {
    position: {
      left: bBox.x + bBox.width + CONTEXT_PAD_PADDING,
      top: bBox.y - CONTEXT_PAD_PADDING / 2
    }
  };
};
function addClasses$1(element, classNames) {
  var classes2 = classes$1(element);
  classNames = isArray$3(classNames) ? classNames : classNames.split(/\s+/g);
  classNames.forEach(function(cls) {
    classes2.add(cls);
  });
}
function includes$8(array, item) {
  return array.indexOf(item) !== -1;
}
function getLastWaypoint(connection) {
  return connection.waypoints[connection.waypoints.length - 1];
}
const ContextPadModule$1 = {
  __depends__: [
    InteractionEventsModule$1,
    OverlaysModule
  ],
  contextPad: ["type", ContextPad]
};
var n$1, l$1, u$1, i$1, o$1, r$2, f$1, e$2, c$1, s$1, h$1 = {}, v$1 = [], p$1 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, y$1 = Array.isArray;
function d$1(n2, l2) {
  for (var u2 in l2)
    n2[u2] = l2[u2];
  return n2;
}
function _$1(n2) {
  var l2 = n2.parentNode;
  l2 && l2.removeChild(n2);
}
function g(l2, u2, t2) {
  var i2, o2, r2, f2 = {};
  for (r2 in u2)
    "key" == r2 ? i2 = u2[r2] : "ref" == r2 ? o2 = u2[r2] : f2[r2] = u2[r2];
  if (arguments.length > 2 && (f2.children = arguments.length > 3 ? n$1.call(arguments, 2) : t2), "function" == typeof l2 && null != l2.defaultProps)
    for (r2 in l2.defaultProps)
      void 0 === f2[r2] && (f2[r2] = l2.defaultProps[r2]);
  return b(l2, f2, i2, o2, null);
}
function b(n2, t2, i2, o2, r2) {
  var f2 = { type: n2, props: t2, key: i2, ref: o2, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: null == r2 ? ++u$1 : r2, __i: -1, __u: 0 };
  return null == r2 && null != l$1.vnode && l$1.vnode(f2), f2;
}
function w$1(n2) {
  return n2.children;
}
function k$1(n2, l2) {
  this.props = n2, this.context = l2;
}
function x$1(n2, l2) {
  if (null == l2)
    return n2.__ ? x$1(n2.__, n2.__i + 1) : null;
  for (var u2; l2 < n2.__k.length; l2++)
    if (null != (u2 = n2.__k[l2]) && null != u2.__e)
      return u2.__e;
  return "function" == typeof n2.type ? x$1(n2) : null;
}
function C$1(n2) {
  var l2, u2;
  if (null != (n2 = n2.__) && null != n2.__c) {
    for (n2.__e = n2.__c.base = null, l2 = 0; l2 < n2.__k.length; l2++)
      if (null != (u2 = n2.__k[l2]) && null != u2.__e) {
        n2.__e = n2.__c.base = u2.__e;
        break;
      }
    return C$1(n2);
  }
}
function P(n2) {
  (!n2.__d && (n2.__d = true) && i$1.push(n2) && !S.__r++ || o$1 !== l$1.debounceRendering) && ((o$1 = l$1.debounceRendering) || r$2)(S);
}
function S() {
  var n2, u2, t2, o2, r2, e2, c2, s2;
  for (i$1.sort(f$1); n2 = i$1.shift(); )
    n2.__d && (u2 = i$1.length, o2 = void 0, e2 = (r2 = (t2 = n2).__v).__e, c2 = [], s2 = [], t2.__P && ((o2 = d$1({}, r2)).__v = r2.__v + 1, l$1.vnode && l$1.vnode(o2), O(t2.__P, o2, r2, t2.__n, void 0 !== t2.__P.ownerSVGElement, 32 & r2.__u ? [e2] : null, c2, null == e2 ? x$1(r2) : e2, !!(32 & r2.__u), s2), o2.__v = r2.__v, o2.__.__k[o2.__i] = o2, j$1(c2, o2, s2), o2.__e != e2 && C$1(o2)), i$1.length > u2 && i$1.sort(f$1));
  S.__r = 0;
}
function $(n2, l2, u2, t2, i2, o2, r2, f2, e2, c2, s2) {
  var a2, p2, y2, d2, _2, g2 = t2 && t2.__k || v$1, b2 = l2.length;
  for (u2.__d = e2, I(u2, l2, g2), e2 = u2.__d, a2 = 0; a2 < b2; a2++)
    null != (y2 = u2.__k[a2]) && "boolean" != typeof y2 && "function" != typeof y2 && (p2 = -1 === y2.__i ? h$1 : g2[y2.__i] || h$1, y2.__i = a2, O(n2, y2, p2, i2, o2, r2, f2, e2, c2, s2), d2 = y2.__e, y2.ref && p2.ref != y2.ref && (p2.ref && N(p2.ref, null, y2), s2.push(y2.ref, y2.__c || d2, y2)), null == _2 && null != d2 && (_2 = d2), 65536 & y2.__u || p2.__k === y2.__k ? (e2 && !e2.isConnected && (e2 = x$1(p2)), e2 = H(y2, e2, n2)) : "function" == typeof y2.type && void 0 !== y2.__d ? e2 = y2.__d : d2 && (e2 = d2.nextSibling), y2.__d = void 0, y2.__u &= -196609);
  u2.__d = e2, u2.__e = _2;
}
function I(n2, l2, u2) {
  var t2, i2, o2, r2, f2, e2 = l2.length, c2 = u2.length, s2 = c2, a2 = 0;
  for (n2.__k = [], t2 = 0; t2 < e2; t2++)
    r2 = t2 + a2, null != (i2 = n2.__k[t2] = null == (i2 = l2[t2]) || "boolean" == typeof i2 || "function" == typeof i2 ? null : "string" == typeof i2 || "number" == typeof i2 || "bigint" == typeof i2 || i2.constructor == String ? b(null, i2, null, null, null) : y$1(i2) ? b(w$1, { children: i2 }, null, null, null) : void 0 === i2.constructor && i2.__b > 0 ? b(i2.type, i2.props, i2.key, i2.ref ? i2.ref : null, i2.__v) : i2) ? (i2.__ = n2, i2.__b = n2.__b + 1, f2 = A$1(i2, u2, r2, s2), i2.__i = f2, o2 = null, -1 !== f2 && (s2--, (o2 = u2[f2]) && (o2.__u |= 131072)), null == o2 || null === o2.__v ? (-1 == f2 && a2--, "function" != typeof i2.type && (i2.__u |= 65536)) : f2 !== r2 && (f2 === r2 + 1 ? a2++ : f2 > r2 ? s2 > e2 - r2 ? a2 += f2 - r2 : a2-- : f2 < r2 ? f2 == r2 - 1 && (a2 = f2 - r2) : a2 = 0, f2 !== t2 + a2 && (i2.__u |= 65536))) : (o2 = u2[r2]) && null == o2.key && o2.__e && 0 == (131072 & o2.__u) && (o2.__e == n2.__d && (n2.__d = x$1(o2)), q$1(o2, o2, false), u2[r2] = null, s2--);
  if (s2)
    for (t2 = 0; t2 < c2; t2++)
      null != (o2 = u2[t2]) && 0 == (131072 & o2.__u) && (o2.__e == n2.__d && (n2.__d = x$1(o2)), q$1(o2, o2));
}
function H(n2, l2, u2) {
  var t2, i2;
  if ("function" == typeof n2.type) {
    for (t2 = n2.__k, i2 = 0; t2 && i2 < t2.length; i2++)
      t2[i2] && (t2[i2].__ = n2, l2 = H(t2[i2], l2, u2));
    return l2;
  }
  n2.__e != l2 && (u2.insertBefore(n2.__e, l2 || null), l2 = n2.__e);
  do {
    l2 = l2 && l2.nextSibling;
  } while (null != l2 && 8 === l2.nodeType);
  return l2;
}
function A$1(n2, l2, u2, t2) {
  var i2 = n2.key, o2 = n2.type, r2 = u2 - 1, f2 = u2 + 1, e2 = l2[u2];
  if (null === e2 || e2 && i2 == e2.key && o2 === e2.type && 0 == (131072 & e2.__u))
    return u2;
  if (t2 > (null != e2 && 0 == (131072 & e2.__u) ? 1 : 0))
    for (; r2 >= 0 || f2 < l2.length; ) {
      if (r2 >= 0) {
        if ((e2 = l2[r2]) && 0 == (131072 & e2.__u) && i2 == e2.key && o2 === e2.type)
          return r2;
        r2--;
      }
      if (f2 < l2.length) {
        if ((e2 = l2[f2]) && 0 == (131072 & e2.__u) && i2 == e2.key && o2 === e2.type)
          return f2;
        f2++;
      }
    }
  return -1;
}
function F$1(n2, l2, u2) {
  "-" === l2[0] ? n2.setProperty(l2, null == u2 ? "" : u2) : n2[l2] = null == u2 ? "" : "number" != typeof u2 || p$1.test(l2) ? u2 : u2 + "px";
}
function L(n2, l2, u2, t2, i2) {
  var o2;
  n:
    if ("style" === l2)
      if ("string" == typeof u2)
        n2.style.cssText = u2;
      else {
        if ("string" == typeof t2 && (n2.style.cssText = t2 = ""), t2)
          for (l2 in t2)
            u2 && l2 in u2 || F$1(n2.style, l2, "");
        if (u2)
          for (l2 in u2)
            t2 && u2[l2] === t2[l2] || F$1(n2.style, l2, u2[l2]);
      }
    else if ("o" === l2[0] && "n" === l2[1])
      o2 = l2 !== (l2 = l2.replace(/(PointerCapture)$|Capture$/i, "$1")), l2 = l2.toLowerCase() in n2 || "onFocusOut" === l2 || "onFocusIn" === l2 ? l2.toLowerCase().slice(2) : l2.slice(2), n2.l || (n2.l = {}), n2.l[l2 + o2] = u2, u2 ? t2 ? u2.u = t2.u : (u2.u = e$2, n2.addEventListener(l2, o2 ? s$1 : c$1, o2)) : n2.removeEventListener(l2, o2 ? s$1 : c$1, o2);
    else {
      if (i2)
        l2 = l2.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if ("width" != l2 && "height" != l2 && "href" != l2 && "list" != l2 && "form" != l2 && "tabIndex" != l2 && "download" != l2 && "rowSpan" != l2 && "colSpan" != l2 && "role" != l2 && l2 in n2)
        try {
          n2[l2] = null == u2 ? "" : u2;
          break n;
        } catch (n3) {
        }
      "function" == typeof u2 || (null == u2 || false === u2 && "-" !== l2[4] ? n2.removeAttribute(l2) : n2.setAttribute(l2, u2));
    }
}
function M(n2) {
  return function(u2) {
    if (this.l) {
      var t2 = this.l[u2.type + n2];
      if (null == u2.t)
        u2.t = e$2++;
      else if (u2.t < t2.u)
        return;
      return t2(l$1.event ? l$1.event(u2) : u2);
    }
  };
}
function O(n2, u2, t2, i2, o2, r2, f2, e2, c2, s2) {
  var a2, h2, v2, p2, _2, g2, b2, m2, x2, C2, P2, S2, I2, H2, T, A2 = u2.type;
  if (void 0 !== u2.constructor)
    return null;
  128 & t2.__u && (c2 = !!(32 & t2.__u), r2 = [e2 = u2.__e = t2.__e]), (a2 = l$1.__b) && a2(u2);
  n:
    if ("function" == typeof A2)
      try {
        if (m2 = u2.props, x2 = (a2 = A2.contextType) && i2[a2.__c], C2 = a2 ? x2 ? x2.props.value : a2.__ : i2, t2.__c ? b2 = (h2 = u2.__c = t2.__c).__ = h2.__E : ("prototype" in A2 && A2.prototype.render ? u2.__c = h2 = new A2(m2, C2) : (u2.__c = h2 = new k$1(m2, C2), h2.constructor = A2, h2.render = B$1), x2 && x2.sub(h2), h2.props = m2, h2.state || (h2.state = {}), h2.context = C2, h2.__n = i2, v2 = h2.__d = true, h2.__h = [], h2._sb = []), null == h2.__s && (h2.__s = h2.state), null != A2.getDerivedStateFromProps && (h2.__s == h2.state && (h2.__s = d$1({}, h2.__s)), d$1(h2.__s, A2.getDerivedStateFromProps(m2, h2.__s))), p2 = h2.props, _2 = h2.state, h2.__v = u2, v2)
          null == A2.getDerivedStateFromProps && null != h2.componentWillMount && h2.componentWillMount(), null != h2.componentDidMount && h2.__h.push(h2.componentDidMount);
        else {
          if (null == A2.getDerivedStateFromProps && m2 !== p2 && null != h2.componentWillReceiveProps && h2.componentWillReceiveProps(m2, C2), !h2.__e && (null != h2.shouldComponentUpdate && false === h2.shouldComponentUpdate(m2, h2.__s, C2) || u2.__v === t2.__v)) {
            for (u2.__v !== t2.__v && (h2.props = m2, h2.state = h2.__s, h2.__d = false), u2.__e = t2.__e, u2.__k = t2.__k, u2.__k.forEach(function(n3) {
              n3 && (n3.__ = u2);
            }), P2 = 0; P2 < h2._sb.length; P2++)
              h2.__h.push(h2._sb[P2]);
            h2._sb = [], h2.__h.length && f2.push(h2);
            break n;
          }
          null != h2.componentWillUpdate && h2.componentWillUpdate(m2, h2.__s, C2), null != h2.componentDidUpdate && h2.__h.push(function() {
            h2.componentDidUpdate(p2, _2, g2);
          });
        }
        if (h2.context = C2, h2.props = m2, h2.__P = n2, h2.__e = false, S2 = l$1.__r, I2 = 0, "prototype" in A2 && A2.prototype.render) {
          for (h2.state = h2.__s, h2.__d = false, S2 && S2(u2), a2 = h2.render(h2.props, h2.state, h2.context), H2 = 0; H2 < h2._sb.length; H2++)
            h2.__h.push(h2._sb[H2]);
          h2._sb = [];
        } else
          do {
            h2.__d = false, S2 && S2(u2), a2 = h2.render(h2.props, h2.state, h2.context), h2.state = h2.__s;
          } while (h2.__d && ++I2 < 25);
        h2.state = h2.__s, null != h2.getChildContext && (i2 = d$1(d$1({}, i2), h2.getChildContext())), v2 || null == h2.getSnapshotBeforeUpdate || (g2 = h2.getSnapshotBeforeUpdate(p2, _2)), $(n2, y$1(T = null != a2 && a2.type === w$1 && null == a2.key ? a2.props.children : a2) ? T : [T], u2, t2, i2, o2, r2, f2, e2, c2, s2), h2.base = u2.__e, u2.__u &= -161, h2.__h.length && f2.push(h2), b2 && (h2.__E = h2.__ = null);
      } catch (n3) {
        u2.__v = null, c2 || null != r2 ? (u2.__e = e2, u2.__u |= c2 ? 160 : 32, r2[r2.indexOf(e2)] = null) : (u2.__e = t2.__e, u2.__k = t2.__k), l$1.__e(n3, u2, t2);
      }
    else
      null == r2 && u2.__v === t2.__v ? (u2.__k = t2.__k, u2.__e = t2.__e) : u2.__e = z$1(t2.__e, u2, t2, i2, o2, r2, f2, c2, s2);
  (a2 = l$1.diffed) && a2(u2);
}
function j$1(n2, u2, t2) {
  u2.__d = void 0;
  for (var i2 = 0; i2 < t2.length; i2++)
    N(t2[i2], t2[++i2], t2[++i2]);
  l$1.__c && l$1.__c(u2, n2), n2.some(function(u3) {
    try {
      n2 = u3.__h, u3.__h = [], n2.some(function(n3) {
        n3.call(u3);
      });
    } catch (n3) {
      l$1.__e(n3, u3.__v);
    }
  });
}
function z$1(l2, u2, t2, i2, o2, r2, f2, e2, c2) {
  var s2, a2, v2, p2, d2, g2, b2, m2 = t2.props, w2 = u2.props, k2 = u2.type;
  if ("svg" === k2 && (o2 = true), null != r2) {
    for (s2 = 0; s2 < r2.length; s2++)
      if ((d2 = r2[s2]) && "setAttribute" in d2 == !!k2 && (k2 ? d2.localName === k2 : 3 === d2.nodeType)) {
        l2 = d2, r2[s2] = null;
        break;
      }
  }
  if (null == l2) {
    if (null === k2)
      return document.createTextNode(w2);
    l2 = o2 ? document.createElementNS("http://www.w3.org/2000/svg", k2) : document.createElement(k2, w2.is && w2), r2 = null, e2 = false;
  }
  if (null === k2)
    m2 === w2 || e2 && l2.data === w2 || (l2.data = w2);
  else {
    if (r2 = r2 && n$1.call(l2.childNodes), m2 = t2.props || h$1, !e2 && null != r2)
      for (m2 = {}, s2 = 0; s2 < l2.attributes.length; s2++)
        m2[(d2 = l2.attributes[s2]).name] = d2.value;
    for (s2 in m2)
      d2 = m2[s2], "children" == s2 || ("dangerouslySetInnerHTML" == s2 ? v2 = d2 : "key" === s2 || s2 in w2 || L(l2, s2, null, d2, o2));
    for (s2 in w2)
      d2 = w2[s2], "children" == s2 ? p2 = d2 : "dangerouslySetInnerHTML" == s2 ? a2 = d2 : "value" == s2 ? g2 = d2 : "checked" == s2 ? b2 = d2 : "key" === s2 || e2 && "function" != typeof d2 || m2[s2] === d2 || L(l2, s2, d2, m2[s2], o2);
    if (a2)
      e2 || v2 && (a2.__html === v2.__html || a2.__html === l2.innerHTML) || (l2.innerHTML = a2.__html), u2.__k = [];
    else if (v2 && (l2.innerHTML = ""), $(l2, y$1(p2) ? p2 : [p2], u2, t2, i2, o2 && "foreignObject" !== k2, r2, f2, r2 ? r2[0] : t2.__k && x$1(t2, 0), e2, c2), null != r2)
      for (s2 = r2.length; s2--; )
        null != r2[s2] && _$1(r2[s2]);
    e2 || (s2 = "value", void 0 !== g2 && (g2 !== l2[s2] || "progress" === k2 && !g2 || "option" === k2 && g2 !== m2[s2]) && L(l2, s2, g2, m2[s2], false), s2 = "checked", void 0 !== b2 && b2 !== l2[s2] && L(l2, s2, b2, m2[s2], false));
  }
  return l2;
}
function N(n2, u2, t2) {
  try {
    "function" == typeof n2 ? n2(u2) : n2.current = u2;
  } catch (n3) {
    l$1.__e(n3, t2);
  }
}
function q$1(n2, u2, t2) {
  var i2, o2;
  if (l$1.unmount && l$1.unmount(n2), (i2 = n2.ref) && (i2.current && i2.current !== n2.__e || N(i2, null, u2)), null != (i2 = n2.__c)) {
    if (i2.componentWillUnmount)
      try {
        i2.componentWillUnmount();
      } catch (n3) {
        l$1.__e(n3, u2);
      }
    i2.base = i2.__P = null;
  }
  if (i2 = n2.__k)
    for (o2 = 0; o2 < i2.length; o2++)
      i2[o2] && q$1(i2[o2], u2, t2 || "function" != typeof n2.type);
  t2 || null == n2.__e || _$1(n2.__e), n2.__c = n2.__ = n2.__e = n2.__d = void 0;
}
function B$1(n2, l2, u2) {
  return this.constructor(n2, u2);
}
function D$1(u2, t2, i2) {
  var o2, r2, f2, e2;
  l$1.__ && l$1.__(u2, t2), r2 = (o2 = "function" == typeof i2) ? null : i2 && i2.__k || t2.__k, f2 = [], e2 = [], O(t2, u2 = (!o2 && i2 || t2).__k = g(w$1, null, [u2]), r2 || h$1, h$1, void 0 !== t2.ownerSVGElement, !o2 && i2 ? [i2] : r2 ? null : t2.firstChild ? n$1.call(t2.childNodes) : null, f2, !o2 && i2 ? i2 : r2 ? r2.__e : t2.firstChild, o2, e2), j$1(f2, u2, e2);
}
n$1 = v$1.slice, l$1 = { __e: function(n2, l2, u2, t2) {
  for (var i2, o2, r2; l2 = l2.__; )
    if ((i2 = l2.__c) && !i2.__)
      try {
        if ((o2 = i2.constructor) && null != o2.getDerivedStateFromError && (i2.setState(o2.getDerivedStateFromError(n2)), r2 = i2.__d), null != i2.componentDidCatch && (i2.componentDidCatch(n2, t2 || {}), r2 = i2.__d), r2)
          return i2.__E = i2;
      } catch (l3) {
        n2 = l3;
      }
  throw n2;
} }, u$1 = 0, k$1.prototype.setState = function(n2, l2) {
  var u2;
  u2 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = d$1({}, this.state), "function" == typeof n2 && (n2 = n2(d$1({}, u2), this.props)), n2 && d$1(u2, n2), null != n2 && this.__v && (l2 && this._sb.push(l2), P(this));
}, k$1.prototype.forceUpdate = function(n2) {
  this.__v && (this.__e = true, n2 && this.__h.push(n2), P(this));
}, k$1.prototype.render = w$1, i$1 = [], r$2 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f$1 = function(n2, l2) {
  return n2.__v.__b - l2.__v.__b;
}, S.__r = 0, e$2 = 0, c$1 = M(false), s$1 = M(true);
var n = function(t2, s2, r2, e2) {
  var u2;
  s2[0] = 0;
  for (var h2 = 1; h2 < s2.length; h2++) {
    var p2 = s2[h2++], a2 = s2[h2] ? (s2[0] |= p2 ? 1 : 2, r2[s2[h2++]]) : s2[++h2];
    3 === p2 ? e2[0] = a2 : 4 === p2 ? e2[1] = Object.assign(e2[1] || {}, a2) : 5 === p2 ? (e2[1] = e2[1] || {})[s2[++h2]] = a2 : 6 === p2 ? e2[1][s2[++h2]] += a2 + "" : p2 ? (u2 = t2.apply(a2, n(t2, a2, r2, ["", null])), e2.push(u2), a2[0] ? s2[0] |= 2 : (s2[h2 - 2] = 0, s2[h2] = u2)) : e2.push(a2);
  }
  return e2;
}, t$1 = /* @__PURE__ */ new Map();
function e$1(s2) {
  var r2 = t$1.get(this);
  return r2 || (r2 = /* @__PURE__ */ new Map(), t$1.set(this, r2)), (r2 = n(this, r2.get(s2) || (r2.set(s2, r2 = function(n2) {
    for (var t2, s3, r3 = 1, e2 = "", u2 = "", h2 = [0], p2 = function(n3) {
      1 === r3 && (n3 || (e2 = e2.replace(/^\s*\n\s*|\s*\n\s*$/g, ""))) ? h2.push(0, n3, e2) : 3 === r3 && (n3 || e2) ? (h2.push(3, n3, e2), r3 = 2) : 2 === r3 && "..." === e2 && n3 ? h2.push(4, n3, 0) : 2 === r3 && e2 && !n3 ? h2.push(5, 0, true, e2) : r3 >= 5 && ((e2 || !n3 && 5 === r3) && (h2.push(r3, 0, e2, s3), r3 = 6), n3 && (h2.push(r3, n3, 0, s3), r3 = 6)), e2 = "";
    }, a2 = 0; a2 < n2.length; a2++) {
      a2 && (1 === r3 && p2(), p2(a2));
      for (var l2 = 0; l2 < n2[a2].length; l2++)
        t2 = n2[a2][l2], 1 === r3 ? "<" === t2 ? (p2(), h2 = [h2], r3 = 3) : e2 += t2 : 4 === r3 ? "--" === e2 && ">" === t2 ? (r3 = 1, e2 = "") : e2 = t2 + e2[0] : u2 ? t2 === u2 ? u2 = "" : e2 += t2 : '"' === t2 || "'" === t2 ? u2 = t2 : ">" === t2 ? (p2(), r3 = 1) : r3 && ("=" === t2 ? (r3 = 5, s3 = e2, e2 = "") : "/" === t2 && (r3 < 5 || ">" === n2[a2][l2 + 1]) ? (p2(), 3 === r3 && (h2 = h2[0]), r3 = h2, (h2 = h2[0]).push(2, 0, r3), r3 = 0) : " " === t2 || "	" === t2 || "\n" === t2 || "\r" === t2 ? (p2(), r3 = 2) : e2 += t2), 3 === r3 && "!--" === e2 && (r3 = 4, h2 = h2[0]);
    }
    return p2(), h2;
  }(s2)), r2), arguments, [])).length > 1 ? r2 : r2[0];
}
var m$1 = e$1.bind(g);
var t, r$1, u, i, o = 0, f = [], c = [], e = l$1, a = e.__b, v = e.__r, l = e.diffed, m = e.__c, s = e.unmount, d = e.__;
function h(n2, t2) {
  e.__h && e.__h(r$1, n2, o || t2), o = 0;
  var u2 = r$1.__H || (r$1.__H = { __: [], __h: [] });
  return n2 >= u2.__.length && u2.__.push({ __V: c }), u2.__[n2];
}
function p(n2) {
  return o = 1, y(D, n2);
}
function y(n2, u2, i2) {
  var o2 = h(t++, 2);
  if (o2.t = n2, !o2.__c && (o2.__ = [i2 ? i2(u2) : D(void 0, u2), function(n3) {
    var t2 = o2.__N ? o2.__N[0] : o2.__[0], r2 = o2.t(t2, n3);
    t2 !== r2 && (o2.__N = [r2, o2.__[1]], o2.__c.setState({}));
  }], o2.__c = r$1, !r$1.u)) {
    var f2 = function(n3, t2, r2) {
      if (!o2.__c.__H)
        return true;
      var u3 = o2.__c.__H.__.filter(function(n4) {
        return !!n4.__c;
      });
      if (u3.every(function(n4) {
        return !n4.__N;
      }))
        return !c2 || c2.call(this, n3, t2, r2);
      var i3 = false;
      return u3.forEach(function(n4) {
        if (n4.__N) {
          var t3 = n4.__[0];
          n4.__ = n4.__N, n4.__N = void 0, t3 !== n4.__[0] && (i3 = true);
        }
      }), !(!i3 && o2.__c.props === n3) && (!c2 || c2.call(this, n3, t2, r2));
    };
    r$1.u = true;
    var c2 = r$1.shouldComponentUpdate, e2 = r$1.componentWillUpdate;
    r$1.componentWillUpdate = function(n3, t2, r2) {
      if (this.__e) {
        var u3 = c2;
        c2 = void 0, f2(n3, t2, r2), c2 = u3;
      }
      e2 && e2.call(this, n3, t2, r2);
    }, r$1.shouldComponentUpdate = f2;
  }
  return o2.__N || o2.__;
}
function _(n2, u2) {
  var i2 = h(t++, 3);
  !e.__s && C(i2.__H, u2) && (i2.__ = n2, i2.i = u2, r$1.__H.__h.push(i2));
}
function A(n2, u2) {
  var i2 = h(t++, 4);
  !e.__s && C(i2.__H, u2) && (i2.__ = n2, i2.i = u2, r$1.__h.push(i2));
}
function F(n2) {
  return o = 5, q(function() {
    return { current: n2 };
  }, []);
}
function q(n2, r2) {
  var u2 = h(t++, 7);
  return C(u2.__H, r2) ? (u2.__V = n2(), u2.i = r2, u2.__h = n2, u2.__V) : u2.__;
}
function x(n2, t2) {
  return o = 8, q(function() {
    return n2;
  }, t2);
}
function j() {
  for (var n2; n2 = f.shift(); )
    if (n2.__P && n2.__H)
      try {
        n2.__H.__h.forEach(z), n2.__H.__h.forEach(B), n2.__H.__h = [];
      } catch (t2) {
        n2.__H.__h = [], e.__e(t2, n2.__v);
      }
}
e.__b = function(n2) {
  r$1 = null, a && a(n2);
}, e.__ = function(n2, t2) {
  n2 && t2.__k && t2.__k.__m && (n2.__m = t2.__k.__m), d && d(n2, t2);
}, e.__r = function(n2) {
  v && v(n2), t = 0;
  var i2 = (r$1 = n2.__c).__H;
  i2 && (u === r$1 ? (i2.__h = [], r$1.__h = [], i2.__.forEach(function(n3) {
    n3.__N && (n3.__ = n3.__N), n3.__V = c, n3.__N = n3.i = void 0;
  })) : (i2.__h.forEach(z), i2.__h.forEach(B), i2.__h = [], t = 0)), u = r$1;
}, e.diffed = function(n2) {
  l && l(n2);
  var t2 = n2.__c;
  t2 && t2.__H && (t2.__H.__h.length && (1 !== f.push(t2) && i === e.requestAnimationFrame || ((i = e.requestAnimationFrame) || w)(j)), t2.__H.__.forEach(function(n3) {
    n3.i && (n3.__H = n3.i), n3.__V !== c && (n3.__ = n3.__V), n3.i = void 0, n3.__V = c;
  })), u = r$1 = null;
}, e.__c = function(n2, t2) {
  t2.some(function(n3) {
    try {
      n3.__h.forEach(z), n3.__h = n3.__h.filter(function(n4) {
        return !n4.__ || B(n4);
      });
    } catch (r2) {
      t2.some(function(n4) {
        n4.__h && (n4.__h = []);
      }), t2 = [], e.__e(r2, n3.__v);
    }
  }), m && m(n2, t2);
}, e.unmount = function(n2) {
  s && s(n2);
  var t2, r2 = n2.__c;
  r2 && r2.__H && (r2.__H.__.forEach(function(n3) {
    try {
      z(n3);
    } catch (n4) {
      t2 = n4;
    }
  }), r2.__H = void 0, t2 && e.__e(t2, r2.__v));
};
var k = "function" == typeof requestAnimationFrame;
function w(n2) {
  var t2, r2 = function() {
    clearTimeout(u2), k && cancelAnimationFrame(t2), setTimeout(n2);
  }, u2 = setTimeout(r2, 100);
  k && (t2 = requestAnimationFrame(r2));
}
function z(n2) {
  var t2 = r$1, u2 = n2.__c;
  "function" == typeof u2 && (n2.__c = void 0, u2()), r$1 = t2;
}
function B(n2) {
  var t2 = r$1;
  n2.__c = n2.__(), r$1 = t2;
}
function C(n2, t2) {
  return !n2 || n2.length !== t2.length || t2.some(function(t3, r2) {
    return t3 !== n2[r2];
  });
}
function D(n2, t2) {
  return "function" == typeof t2 ? t2(n2) : t2;
}
function r(e2) {
  var t2, f2, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2)
    n2 += e2;
  else if ("object" == typeof e2)
    if (Array.isArray(e2)) {
      var o2 = e2.length;
      for (t2 = 0; t2 < o2; t2++)
        e2[t2] && (f2 = r(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
    } else
      for (f2 in e2)
        e2[f2] && (n2 && (n2 += " "), n2 += f2);
  return n2;
}
function clsx() {
  for (var e2, t2, f2 = 0, n2 = "", o2 = arguments.length; f2 < o2; f2++)
    (e2 = arguments[f2]) && (t2 = r(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
function PopupMenuItem(props) {
  const {
    entry,
    selected,
    onMouseEnter,
    onMouseLeave,
    onAction
  } = props;
  return m$1`
    <li
      class=${clsx("entry", { selected })}
      data-id=${entry.id}
      title=${entry.title || entry.label}
      tabIndex="0"
      onClick=${onAction}
      onFocus=${onMouseEnter}
      onBlur=${onMouseLeave}
      onMouseEnter=${onMouseEnter}
      onMouseLeave=${onMouseLeave}
      onDragStart=${(event2) => onAction(event2, entry, "dragstart")}
      aria-role="button"
      draggable=${true}
    >
      <div class="djs-popup-entry-content">
        <span
          class=${clsx("djs-popup-entry-name", entry.className)}
        >
          ${entry.imageUrl && m$1`<img class="djs-popup-entry-icon" src=${entry.imageUrl} alt="" />` || entry.imageHtml && m$1`<div class="djs-popup-entry-icon" dangerouslySetInnerHTML=${{ __html: entry.imageHtml }} />`}

          ${entry.label ? m$1`
            <span class="djs-popup-label">
              ${entry.label}
            </span>
          ` : null}
        </span>
        ${entry.description && m$1`
          <span
            class="djs-popup-entry-description"
            title=${entry.description}
          >
            ${entry.description}
          </span>
        `}
      </div>
      ${entry.documentationRef && m$1`
        <div class="djs-popup-entry-docs">
          <a
            href="${entry.documentationRef}"
            onClick=${(event2) => event2.stopPropagation()}
            title="Open element documentation"
            target="_blank"
            rel="noopener"
          >
            <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path fill-rule="evenodd" clip-rule="evenodd" d="M10.6368 10.6375V5.91761H11.9995V10.6382C11.9995 10.9973 11.8623 11.3141 11.5878 11.5885C11.3134 11.863 10.9966 12.0002 10.6375 12.0002H1.36266C0.982345 12.0002 0.660159 11.8681 0.396102 11.6041C0.132044 11.34 1.52588e-05 11.0178 1.52588e-05 10.6375V1.36267C1.52588e-05 0.98236 0.132044 0.660173 0.396102 0.396116C0.660159 0.132058 0.982345 2.95639e-05 1.36266 2.95639e-05H5.91624V1.36267H1.36266V10.6375H10.6368ZM12 0H7.2794L7.27873 1.36197H9.68701L3.06507 7.98391L4.01541 8.93425L10.6373 2.31231V4.72059H12V0Z" fill="#818798"/>
            </svg>
          </a>
        </div>
      `}
    </li>
  `;
}
function PopupMenuList(props) {
  const {
    selectedEntry,
    setSelectedEntry,
    entries,
    ...restProps
  } = props;
  const resultsRef = F();
  const groups = q(() => groupEntries(entries), [entries]);
  A(() => {
    const containerEl = resultsRef.current;
    if (!containerEl)
      return;
    const selectedEl = containerEl.querySelector(".selected");
    if (selectedEl) {
      scrollIntoView(selectedEl);
    }
  }, [selectedEntry]);
  return m$1`
    <div class="djs-popup-results" ref=${resultsRef}>
      ${groups.map((group) => m$1`
        ${group.name && m$1`
          <div key=${group.id} class="entry-header" title=${group.name}>
            ${group.name}
          </div>
        `}
        <ul class="djs-popup-group" data-group=${group.id}>
          ${group.entries.map((entry) => m$1`
            <${PopupMenuItem}
              key=${entry.id}
              entry=${entry}
              selected=${entry === selectedEntry}
              onMouseEnter=${() => setSelectedEntry(entry)}
              onMouseLeave=${() => setSelectedEntry(null)}
              ...${restProps}
            />
          `)}
        </ul>
      `)}
    </div>
  `;
}
function groupEntries(entries) {
  const groups = [];
  const getGroup = (group) => groups.find((elem) => group.id === elem.id);
  const containsGroup = (group) => !!getGroup(group);
  const formatGroup = (group) => typeof group === "string" ? { id: group } : group;
  entries.forEach((entry) => {
    const group = entry.group ? formatGroup(entry.group) : { id: "default" };
    if (!containsGroup(group)) {
      groups.push({ ...group, entries: [entry] });
    } else {
      getGroup(group).entries.push(entry);
    }
  });
  return groups;
}
function scrollIntoView(el) {
  if (typeof el.scrollIntoViewIfNeeded === "function") {
    el.scrollIntoViewIfNeeded();
  } else {
    el.scrollIntoView({
      scrollMode: "if-needed",
      block: "nearest"
    });
  }
}
function PopupMenuComponent(props) {
  const {
    onClose,
    onSelect,
    className,
    headerEntries,
    position,
    title,
    width,
    scale,
    search,
    emptyPlaceholder,
    entries: originalEntries,
    onOpened,
    onClosed
  } = props;
  const searchable = q(() => {
    if (!isDefined(search)) {
      return false;
    }
    return originalEntries.length > 5;
  }, [search, originalEntries]);
  const [value, setValue] = p("");
  const filterEntries = x((originalEntries2, value2) => {
    if (!searchable) {
      return originalEntries2;
    }
    const filter2 = (entry) => {
      if (!value2) {
        return (entry.rank || 0) >= 0;
      }
      if (entry.searchable === false) {
        return false;
      }
      const searchableFields = [
        entry.description || "",
        entry.label || "",
        entry.search || ""
      ].map((string) => string.toLowerCase());
      return value2.toLowerCase().split(/\s/g).every((word) => searchableFields.some((field) => field.includes(word)));
    };
    return originalEntries2.filter(filter2);
  }, [searchable]);
  const [entries, setEntries] = p(filterEntries(originalEntries, value));
  const [selectedEntry, setSelectedEntry] = p(entries[0]);
  const updateEntries = x((newEntries) => {
    if (!selectedEntry || !newEntries.includes(selectedEntry)) {
      setSelectedEntry(newEntries[0]);
    }
    setEntries(newEntries);
  }, [selectedEntry, setEntries, setSelectedEntry]);
  _(() => {
    updateEntries(filterEntries(originalEntries, value));
  }, [value, originalEntries]);
  const keyboardSelect = x((direction) => {
    const idx = entries.indexOf(selectedEntry);
    let nextIdx = idx + direction;
    if (nextIdx < 0) {
      nextIdx = entries.length - 1;
    }
    if (nextIdx >= entries.length) {
      nextIdx = 0;
    }
    setSelectedEntry(entries[nextIdx]);
  }, [entries, selectedEntry, setSelectedEntry]);
  const handleKeyDown = x((event2) => {
    if (event2.key === "Enter" && selectedEntry) {
      return onSelect(event2, selectedEntry);
    }
    if (event2.key === "ArrowUp") {
      keyboardSelect(-1);
      return event2.preventDefault();
    }
    if (event2.key === "ArrowDown") {
      keyboardSelect(1);
      return event2.preventDefault();
    }
  }, [onSelect, selectedEntry, keyboardSelect]);
  const handleKey = x((event2) => {
    if (matches(event2.target, "input")) {
      setValue(() => event2.target.value);
    }
  }, [setValue]);
  _(() => {
    onOpened();
    return () => {
      onClosed();
    };
  }, []);
  const displayHeader = q(() => title || headerEntries.length > 0, [title, headerEntries]);
  return m$1`
    <${PopupMenuWrapper}
      onClose=${onClose}
      onKeyup=${handleKey}
      onKeydown=${handleKeyDown}
      className=${className}
      position=${position}
      width=${width}
      scale=${scale}
    >
      ${displayHeader && m$1`
        <div class="djs-popup-header">
          <h3 class="djs-popup-title" title=${title}>${title}</h3>
          ${headerEntries.map((entry) => m$1`
            <${entry.action ? "button" : "span"}
              class=${getHeaderClasses(entry, entry === selectedEntry)}
              onClick=${(event2) => onSelect(event2, entry)}
              title=${entry.title || entry.label}
              data-id=${entry.id}
              onMouseEnter=${() => setSelectedEntry(entry)}
              onMouseLeave=${() => setSelectedEntry(null)}
              onFocus=${() => setSelectedEntry(entry)}
              onBlur=${() => setSelectedEntry(null)}
            >
            ${entry.imageUrl && m$1`<img class="djs-popup-entry-icon" src=${entry.imageUrl} alt="" />` || entry.imageHtml && m$1`<div class="djs-popup-entry-icon" dangerouslySetInnerHTML=${{ __html: entry.imageHtml }} />`}

              ${entry.label ? m$1`
                <span class="djs-popup-label">${entry.label}</span>
              ` : null}
            </${entry.action ? "button" : "span"}>
          `)}
        </div>
      `}
      ${originalEntries.length > 0 && m$1`
        <div class="djs-popup-body">

          ${searchable && m$1`
          <div class="djs-popup-search">
            <svg class="djs-popup-search-icon" width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path fill-rule="evenodd" clip-rule="evenodd" d="M9.0325 8.5H9.625L13.3675 12.25L12.25 13.3675L8.5 9.625V9.0325L8.2975 8.8225C7.4425 9.5575 6.3325 10 5.125 10C2.4325 10 0.25 7.8175 0.25 5.125C0.25 2.4325 2.4325 0.25 5.125 0.25C7.8175 0.25 10 2.4325 10 5.125C10 6.3325 9.5575 7.4425 8.8225 8.2975L9.0325 8.5ZM1.75 5.125C1.75 6.9925 3.2575 8.5 5.125 8.5C6.9925 8.5 8.5 6.9925 8.5 5.125C8.5 3.2575 6.9925 1.75 5.125 1.75C3.2575 1.75 1.75 3.2575 1.75 5.125Z" fill="#22242A"/>
            </svg>
            <input type="text" aria-label="${title}" />
          </div>
          `}

          <${PopupMenuList}
            entries=${entries}
            selectedEntry=${selectedEntry}
            setSelectedEntry=${setSelectedEntry}
            onAction=${onSelect}
          />
        </div>
      `}
    ${emptyPlaceholder && entries.length === 0 && m$1`
      <div class="djs-popup-no-results">${isFunction(emptyPlaceholder) ? emptyPlaceholder(value) : emptyPlaceholder}</div>
    `}
    </${PopupMenuWrapper}>
  `;
}
function PopupMenuWrapper(props) {
  const {
    onClose,
    onKeydown,
    onKeyup,
    className,
    children,
    position: positionGetter
  } = props;
  const popupRef = F();
  A(() => {
    if (typeof positionGetter !== "function") {
      return;
    }
    const popupEl = popupRef.current;
    const position = positionGetter(popupEl);
    popupEl.style.left = `${position.x}px`;
    popupEl.style.top = `${position.y}px`;
  }, [popupRef.current, positionGetter]);
  A(() => {
    const popupEl = popupRef.current;
    if (!popupEl) {
      return;
    }
    const inputEl = popupEl.querySelector("input");
    (inputEl || popupEl).focus();
  }, []);
  _(() => {
    const handleKeyDown = (event2) => {
      if (event2.key === "Escape") {
        event2.preventDefault();
        return onClose();
      }
    };
    const handleClick = (event2) => {
      const popup = closest(event2.target, ".djs-popup", true);
      if (popup) {
        return;
      }
      return onClose();
    };
    document.documentElement.addEventListener("keydown", handleKeyDown);
    document.body.addEventListener("click", handleClick);
    return () => {
      document.documentElement.removeEventListener("keydown", handleKeyDown);
      document.body.removeEventListener("click", handleClick);
    };
  }, []);
  return m$1`
    <div
      class=${clsx("djs-popup", className)}
      style=${getPopupStyle(props)}
      onKeydown=${onKeydown}
      onKeyup=${onKeyup}
      ref=${popupRef}
      tabIndex="-1"
    >
      ${children}
    </div>
  `;
}
function getPopupStyle(props) {
  return {
    transform: `scale(${props.scale})`,
    width: `${props.width}px`,
    "transform-origin": "top left"
  };
}
function getHeaderClasses(entry, selected) {
  return clsx(
    "entry",
    entry.className,
    entry.active ? "active" : "",
    entry.disabled ? "disabled" : "",
    selected ? "selected" : ""
  );
}
var DATA_REF = "data-id";
var CLOSE_EVENTS = [
  "contextPad.close",
  "canvas.viewbox.changing",
  "commandStack.changed"
];
var DEFAULT_PRIORITY$1 = 1e3;
function PopupMenu(config, eventBus, canvas) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._current = null;
  var scale = isDefined(config && config.scale) ? config.scale : {
    min: 1,
    max: 1.5
  };
  this._config = {
    scale
  };
  eventBus.on("diagram.destroy", () => {
    this.close();
  });
  eventBus.on("element.changed", (event2) => {
    const element = this.isOpen() && this._current.target;
    if (event2.element === element) {
      this.refresh();
    }
  });
}
PopupMenu.$inject = [
  "config.popupMenu",
  "eventBus",
  "canvas"
];
PopupMenu.prototype._render = function() {
  const {
    position: _position,
    providerId: className,
    entries,
    headerEntries,
    emptyPlaceholder,
    options
  } = this._current;
  const entriesArray = Object.entries(entries).map(
    ([key, value]) => ({ id: key, ...value })
  );
  const headerEntriesArray = Object.entries(headerEntries).map(
    ([key, value]) => ({ id: key, ...value })
  );
  const position = _position && ((container) => this._ensureVisible(container, _position));
  const scale = this._updateScale(this._current.container);
  const onClose = (result) => this.close(result);
  const onSelect = (event2, entry, action) => this.trigger(event2, entry, action);
  D$1(
    m$1`
      <${PopupMenuComponent}
        onClose=${onClose}
        onSelect=${onSelect}
        position=${position}
        className=${className}
        entries=${entriesArray}
        headerEntries=${headerEntriesArray}
        emptyPlaceholder=${emptyPlaceholder}
        scale=${scale}
        onOpened=${this._onOpened.bind(this)}
        onClosed=${this._onClosed.bind(this)}
        ...${{ ...options }}
      />
    `,
    this._current.container
  );
};
PopupMenu.prototype.open = function(target, providerId, position, options) {
  if (!target) {
    throw new Error("target is missing");
  }
  if (!providerId) {
    throw new Error("providers for <" + providerId + "> not found");
  }
  if (!position) {
    throw new Error("position is missing");
  }
  if (this.isOpen()) {
    this.close();
  }
  const {
    entries,
    headerEntries,
    emptyPlaceholder
  } = this._getContext(target, providerId);
  this._current = {
    position,
    providerId,
    target,
    entries,
    headerEntries,
    emptyPlaceholder,
    container: this._createContainer({ provider: providerId }),
    options
  };
  this._emit("open");
  this._bindAutoClose();
  this._render();
};
PopupMenu.prototype.refresh = function() {
  if (!this.isOpen()) {
    return;
  }
  const {
    target,
    providerId
  } = this._current;
  const {
    entries,
    headerEntries,
    emptyPlaceholder
  } = this._getContext(target, providerId);
  this._current = {
    ...this._current,
    entries,
    headerEntries,
    emptyPlaceholder
  };
  this._emit("refresh");
  this._render();
};
PopupMenu.prototype._getContext = function(target, provider) {
  const providers = this._getProviders(provider);
  if (!providers || !providers.length) {
    throw new Error("provider for <" + provider + "> not found");
  }
  const entries = this._getEntries(target, providers);
  const headerEntries = this._getHeaderEntries(target, providers);
  const emptyPlaceholder = this._getEmptyPlaceholder(providers);
  return {
    entries,
    headerEntries,
    emptyPlaceholder,
    empty: !(Object.keys(entries).length || Object.keys(headerEntries).length)
  };
};
PopupMenu.prototype.close = function() {
  if (!this.isOpen()) {
    return;
  }
  this._emit("close");
  this.reset();
  this._current = null;
};
PopupMenu.prototype.reset = function() {
  const container = this._current.container;
  D$1(null, container);
  remove$2(container);
};
PopupMenu.prototype._emit = function(event2, payload) {
  this._eventBus.fire(`popupMenu.${event2}`, payload);
};
PopupMenu.prototype._onOpened = function() {
  this._emit("opened");
};
PopupMenu.prototype._onClosed = function() {
  this._emit("closed");
};
PopupMenu.prototype._createContainer = function(config) {
  var canvas = this._canvas, parent = canvas.getContainer();
  const container = domify$1(`<div class="djs-popup-parent djs-scrollable" data-popup=${config.provider}></div>`);
  parent.appendChild(container);
  return container;
};
PopupMenu.prototype._bindAutoClose = function() {
  this._eventBus.once(CLOSE_EVENTS, this.close, this);
};
PopupMenu.prototype._unbindAutoClose = function() {
  this._eventBus.off(CLOSE_EVENTS, this.close, this);
};
PopupMenu.prototype._updateScale = function() {
  var zoom2 = this._canvas.zoom();
  var scaleConfig = this._config.scale, minScale, maxScale, scale = zoom2;
  if (scaleConfig !== true) {
    if (scaleConfig === false) {
      minScale = 1;
      maxScale = 1;
    } else {
      minScale = scaleConfig.min;
      maxScale = scaleConfig.max;
    }
    if (isDefined(minScale) && zoom2 < minScale) {
      scale = minScale;
    }
    if (isDefined(maxScale) && zoom2 > maxScale) {
      scale = maxScale;
    }
  }
  return scale;
};
PopupMenu.prototype._ensureVisible = function(container, position) {
  var documentBounds = document.documentElement.getBoundingClientRect();
  var containerBounds = container.getBoundingClientRect();
  var overAxis = {}, left = position.x, top = position.y;
  if (position.x + containerBounds.width > documentBounds.width) {
    overAxis.x = true;
  }
  if (position.y + containerBounds.height > documentBounds.height) {
    overAxis.y = true;
  }
  if (overAxis.x && overAxis.y) {
    left = position.x - containerBounds.width;
    top = position.y - containerBounds.height;
  } else if (overAxis.x) {
    left = position.x - containerBounds.width;
    top = position.y;
  } else if (overAxis.y && position.y < containerBounds.height) {
    left = position.x;
    top = 10;
  } else if (overAxis.y) {
    left = position.x;
    top = position.y - containerBounds.height;
  }
  if (position.y < documentBounds.top) {
    top = position.y + containerBounds.height;
  }
  return {
    x: left,
    y: top
  };
};
PopupMenu.prototype.isEmpty = function(target, providerId) {
  if (!target) {
    throw new Error("target is missing");
  }
  if (!providerId) {
    throw new Error("provider ID is missing");
  }
  const providers = this._getProviders(providerId);
  if (!providers || !providers.length) {
    return true;
  }
  return this._getContext(target, providerId).empty;
};
PopupMenu.prototype.registerProvider = function(id, priority, provider) {
  if (!provider) {
    provider = priority;
    priority = DEFAULT_PRIORITY$1;
  }
  this._eventBus.on("popupMenu.getProviders." + id, priority, function(event2) {
    event2.providers.push(provider);
  });
};
PopupMenu.prototype._getProviders = function(id) {
  var event2 = this._eventBus.createEvent({
    type: "popupMenu.getProviders." + id,
    providers: []
  });
  this._eventBus.fire(event2);
  return event2.providers;
};
PopupMenu.prototype._getEntries = function(target, providers) {
  var entries = {};
  forEach$1(providers, function(provider) {
    if (!provider.getPopupMenuEntries) {
      forEach$1(provider.getEntries(target), function(entry) {
        var id = entry.id;
        if (!id) {
          throw new Error("entry ID is missing");
        }
        entries[id] = omit(entry, ["id"]);
      });
      return;
    }
    var entriesOrUpdater = provider.getPopupMenuEntries(target);
    if (isFunction(entriesOrUpdater)) {
      entries = entriesOrUpdater(entries);
    } else {
      forEach$1(entriesOrUpdater, function(entry, id) {
        entries[id] = entry;
      });
    }
  });
  return entries;
};
PopupMenu.prototype._getHeaderEntries = function(target, providers) {
  var entries = {};
  forEach$1(providers, function(provider) {
    if (!provider.getPopupMenuHeaderEntries) {
      if (!provider.getHeaderEntries) {
        return;
      }
      forEach$1(provider.getHeaderEntries(target), function(entry) {
        var id = entry.id;
        if (!id) {
          throw new Error("entry ID is missing");
        }
        entries[id] = omit(entry, ["id"]);
      });
      return;
    }
    var entriesOrUpdater = provider.getPopupMenuHeaderEntries(target);
    if (isFunction(entriesOrUpdater)) {
      entries = entriesOrUpdater(entries);
    } else {
      forEach$1(entriesOrUpdater, function(entry, id) {
        entries[id] = entry;
      });
    }
  });
  return entries;
};
PopupMenu.prototype._getEmptyPlaceholder = function(providers) {
  const provider = providers.find(
    (provider2) => isFunction(provider2.getEmptyPlaceholder)
  );
  return provider && provider.getEmptyPlaceholder();
};
PopupMenu.prototype.isOpen = function() {
  return !!this._current;
};
PopupMenu.prototype.trigger = function(event2, entry, action = "click") {
  event2.preventDefault();
  if (!entry) {
    let element = closest(event2.delegateTarget || event2.target, ".entry", true);
    let entryId = attr$1(element, DATA_REF);
    entry = { id: entryId, ...this._getEntry(entryId) };
  }
  const handler = entry.action;
  if (this._emit("trigger", { entry, event: event2 }) === false) {
    return;
  }
  if (isFunction(handler)) {
    if (action === "click") {
      return handler(event2, entry);
    }
  } else {
    if (handler[action]) {
      return handler[action](event2, entry);
    }
  }
};
PopupMenu.prototype._getEntry = function(entryId) {
  var entry = this._current.entries[entryId] || this._current.headerEntries[entryId];
  if (!entry) {
    throw new Error("entry not found");
  }
  return entry;
};
const PopupMenuModule$1 = {
  __init__: ["popupMenu"],
  popupMenu: ["type", PopupMenu]
};
var icons$1 = {
  align: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2000 2000">
              <line x1="200" y1="150" x2="200" y2="1850" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
              <rect x="500" y="150" width="1300" height="700" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
              <rect x="500" y="1150" width="700" height="700" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`,
  bottom: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
            <line x1="150" y1="1650" x2="1650" y2="1650" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
            <rect x="150" y="350" width="600" height="1300" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
            <rect x="1050" y="850" width="600" height="800" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`,
  center: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
            <line x1="900" y1="150" x2="900" y2="1650" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
            <rect x="250" y="150" width="1300" height="600" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
            <rect x="500" y="1050" width="800" height="600" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`,
  left: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
            <line x1="100" y1="150" x2="100" y2="1650" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
            <rect x="100" y="150" width="1300" height="600" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
            <rect x="100" y="1050" width="800" height="600" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`,
  right: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
            <line x1="1650" y1="150" x2="1650" y2="1650" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
            <rect x="350" y="150" width="1300" height="600" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
            <rect x="850" y="1050" width="800" height="600" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`,
  top: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
            <line x1="150" y1="150" x2="1650" y2="150" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
            <rect x="150" y="150" width="600" height="1300" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
            <rect x="1050" y="150" width="600" height="800" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`,
  middle: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
            <line x1="150" y1="900" x2="1650" y2="900" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
            <rect x="150" y="250" width="600" height="1300" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
            <rect x="1050" y="500" width="600" height="800" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`
};
const ICONS$1 = icons$1;
var LOW_PRIORITY$l = 900;
function AlignElementsContextPadProvider(contextPad, popupMenu, translate2, canvas) {
  contextPad.registerProvider(LOW_PRIORITY$l, this);
  this._contextPad = contextPad;
  this._popupMenu = popupMenu;
  this._translate = translate2;
  this._canvas = canvas;
}
AlignElementsContextPadProvider.$inject = [
  "contextPad",
  "popupMenu",
  "translate",
  "canvas"
];
AlignElementsContextPadProvider.prototype.getMultiElementContextPadEntries = function(elements) {
  var actions = {};
  if (this._isAllowed(elements)) {
    assign$1(actions, this._getEntries(elements));
  }
  return actions;
};
AlignElementsContextPadProvider.prototype._isAllowed = function(elements) {
  return !this._popupMenu.isEmpty(elements, "align-elements");
};
AlignElementsContextPadProvider.prototype._getEntries = function() {
  var self2 = this;
  return {
    "align-elements": {
      group: "align-elements",
      title: self2._translate("Align elements"),
      html: `<div class="entry">${ICONS$1["align"]}</div>`,
      action: {
        click: function(event2, target) {
          var position = self2._getMenuPosition(target);
          assign$1(position, {
            cursor: {
              x: event2.x,
              y: event2.y
            }
          });
          self2._popupMenu.open(target, "align-elements", position);
        }
      }
    }
  };
};
AlignElementsContextPadProvider.prototype._getMenuPosition = function(elements) {
  var Y_OFFSET = 5;
  var pad = this._contextPad.getPad(elements).html;
  var padRect = pad.getBoundingClientRect();
  var pos = {
    x: padRect.left,
    y: padRect.bottom + Y_OFFSET
  };
  return pos;
};
var ALIGNMENT_OPTIONS = [
  "left",
  "center",
  "right",
  "top",
  "middle",
  "bottom"
];
function AlignElementsMenuProvider(popupMenu, alignElements, translate2, rules) {
  this._alignElements = alignElements;
  this._translate = translate2;
  this._popupMenu = popupMenu;
  this._rules = rules;
  popupMenu.registerProvider("align-elements", this);
}
AlignElementsMenuProvider.$inject = [
  "popupMenu",
  "alignElements",
  "translate",
  "rules"
];
AlignElementsMenuProvider.prototype.getPopupMenuEntries = function(target) {
  var entries = {};
  if (this._isAllowed(target)) {
    assign$1(entries, this._getEntries(target));
  }
  return entries;
};
AlignElementsMenuProvider.prototype._isAllowed = function(target) {
  return this._rules.allowed("elements.align", { elements: target });
};
AlignElementsMenuProvider.prototype._getEntries = function(target) {
  var alignElements = this._alignElements, translate2 = this._translate, popupMenu = this._popupMenu;
  var entries = {};
  forEach$1(ALIGNMENT_OPTIONS, function(alignment) {
    entries["align-elements-" + alignment] = {
      group: "align",
      title: translate2("Align elements " + alignment),
      className: "bjs-align-elements-menu-entry",
      imageHtml: ICONS$1[alignment],
      action: function() {
        alignElements.trigger(target, alignment);
        popupMenu.close();
      }
    };
  });
  return entries;
};
function RuleProvider(eventBus) {
  CommandInterceptor.call(this, eventBus);
  this.init();
}
RuleProvider.$inject = ["eventBus"];
e$3(RuleProvider, CommandInterceptor);
RuleProvider.prototype.addRule = function(actions, priority, fn) {
  var self2 = this;
  if (typeof actions === "string") {
    actions = [actions];
  }
  actions.forEach(function(action) {
    self2.canExecute(action, priority, function(context, action2, event2) {
      return fn(context);
    }, true);
  });
};
RuleProvider.prototype.init = function() {
};
function BpmnAlignElements(eventBus) {
  RuleProvider.call(this, eventBus);
}
BpmnAlignElements.$inject = ["eventBus"];
e$3(BpmnAlignElements, RuleProvider);
BpmnAlignElements.prototype.init = function() {
  this.addRule("elements.align", function(context) {
    var elements = context.elements;
    var filteredElements = filter(elements, function(element) {
      return !(element.waypoints || element.host || element.labelTarget);
    });
    filteredElements = getParents$1(filteredElements);
    if (filteredElements.length < 2) {
      return false;
    }
    return filteredElements;
  });
};
const AlignElementsModule = {
  __depends__: [
    AlignElementsModule$1,
    ContextPadModule$1,
    PopupMenuModule$1
  ],
  __init__: [
    "alignElementsContextPadProvider",
    "alignElementsMenuProvider",
    "bpmnAlignElements"
  ],
  alignElementsContextPadProvider: ["type", AlignElementsContextPadProvider],
  alignElementsMenuProvider: ["type", AlignElementsMenuProvider],
  bpmnAlignElements: ["type", BpmnAlignElements]
};
var PLACEMENT_DETECTION_PAD = 10;
var DEFAULT_DISTANCE = 50;
var DEFAULT_MAX_DISTANCE = 250;
function findFreePosition(source, element, position, getNextPosition) {
  var connectedAtPosition;
  while (connectedAtPosition = getConnectedAtPosition(source, position, element)) {
    position = getNextPosition(element, position, connectedAtPosition);
  }
  return position;
}
function generateGetNextPosition(nextPositionDirection) {
  return function(element, previousPosition, connectedAtPosition) {
    var nextPosition = {
      x: previousPosition.x,
      y: previousPosition.y
    };
    ["x", "y"].forEach(function(axis) {
      var nextPositionDirectionForAxis = nextPositionDirection[axis];
      if (!nextPositionDirectionForAxis) {
        return;
      }
      var dimension = axis === "x" ? "width" : "height";
      var margin = nextPositionDirectionForAxis.margin, minDistance = nextPositionDirectionForAxis.minDistance;
      if (margin < 0) {
        nextPosition[axis] = Math.min(
          connectedAtPosition[axis] + margin - element[dimension] / 2,
          previousPosition[axis] - minDistance + margin
        );
      } else {
        nextPosition[axis] = Math.max(
          connectedAtPosition[axis] + connectedAtPosition[dimension] + margin + element[dimension] / 2,
          previousPosition[axis] + minDistance + margin
        );
      }
    });
    return nextPosition;
  };
}
function getConnectedAtPosition(source, position, element) {
  var bounds = {
    x: position.x - element.width / 2,
    y: position.y - element.height / 2,
    width: element.width,
    height: element.height
  };
  var closure = getAutoPlaceClosure(source);
  return find(closure, function(target) {
    if (target === element) {
      return false;
    }
    var orientation = getOrientation(target, bounds, PLACEMENT_DETECTION_PAD);
    return orientation === "intersect";
  });
}
function getConnectedDistance(source, hints) {
  if (!hints) {
    hints = {};
  }
  function getDefaultWeight(connection) {
    return connection.source === source ? 1 : -1;
  }
  var defaultDistance = hints.defaultDistance || DEFAULT_DISTANCE, direction = hints.direction || "e", filter2 = hints.filter, getWeight = hints.getWeight || getDefaultWeight, maxDistance = hints.maxDistance || DEFAULT_MAX_DISTANCE, reference = hints.reference || "start";
  if (!filter2) {
    filter2 = noneFilter;
  }
  function getDistance2(a2, b2) {
    if (direction === "n") {
      if (reference === "start") {
        return asTRBL(a2).top - asTRBL(b2).bottom;
      } else if (reference === "center") {
        return asTRBL(a2).top - getMid(b2).y;
      } else {
        return asTRBL(a2).top - asTRBL(b2).top;
      }
    } else if (direction === "w") {
      if (reference === "start") {
        return asTRBL(a2).left - asTRBL(b2).right;
      } else if (reference === "center") {
        return asTRBL(a2).left - getMid(b2).x;
      } else {
        return asTRBL(a2).left - asTRBL(b2).left;
      }
    } else if (direction === "s") {
      if (reference === "start") {
        return asTRBL(b2).top - asTRBL(a2).bottom;
      } else if (reference === "center") {
        return getMid(b2).y - asTRBL(a2).bottom;
      } else {
        return asTRBL(b2).bottom - asTRBL(a2).bottom;
      }
    } else {
      if (reference === "start") {
        return asTRBL(b2).left - asTRBL(a2).right;
      } else if (reference === "center") {
        return getMid(b2).x - asTRBL(a2).right;
      } else {
        return asTRBL(b2).right - asTRBL(a2).right;
      }
    }
  }
  var sourcesDistances = source.incoming.filter(filter2).map(function(connection) {
    var weight = getWeight(connection);
    var distance2 = weight < 0 ? getDistance2(connection.source, source) : getDistance2(source, connection.source);
    return {
      id: connection.source.id,
      distance: distance2,
      weight
    };
  });
  var targetsDistances = source.outgoing.filter(filter2).map(function(connection) {
    var weight = getWeight(connection);
    var distance2 = weight > 0 ? getDistance2(source, connection.target) : getDistance2(connection.target, source);
    return {
      id: connection.target.id,
      distance: distance2,
      weight
    };
  });
  var distances = sourcesDistances.concat(targetsDistances).reduce(function(accumulator, currentValue) {
    accumulator[currentValue.id + "__weight_" + currentValue.weight] = currentValue;
    return accumulator;
  }, {});
  var distancesGrouped = reduce(distances, function(accumulator, currentValue) {
    var distance2 = currentValue.distance, weight = currentValue.weight;
    if (distance2 < 0 || distance2 > maxDistance) {
      return accumulator;
    }
    if (!accumulator[String(distance2)]) {
      accumulator[String(distance2)] = 0;
    }
    accumulator[String(distance2)] += 1 * weight;
    if (!accumulator.distance || accumulator[accumulator.distance] < accumulator[String(distance2)]) {
      accumulator.distance = distance2;
    }
    return accumulator;
  }, {});
  return distancesGrouped.distance || defaultDistance;
}
function getAutoPlaceClosure(source) {
  var allConnected = getConnected(source);
  if (source.host) {
    allConnected = allConnected.concat(getConnected(source.host));
  }
  if (source.attachers) {
    allConnected = allConnected.concat(source.attachers.reduce(function(shapes, attacher) {
      return shapes.concat(getConnected(attacher));
    }, []));
  }
  return allConnected;
}
function getConnected(element) {
  return getTargets(element).concat(getSources(element));
}
function getSources(shape) {
  return shape.incoming.map(function(connection) {
    return connection.source;
  });
}
function getTargets(shape) {
  return shape.outgoing.map(function(connection) {
    return connection.target;
  });
}
function noneFilter() {
  return true;
}
var LOW_PRIORITY$k = 100;
function AutoPlace$1(eventBus, modeling, canvas) {
  eventBus.on("autoPlace", LOW_PRIORITY$k, function(context) {
    var shape = context.shape, source = context.source;
    return getNewShapePosition$1(source, shape);
  });
  eventBus.on("autoPlace.end", function(event2) {
    canvas.scrollToElement(event2.shape);
  });
  this.append = function(source, shape, hints) {
    eventBus.fire("autoPlace.start", {
      source,
      shape
    });
    var position = eventBus.fire("autoPlace", {
      source,
      shape
    });
    var newShape = modeling.appendShape(source, shape, position, source.parent, hints);
    eventBus.fire("autoPlace.end", {
      source,
      shape: newShape
    });
    return newShape;
  };
}
AutoPlace$1.$inject = [
  "eventBus",
  "modeling",
  "canvas"
];
function getNewShapePosition$1(source, element, hints) {
  if (!hints) {
    hints = {};
  }
  var distance2 = hints.defaultDistance || DEFAULT_DISTANCE;
  var sourceMid = getMid(source), sourceTrbl = asTRBL(source);
  return {
    x: sourceTrbl.right + distance2 + element.width / 2,
    y: sourceMid.y
  };
}
function AutoPlaceSelectionBehavior(eventBus, selection) {
  eventBus.on("autoPlace.end", 500, function(e2) {
    selection.select(e2.shape);
  });
}
AutoPlaceSelectionBehavior.$inject = [
  "eventBus",
  "selection"
];
const AutoPlaceModule$1 = {
  __init__: ["autoPlaceSelectionBehavior"],
  autoPlace: ["type", AutoPlace$1],
  autoPlaceSelectionBehavior: ["type", AutoPlaceSelectionBehavior]
};
function getParent(element, anyType) {
  if (isString(anyType)) {
    anyType = [anyType];
  }
  while (element = element.parent) {
    if (isAny(element, anyType)) {
      return element;
    }
  }
  return null;
}
function getNewShapePosition(source, element) {
  if (is$1(element, "bpmn:TextAnnotation")) {
    return getTextAnnotationPosition(source, element);
  }
  if (isAny(element, ["bpmn:DataObjectReference", "bpmn:DataStoreReference"])) {
    return getDataElementPosition(source, element);
  }
  if (is$1(element, "bpmn:FlowNode")) {
    return getFlowNodePosition(source, element);
  }
}
function getFlowNodePosition(source, element) {
  var sourceTrbl = asTRBL(source);
  var sourceMid = getMid(source);
  var horizontalDistance = getConnectedDistance(source, {
    filter: function(connection) {
      return is$1(connection, "bpmn:SequenceFlow");
    }
  });
  var margin = 30, minDistance = 80, orientation = "left";
  if (is$1(source, "bpmn:BoundaryEvent")) {
    orientation = getOrientation(source, source.host, -25);
    if (orientation.indexOf("top") !== -1) {
      margin *= -1;
    }
  }
  var position = {
    x: sourceTrbl.right + horizontalDistance + element.width / 2,
    y: sourceMid.y + getVerticalDistance(orientation, minDistance)
  };
  var nextPositionDirection = {
    y: {
      margin,
      minDistance
    }
  };
  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));
}
function getVerticalDistance(orientation, minDistance) {
  if (orientation.includes("top")) {
    return -1 * minDistance;
  } else if (orientation.includes("bottom")) {
    return minDistance;
  } else {
    return 0;
  }
}
function getTextAnnotationPosition(source, element) {
  var sourceTrbl = asTRBL(source);
  var position = {
    x: sourceTrbl.right + element.width / 2,
    y: sourceTrbl.top - 50 - element.height / 2
  };
  if (isConnection(source)) {
    position = getMid(source);
    position.x += 100;
    position.y -= 50;
  }
  var nextPositionDirection = {
    y: {
      margin: -30,
      minDistance: 20
    }
  };
  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));
}
function getDataElementPosition(source, element) {
  var sourceTrbl = asTRBL(source);
  var position = {
    x: sourceTrbl.right - 10 + element.width / 2,
    y: sourceTrbl.bottom + 40 + element.width / 2
  };
  var nextPositionDirection = {
    x: {
      margin: 30,
      minDistance: 30
    }
  };
  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));
}
function AutoPlace(eventBus) {
  eventBus.on("autoPlace", function(context) {
    var shape = context.shape, source = context.source;
    return getNewShapePosition(source, shape);
  });
}
AutoPlace.$inject = ["eventBus"];
const AutoPlaceModule = {
  __depends__: [AutoPlaceModule$1],
  __init__: ["bpmnAutoPlace"],
  bpmnAutoPlace: ["type", AutoPlace]
};
function AutoResize(eventBus, elementRegistry, modeling, rules) {
  CommandInterceptor.call(this, eventBus);
  this._elementRegistry = elementRegistry;
  this._modeling = modeling;
  this._rules = rules;
  var self2 = this;
  this.postExecuted(["shape.create"], function(event2) {
    var context = event2.context, hints = context.hints || {}, shape = context.shape, parent = context.parent || context.newParent;
    if (hints.autoResize === false) {
      return;
    }
    self2._expand([shape], parent);
  });
  this.postExecuted(["elements.move"], function(event2) {
    var context = event2.context, elements = flatten(values(context.closure.topLevel)), hints = context.hints;
    var autoResize = hints ? hints.autoResize : true;
    if (autoResize === false) {
      return;
    }
    var expandings = groupBy(elements, function(element) {
      return element.parent.id;
    });
    forEach$1(expandings, function(elements2, parentId) {
      if (isArray$3(autoResize)) {
        elements2 = elements2.filter(function(element) {
          return find(autoResize, matchPattern({ id: element.id }));
        });
      }
      self2._expand(elements2, parentId);
    });
  });
  this.postExecuted(["shape.toggleCollapse"], function(event2) {
    var context = event2.context, hints = context.hints, shape = context.shape;
    if (hints && hints.autoResize === false) {
      return;
    }
    if (shape.collapsed) {
      return;
    }
    self2._expand(shape.children || [], shape);
  });
  this.postExecuted(["shape.resize"], function(event2) {
    var context = event2.context, hints = context.hints, shape = context.shape, parent = shape.parent;
    if (hints && hints.autoResize === false) {
      return;
    }
    if (parent) {
      self2._expand([shape], parent);
    }
  });
}
AutoResize.$inject = [
  "eventBus",
  "elementRegistry",
  "modeling",
  "rules"
];
e$3(AutoResize, CommandInterceptor);
AutoResize.prototype._getOptimalBounds = function(elements, target) {
  var offset = this.getOffset(target), padding = this.getPadding(target);
  var elementsTrbl = asTRBL(getBBox(elements)), targetTrbl = asTRBL(target);
  var newTrbl = {};
  if (elementsTrbl.top - targetTrbl.top < padding.top) {
    newTrbl.top = elementsTrbl.top - offset.top;
  }
  if (elementsTrbl.left - targetTrbl.left < padding.left) {
    newTrbl.left = elementsTrbl.left - offset.left;
  }
  if (targetTrbl.right - elementsTrbl.right < padding.right) {
    newTrbl.right = elementsTrbl.right + offset.right;
  }
  if (targetTrbl.bottom - elementsTrbl.bottom < padding.bottom) {
    newTrbl.bottom = elementsTrbl.bottom + offset.bottom;
  }
  return asBounds(assign$1({}, targetTrbl, newTrbl));
};
AutoResize.prototype._expand = function(elements, target) {
  if (typeof target === "string") {
    target = this._elementRegistry.get(target);
  }
  var allowed = this._rules.allowed("element.autoResize", {
    elements,
    target
  });
  if (!allowed) {
    return;
  }
  var newBounds = this._getOptimalBounds(elements, target);
  if (!boundsChanged$1(newBounds, target)) {
    return;
  }
  var resizeDirections = getResizeDirections(pick(target, ["x", "y", "width", "height"]), newBounds);
  this.resize(target, newBounds, {
    autoResize: resizeDirections
  });
  var parent = target.parent;
  if (parent) {
    this._expand([target], parent);
  }
};
AutoResize.prototype.getOffset = function(shape) {
  return { top: 60, bottom: 60, left: 100, right: 100 };
};
AutoResize.prototype.getPadding = function(shape) {
  return { top: 2, bottom: 2, left: 15, right: 15 };
};
AutoResize.prototype.resize = function(shape, newBounds, hints) {
  this._modeling.resizeShape(shape, newBounds, null, hints);
};
function boundsChanged$1(newBounds, oldBounds) {
  return newBounds.x !== oldBounds.x || newBounds.y !== oldBounds.y || newBounds.width !== oldBounds.width || newBounds.height !== oldBounds.height;
}
function getResizeDirections(oldBounds, newBounds) {
  var directions2 = "";
  oldBounds = asTRBL(oldBounds);
  newBounds = asTRBL(newBounds);
  if (oldBounds.top > newBounds.top) {
    directions2 = directions2.concat("n");
  }
  if (oldBounds.right < newBounds.right) {
    directions2 = directions2.concat("w");
  }
  if (oldBounds.bottom < newBounds.bottom) {
    directions2 = directions2.concat("s");
  }
  if (oldBounds.left > newBounds.left) {
    directions2 = directions2.concat("e");
  }
  return directions2;
}
function BpmnAutoResize(injector) {
  injector.invoke(AutoResize, this);
}
BpmnAutoResize.$inject = [
  "injector"
];
e$3(BpmnAutoResize, AutoResize);
BpmnAutoResize.prototype.resize = function(target, newBounds, hints) {
  if (is$1(target, "bpmn:Participant")) {
    this._modeling.resizeLane(target, newBounds, null, hints);
  } else {
    this._modeling.resizeShape(target, newBounds, null, hints);
  }
};
function AutoResizeProvider(eventBus) {
  RuleProvider.call(this, eventBus);
  var self2 = this;
  this.addRule("element.autoResize", function(context) {
    return self2.canResize(context.elements, context.target);
  });
}
AutoResizeProvider.$inject = ["eventBus"];
e$3(AutoResizeProvider, RuleProvider);
AutoResizeProvider.prototype.canResize = function(elements, target) {
  return false;
};
function BpmnAutoResizeProvider(eventBus, modeling) {
  AutoResizeProvider.call(this, eventBus);
  this._modeling = modeling;
}
e$3(BpmnAutoResizeProvider, AutoResizeProvider);
BpmnAutoResizeProvider.$inject = [
  "eventBus",
  "modeling"
];
BpmnAutoResizeProvider.prototype.canResize = function(elements, target) {
  if (is$1(target.di, "bpmndi:BPMNPlane")) {
    return false;
  }
  if (!is$1(target, "bpmn:Participant") && !is$1(target, "bpmn:Lane") && !is$1(target, "bpmn:SubProcess")) {
    return false;
  }
  var canResize2 = true;
  forEach$1(elements, function(element) {
    if (is$1(element, "bpmn:Lane") || isLabel(element)) {
      canResize2 = false;
      return;
    }
  });
  return canResize2;
};
const AutoResizeModule = {
  __init__: [
    "bpmnAutoResize",
    "bpmnAutoResizeProvider"
  ],
  bpmnAutoResize: ["type", BpmnAutoResize],
  bpmnAutoResizeProvider: ["type", BpmnAutoResizeProvider]
};
var HIGH_PRIORITY$j = 1500;
function HoverFix(elementRegistry, eventBus, injector) {
  var self2 = this;
  var dragging = injector.get("dragging", false);
  function ensureHover(event2) {
    if (event2.hover) {
      return;
    }
    var originalEvent = event2.originalEvent;
    var gfx = self2._findTargetGfx(originalEvent);
    var element = gfx && elementRegistry.get(gfx);
    if (gfx && element) {
      event2.stopPropagation();
      dragging.hover({ element, gfx });
      dragging.move(originalEvent);
    }
  }
  if (dragging) {
    eventBus.on("drag.start", function(event2) {
      eventBus.once("drag.move", HIGH_PRIORITY$j, function(event3) {
        ensureHover(event3);
      });
    });
  }
  (function() {
    var hoverGfx;
    var hover;
    eventBus.on("element.hover", function(event2) {
      hoverGfx = event2.gfx;
      hover = event2.element;
    });
    eventBus.on("element.hover", HIGH_PRIORITY$j, function(event2) {
      if (hover) {
        eventBus.fire("element.out", {
          element: hover,
          gfx: hoverGfx
        });
      }
    });
    eventBus.on("element.out", function() {
      hoverGfx = null;
      hover = null;
    });
  })();
  this._findTargetGfx = function(event2) {
    var position, target;
    if (!(event2 instanceof MouseEvent)) {
      return;
    }
    position = toPoint(event2);
    target = document.elementFromPoint(position.x, position.y);
    return getGfx(target);
  };
}
HoverFix.$inject = [
  "elementRegistry",
  "eventBus",
  "injector"
];
function getGfx(target) {
  return closest(target, "svg, .djs-element", true);
}
const HoverFixModule = {
  __init__: [
    "hoverFix"
  ],
  hoverFix: ["type", HoverFix]
};
var round$b = Math.round;
var DRAG_ACTIVE_CLS = "djs-drag-active";
function preventDefault$1(event2) {
  event2.preventDefault();
}
function isTouchEvent(event2) {
  return typeof TouchEvent !== "undefined" && event2 instanceof TouchEvent;
}
function getLength(point) {
  return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
}
function Dragging(eventBus, canvas, selection, elementRegistry) {
  var defaultOptions = {
    threshold: 5,
    trapClick: true
  };
  var context;
  function toLocalPoint(globalPosition) {
    var viewbox = canvas.viewbox();
    var clientRect = canvas._container.getBoundingClientRect();
    return {
      x: viewbox.x + (globalPosition.x - clientRect.left) / viewbox.scale,
      y: viewbox.y + (globalPosition.y - clientRect.top) / viewbox.scale
    };
  }
  function fire(type, dragContext) {
    dragContext = dragContext || context;
    var event2 = eventBus.createEvent(
      assign$1(
        {},
        dragContext.payload,
        dragContext.data,
        { isTouch: dragContext.isTouch }
      )
    );
    if (eventBus.fire("drag." + type, event2) === false) {
      return false;
    }
    return eventBus.fire(dragContext.prefix + "." + type, event2);
  }
  function restoreSelection(previousSelection) {
    var existingSelection = previousSelection.filter(function(element) {
      return elementRegistry.get(element.id);
    });
    existingSelection.length && selection.select(existingSelection);
  }
  function move2(event2, activate) {
    var payload = context.payload, displacement = context.displacement;
    var globalStart = context.globalStart, globalCurrent = toPoint(event2), globalDelta = delta(globalCurrent, globalStart);
    var localStart = context.localStart, localCurrent = toLocalPoint(globalCurrent), localDelta = delta(localCurrent, localStart);
    if (!context.active && (activate || getLength(globalDelta) > context.threshold)) {
      assign$1(payload, {
        x: round$b(localStart.x + displacement.x),
        y: round$b(localStart.y + displacement.y),
        dx: 0,
        dy: 0
      }, { originalEvent: event2 });
      if (false === fire("start")) {
        return cancel();
      }
      context.active = true;
      if (!context.keepSelection) {
        payload.previousSelection = selection.get();
        selection.select(null);
      }
      if (context.cursor) {
        set(context.cursor);
      }
      canvas.addMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);
    }
    stopPropagation$1(event2);
    if (context.active) {
      assign$1(payload, {
        x: round$b(localCurrent.x + displacement.x),
        y: round$b(localCurrent.y + displacement.y),
        dx: round$b(localDelta.x),
        dy: round$b(localDelta.y)
      }, { originalEvent: event2 });
      fire("move");
    }
  }
  function end(event2) {
    var previousContext, returnValue = true;
    if (context.active) {
      if (event2) {
        context.payload.originalEvent = event2;
        stopPropagation$1(event2);
      }
      returnValue = fire("end");
    }
    if (returnValue === false) {
      fire("rejected");
    }
    previousContext = cleanup(returnValue !== true);
    fire("ended", previousContext);
  }
  function checkCancel(event2) {
    if (isKey("Escape", event2)) {
      preventDefault$1(event2);
      cancel();
    }
  }
  function trapClickAndEnd(event2) {
    var untrap;
    if (context.active) {
      untrap = install$1(eventBus);
      setTimeout(untrap, 400);
      preventDefault$1(event2);
    }
    end(event2);
  }
  function trapTouch(event2) {
    move2(event2);
  }
  function hover(event2) {
    var payload = context.payload;
    payload.hoverGfx = event2.gfx;
    payload.hover = event2.element;
    fire("hover");
  }
  function out(event2) {
    fire("out");
    var payload = context.payload;
    payload.hoverGfx = null;
    payload.hover = null;
  }
  function cancel(restore) {
    var previousContext;
    if (!context) {
      return;
    }
    var wasActive = context.active;
    if (wasActive) {
      fire("cancel");
    }
    previousContext = cleanup(restore);
    if (wasActive) {
      fire("canceled", previousContext);
    }
  }
  function cleanup(restore) {
    var previousContext, endDrag;
    fire("cleanup");
    unset();
    if (context.trapClick) {
      endDrag = trapClickAndEnd;
    } else {
      endDrag = end;
    }
    event.unbind(document, "mousemove", move2);
    event.unbind(document, "dragstart", preventDefault$1);
    event.unbind(document, "selectstart", preventDefault$1);
    event.unbind(document, "mousedown", endDrag, true);
    event.unbind(document, "mouseup", endDrag, true);
    event.unbind(document, "keyup", checkCancel);
    event.unbind(document, "touchstart", trapTouch, true);
    event.unbind(document, "touchcancel", cancel, true);
    event.unbind(document, "touchmove", move2, true);
    event.unbind(document, "touchend", end, true);
    eventBus.off("element.hover", hover);
    eventBus.off("element.out", out);
    canvas.removeMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);
    var previousSelection = context.payload.previousSelection;
    if (restore !== false && previousSelection && !selection.get().length) {
      restoreSelection(previousSelection);
    }
    previousContext = context;
    context = null;
    return previousContext;
  }
  function init(event$1, relativeTo, prefix2, options) {
    if (context) {
      cancel(false);
    }
    if (typeof relativeTo === "string") {
      options = prefix2;
      prefix2 = relativeTo;
      relativeTo = null;
    }
    options = assign$1({}, defaultOptions, options || {});
    var data = options.data || {}, originalEvent, globalStart, localStart, endDrag, isTouch;
    if (options.trapClick) {
      endDrag = trapClickAndEnd;
    } else {
      endDrag = end;
    }
    if (event$1) {
      originalEvent = getOriginal$1(event$1) || event$1;
      globalStart = toPoint(event$1);
      stopPropagation$1(event$1);
      if (originalEvent.type === "dragstart") {
        preventDefault$1(originalEvent);
      }
    } else {
      originalEvent = null;
      globalStart = { x: 0, y: 0 };
    }
    localStart = toLocalPoint(globalStart);
    if (!relativeTo) {
      relativeTo = localStart;
    }
    isTouch = isTouchEvent(originalEvent);
    context = assign$1({
      prefix: prefix2,
      data,
      payload: {},
      globalStart,
      displacement: delta(relativeTo, localStart),
      localStart,
      isTouch
    }, options);
    if (!options.manual) {
      if (isTouch) {
        event.bind(document, "touchstart", trapTouch, true);
        event.bind(document, "touchcancel", cancel, true);
        event.bind(document, "touchmove", move2, true);
        event.bind(document, "touchend", end, true);
      } else {
        event.bind(document, "mousemove", move2);
        event.bind(document, "dragstart", preventDefault$1);
        event.bind(document, "selectstart", preventDefault$1);
        event.bind(document, "mousedown", endDrag, true);
        event.bind(document, "mouseup", endDrag, true);
      }
      event.bind(document, "keyup", checkCancel);
      eventBus.on("element.hover", hover);
      eventBus.on("element.out", out);
    }
    fire("init");
    if (options.autoActivate) {
      move2(event$1, true);
    }
  }
  eventBus.on("diagram.destroy", cancel);
  this.init = init;
  this.move = move2;
  this.hover = hover;
  this.out = out;
  this.end = end;
  this.cancel = cancel;
  this.context = function() {
    return context;
  };
  this.setOptions = function(options) {
    assign$1(defaultOptions, options);
  };
}
Dragging.$inject = [
  "eventBus",
  "canvas",
  "selection",
  "elementRegistry"
];
const DraggingModule = {
  __depends__: [
    HoverFixModule,
    SelectionModule
  ],
  dragging: ["type", Dragging]
};
function AutoScroll(config, eventBus, canvas) {
  this._canvas = canvas;
  this._opts = assign$1({
    scrollThresholdIn: [20, 20, 20, 20],
    scrollThresholdOut: [0, 0, 0, 0],
    scrollRepeatTimeout: 15,
    scrollStep: 10
  }, config);
  var self2 = this;
  eventBus.on("drag.move", function(e2) {
    var point = self2._toBorderPoint(e2);
    self2.startScroll(point);
  });
  eventBus.on(["drag.cleanup"], function() {
    self2.stopScroll();
  });
}
AutoScroll.$inject = [
  "config.autoScroll",
  "eventBus",
  "canvas"
];
AutoScroll.prototype.startScroll = function(point) {
  var canvas = this._canvas;
  var opts = this._opts;
  var self2 = this;
  var clientRect = canvas.getContainer().getBoundingClientRect();
  var diff = [
    point.x,
    point.y,
    clientRect.width - point.x,
    clientRect.height - point.y
  ];
  this.stopScroll();
  var dx = 0, dy = 0;
  for (var i2 = 0; i2 < 4; i2++) {
    if (between(diff[i2], opts.scrollThresholdOut[i2], opts.scrollThresholdIn[i2])) {
      if (i2 === 0) {
        dx = opts.scrollStep;
      } else if (i2 == 1) {
        dy = opts.scrollStep;
      } else if (i2 == 2) {
        dx = -opts.scrollStep;
      } else if (i2 == 3) {
        dy = -opts.scrollStep;
      }
    }
  }
  if (dx !== 0 || dy !== 0) {
    canvas.scroll({ dx, dy });
    this._scrolling = setTimeout(function() {
      self2.startScroll(point);
    }, opts.scrollRepeatTimeout);
  }
};
function between(val, start, end) {
  if (start < val && val < end) {
    return true;
  }
  return false;
}
AutoScroll.prototype.stopScroll = function() {
  clearTimeout(this._scrolling);
};
AutoScroll.prototype.setOptions = function(options) {
  this._opts = assign$1({}, this._opts, options);
};
AutoScroll.prototype._toBorderPoint = function(event2) {
  var clientRect = this._canvas._container.getBoundingClientRect();
  var globalPosition = toPoint(event2.originalEvent);
  return {
    x: globalPosition.x - clientRect.left,
    y: globalPosition.y - clientRect.top
  };
};
const AutoScrollModule = {
  __depends__: [
    DraggingModule
  ],
  __init__: ["autoScroll"],
  autoScroll: ["type", AutoScroll]
};
function Rules(injector) {
  this._commandStack = injector.get("commandStack", false);
}
Rules.$inject = ["injector"];
Rules.prototype.allowed = function(action, context) {
  var allowed = true;
  var commandStack = this._commandStack;
  if (commandStack) {
    allowed = commandStack.canExecute(action, context);
  }
  return allowed === void 0 ? true : allowed;
};
const RulesModule$1 = {
  __init__: ["rules"],
  rules: ["type", Rules]
};
var round$a = Math.round, max$6 = Math.max;
function circlePath(center2, r2) {
  var x2 = center2.x, y2 = center2.y;
  return [
    ["M", x2, y2],
    ["m", 0, -r2],
    ["a", r2, r2, 0, 1, 1, 0, 2 * r2],
    ["a", r2, r2, 0, 1, 1, 0, -2 * r2],
    ["z"]
  ];
}
function linePath(points) {
  var segments = [];
  points.forEach(function(p2, idx) {
    segments.push([idx === 0 ? "M" : "L", p2.x, p2.y]);
  });
  return segments;
}
var INTERSECTION_THRESHOLD$1 = 10;
function getBendpointIntersection(waypoints, reference) {
  var i2, w2;
  for (i2 = 0; w2 = waypoints[i2]; i2++) {
    if (pointDistance(w2, reference) <= INTERSECTION_THRESHOLD$1) {
      return {
        point: waypoints[i2],
        bendpoint: true,
        index: i2
      };
    }
  }
  return null;
}
function getPathIntersection(waypoints, reference) {
  var intersections = findPathIntersections(circlePath(reference, INTERSECTION_THRESHOLD$1), linePath(waypoints));
  var a2 = intersections[0], b2 = intersections[intersections.length - 1], idx;
  if (!a2) {
    return null;
  }
  if (a2 !== b2) {
    if (a2.segment2 !== b2.segment2) {
      idx = max$6(a2.segment2, b2.segment2) - 1;
      return {
        point: waypoints[idx],
        bendpoint: true,
        index: idx
      };
    }
    return {
      point: {
        x: round$a(a2.x + b2.x) / 2,
        y: round$a(a2.y + b2.y) / 2
      },
      index: a2.segment2
    };
  }
  return {
    point: {
      x: round$a(a2.x),
      y: round$a(a2.y)
    },
    index: a2.segment2
  };
}
function getApproxIntersection(waypoints, reference) {
  return getBendpointIntersection(waypoints, reference) || getPathIntersection(waypoints, reference);
}
function vectorLength(vector) {
  return Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2));
}
function getAngle(line) {
  return Math.atan((line[1].y - line[0].y) / (line[1].x - line[0].x));
}
function rotateVector(vector, angle) {
  return !angle ? vector : {
    x: Math.cos(angle) * vector.x - Math.sin(angle) * vector.y,
    y: Math.sin(angle) * vector.x + Math.cos(angle) * vector.y
  };
}
function solveLambaSystem(a2, b2, c2) {
  var system = [
    { n: a2[0] - c2[0], lambda: b2[0] },
    { n: a2[1] - c2[1], lambda: b2[1] }
  ];
  var n2 = system[0].n * b2[0] + system[1].n * b2[1], l2 = system[0].lambda * b2[0] + system[1].lambda * b2[1];
  return -n2 / l2;
}
function perpendicularFoot(point, line) {
  var a2 = line[0], b2 = line[1];
  var bd = { x: b2.x - a2.x, y: b2.y - a2.y };
  var r2 = solveLambaSystem([a2.x, a2.y], [bd.x, bd.y], [point.x, point.y]);
  return { x: a2.x + r2 * bd.x, y: a2.y + r2 * bd.y };
}
function getDistancePointLine(point, line) {
  var pfPoint = perpendicularFoot(point, line);
  var connectionVector = {
    x: pfPoint.x - point.x,
    y: pfPoint.y - point.y
  };
  return vectorLength(connectionVector);
}
function getDistancePointPoint(point1, point2) {
  return vectorLength({
    x: point1.x - point2.x,
    y: point1.y - point2.y
  });
}
var BENDPOINT_CLS = "djs-bendpoint";
var SEGMENT_DRAGGER_CLS = "djs-segment-dragger";
function toCanvasCoordinates(canvas, event2) {
  var position = toPoint(event2), clientRect = canvas._container.getBoundingClientRect(), offset;
  offset = {
    x: clientRect.left,
    y: clientRect.top
  };
  var viewbox = canvas.viewbox();
  return {
    x: viewbox.x + (position.x - offset.x) / viewbox.scale,
    y: viewbox.y + (position.y - offset.y) / viewbox.scale
  };
}
function getConnectionIntersection(canvas, waypoints, event2) {
  var localPosition = toCanvasCoordinates(canvas, event2), intersection2 = getApproxIntersection(waypoints, localPosition);
  return intersection2;
}
function addBendpoint(parentGfx, cls) {
  var groupGfx = create$1("g");
  classes(groupGfx).add(BENDPOINT_CLS);
  append(parentGfx, groupGfx);
  var visual = create$1("circle");
  attr(visual, {
    cx: 0,
    cy: 0,
    r: 4
  });
  classes(visual).add("djs-visual");
  append(groupGfx, visual);
  var hit = create$1("circle");
  attr(hit, {
    cx: 0,
    cy: 0,
    r: 10
  });
  classes(hit).add("djs-hit");
  append(groupGfx, hit);
  if (cls) {
    classes(groupGfx).add(cls);
  }
  return groupGfx;
}
function createParallelDragger(parentGfx, segmentStart, segmentEnd, alignment) {
  var draggerGfx = create$1("g");
  append(parentGfx, draggerGfx);
  var width = 18, height = 6, padding = 11, hitWidth = calculateHitWidth(segmentStart, segmentEnd, alignment), hitHeight = height + padding;
  var visual = create$1("rect");
  attr(visual, {
    x: -width / 2,
    y: -height / 2,
    width,
    height
  });
  classes(visual).add("djs-visual");
  append(draggerGfx, visual);
  var hit = create$1("rect");
  attr(hit, {
    x: -hitWidth / 2,
    y: -hitHeight / 2,
    width: hitWidth,
    height: hitHeight
  });
  classes(hit).add("djs-hit");
  append(draggerGfx, hit);
  rotate(draggerGfx, alignment === "v" ? 90 : 0);
  return draggerGfx;
}
function addSegmentDragger(parentGfx, segmentStart, segmentEnd) {
  var groupGfx = create$1("g"), mid2 = getMidPoint(segmentStart, segmentEnd), alignment = pointsAligned(segmentStart, segmentEnd);
  append(parentGfx, groupGfx);
  createParallelDragger(groupGfx, segmentStart, segmentEnd, alignment);
  classes(groupGfx).add(SEGMENT_DRAGGER_CLS);
  classes(groupGfx).add(alignment === "h" ? "horizontal" : "vertical");
  translate$2(groupGfx, mid2.x, mid2.y);
  return groupGfx;
}
function calculateSegmentMoveRegion(segmentLength) {
  return Math.abs(Math.round(segmentLength * 2 / 3));
}
function getClosestPointOnConnection(position, connection) {
  var segment = getClosestSegment(position, connection);
  return perpendicularFoot(position, segment);
}
function calculateHitWidth(segmentStart, segmentEnd, alignment) {
  var segmentLengthXAxis = segmentEnd.x - segmentStart.x, segmentLengthYAxis = segmentEnd.y - segmentStart.y;
  return alignment === "h" ? calculateSegmentMoveRegion(segmentLengthXAxis) : calculateSegmentMoveRegion(segmentLengthYAxis);
}
function getClosestSegment(position, connection) {
  var waypoints = connection.waypoints;
  var minDistance = Infinity, segmentIndex;
  for (var i2 = 0; i2 < waypoints.length - 1; i2++) {
    var start = waypoints[i2], end = waypoints[i2 + 1], distance2 = getDistancePointLine(position, [start, end]);
    if (distance2 < minDistance) {
      minDistance = distance2;
      segmentIndex = i2;
    }
  }
  return [waypoints[segmentIndex], waypoints[segmentIndex + 1]];
}
function Bendpoints(eventBus, canvas, interactionEvents, bendpointMove, connectionSegmentMove) {
  function isIntersectionMiddle(intersection2, waypoints, treshold) {
    var idx = intersection2.index, p2 = intersection2.point, p0, p1, mid2, aligned, xDelta, yDelta;
    if (idx <= 0 || intersection2.bendpoint) {
      return false;
    }
    p0 = waypoints[idx - 1];
    p1 = waypoints[idx];
    mid2 = getMidPoint(p0, p1), aligned = pointsAligned(p0, p1);
    xDelta = Math.abs(p2.x - mid2.x);
    yDelta = Math.abs(p2.y - mid2.y);
    return aligned && xDelta <= treshold && yDelta <= treshold;
  }
  function calculateIntersectionThreshold(connection, intersection2) {
    var waypoints = connection.waypoints, relevantSegment, alignment, segmentLength, threshold;
    if (intersection2.index <= 0 || intersection2.bendpoint) {
      return null;
    }
    relevantSegment = {
      start: waypoints[intersection2.index - 1],
      end: waypoints[intersection2.index]
    };
    alignment = pointsAligned(relevantSegment.start, relevantSegment.end);
    if (!alignment) {
      return null;
    }
    if (alignment === "h") {
      segmentLength = relevantSegment.end.x - relevantSegment.start.x;
    } else {
      segmentLength = relevantSegment.end.y - relevantSegment.start.y;
    }
    threshold = calculateSegmentMoveRegion(segmentLength) / 2;
    return threshold;
  }
  function activateBendpointMove(event2, connection) {
    var waypoints = connection.waypoints, intersection2 = getConnectionIntersection(canvas, waypoints, event2), threshold;
    if (!intersection2) {
      return;
    }
    threshold = calculateIntersectionThreshold(connection, intersection2);
    if (isIntersectionMiddle(intersection2, waypoints, threshold)) {
      connectionSegmentMove.start(event2, connection, intersection2.index);
    } else {
      bendpointMove.start(event2, connection, intersection2.index, !intersection2.bendpoint);
    }
    return true;
  }
  function bindInteractionEvents(node2, eventName, element) {
    event.bind(node2, eventName, function(event2) {
      interactionEvents.triggerMouseEvent(eventName, event2, element);
      event2.stopPropagation();
    });
  }
  function getBendpointsContainer(element, create2) {
    var layer = canvas.getLayer("overlays"), gfx = query('.djs-bendpoints[data-element-id="' + escapeCSS(element.id) + '"]', layer);
    if (!gfx && create2) {
      gfx = create$1("g");
      attr(gfx, { "data-element-id": element.id });
      classes(gfx).add("djs-bendpoints");
      append(layer, gfx);
      bindInteractionEvents(gfx, "mousedown", element);
      bindInteractionEvents(gfx, "click", element);
      bindInteractionEvents(gfx, "dblclick", element);
    }
    return gfx;
  }
  function getSegmentDragger(idx, parentGfx) {
    return query(
      '.djs-segment-dragger[data-segment-idx="' + idx + '"]',
      parentGfx
    );
  }
  function createBendpoints(gfx, connection) {
    connection.waypoints.forEach(function(p2, idx) {
      var bendpoint = addBendpoint(gfx);
      append(gfx, bendpoint);
      translate$2(bendpoint, p2.x, p2.y);
    });
    addBendpoint(gfx, "floating");
  }
  function createSegmentDraggers(gfx, connection) {
    var waypoints = connection.waypoints;
    var segmentStart, segmentEnd, segmentDraggerGfx;
    for (var i2 = 1; i2 < waypoints.length; i2++) {
      segmentStart = waypoints[i2 - 1];
      segmentEnd = waypoints[i2];
      if (pointsAligned(segmentStart, segmentEnd)) {
        segmentDraggerGfx = addSegmentDragger(gfx, segmentStart, segmentEnd);
        attr(segmentDraggerGfx, { "data-segment-idx": i2 });
        bindInteractionEvents(segmentDraggerGfx, "mousemove", connection);
      }
    }
  }
  function clearBendpoints(gfx) {
    forEach$1(all("." + BENDPOINT_CLS, gfx), function(node2) {
      remove$1(node2);
    });
  }
  function clearSegmentDraggers(gfx) {
    forEach$1(all("." + SEGMENT_DRAGGER_CLS, gfx), function(node2) {
      remove$1(node2);
    });
  }
  function addHandles(connection) {
    var gfx = getBendpointsContainer(connection);
    if (!gfx) {
      gfx = getBendpointsContainer(connection, true);
      createBendpoints(gfx, connection);
      createSegmentDraggers(gfx, connection);
    }
    return gfx;
  }
  function updateHandles(connection) {
    var gfx = getBendpointsContainer(connection);
    if (gfx) {
      clearSegmentDraggers(gfx);
      clearBendpoints(gfx);
      createSegmentDraggers(gfx, connection);
      createBendpoints(gfx, connection);
    }
  }
  function updateFloatingBendpointPosition(parentGfx, intersection2) {
    var floating = query(".floating", parentGfx), point = intersection2.point;
    if (!floating) {
      return;
    }
    translate$2(floating, point.x, point.y);
  }
  function updateSegmentDraggerPosition(parentGfx, intersection2, waypoints) {
    var draggerGfx = getSegmentDragger(intersection2.index, parentGfx), segmentStart = waypoints[intersection2.index - 1], segmentEnd = waypoints[intersection2.index], point = intersection2.point, mid2 = getMidPoint(segmentStart, segmentEnd), alignment = pointsAligned(segmentStart, segmentEnd), draggerVisual, relativePosition;
    if (!draggerGfx) {
      return;
    }
    draggerVisual = getDraggerVisual(draggerGfx);
    relativePosition = {
      x: point.x - mid2.x,
      y: point.y - mid2.y
    };
    if (alignment === "v") {
      relativePosition = {
        x: relativePosition.y,
        y: relativePosition.x
      };
    }
    translate$2(draggerVisual, relativePosition.x, relativePosition.y);
  }
  eventBus.on("connection.changed", function(event2) {
    updateHandles(event2.element);
  });
  eventBus.on("connection.remove", function(event2) {
    var gfx = getBendpointsContainer(event2.element);
    if (gfx) {
      remove$1(gfx);
    }
  });
  eventBus.on("element.marker.update", function(event2) {
    var element = event2.element, bendpointsGfx;
    if (!element.waypoints) {
      return;
    }
    bendpointsGfx = addHandles(element);
    if (event2.add) {
      classes(bendpointsGfx).add(event2.marker);
    } else {
      classes(bendpointsGfx).remove(event2.marker);
    }
  });
  eventBus.on("element.mousemove", function(event2) {
    var element = event2.element, waypoints = element.waypoints, bendpointsGfx, intersection2;
    if (waypoints) {
      bendpointsGfx = getBendpointsContainer(element, true);
      intersection2 = getConnectionIntersection(canvas, waypoints, event2.originalEvent);
      if (!intersection2) {
        return;
      }
      updateFloatingBendpointPosition(bendpointsGfx, intersection2);
      if (!intersection2.bendpoint) {
        updateSegmentDraggerPosition(bendpointsGfx, intersection2, waypoints);
      }
    }
  });
  eventBus.on("element.mousedown", function(event2) {
    if (!isPrimaryButton(event2)) {
      return;
    }
    var originalEvent = event2.originalEvent, element = event2.element;
    if (!element.waypoints) {
      return;
    }
    return activateBendpointMove(originalEvent, element);
  });
  eventBus.on("selection.changed", function(event2) {
    var newSelection = event2.newSelection, primary = newSelection[0];
    if (primary && primary.waypoints) {
      addHandles(primary);
    }
  });
  eventBus.on("element.hover", function(event2) {
    var element = event2.element;
    if (element.waypoints) {
      addHandles(element);
      interactionEvents.registerEvent(event2.gfx, "mousemove", "element.mousemove");
    }
  });
  eventBus.on("element.out", function(event2) {
    interactionEvents.unregisterEvent(event2.gfx, "mousemove", "element.mousemove");
  });
  eventBus.on("element.updateId", function(context) {
    var element = context.element, newId = context.newId;
    if (element.waypoints) {
      var bendpointContainer = getBendpointsContainer(element);
      if (bendpointContainer) {
        attr(bendpointContainer, { "data-element-id": newId });
      }
    }
  });
  this.addHandles = addHandles;
  this.updateHandles = updateHandles;
  this.getBendpointsContainer = getBendpointsContainer;
  this.getSegmentDragger = getSegmentDragger;
}
Bendpoints.$inject = [
  "eventBus",
  "canvas",
  "interactionEvents",
  "bendpointMove",
  "connectionSegmentMove"
];
function getDraggerVisual(draggerGfx) {
  return query(".djs-visual", draggerGfx);
}
var round$9 = Math.round;
var RECONNECT_START$1 = "reconnectStart", RECONNECT_END$1 = "reconnectEnd", UPDATE_WAYPOINTS$1 = "updateWaypoints";
function BendpointMove(injector, eventBus, canvas, dragging, rules, modeling) {
  this._injector = injector;
  this.start = function(event2, connection, bendpointIndex, insert) {
    var gfx = canvas.getGraphics(connection), source = connection.source, target = connection.target, waypoints = connection.waypoints, type;
    if (!insert && bendpointIndex === 0) {
      type = RECONNECT_START$1;
    } else if (!insert && bendpointIndex === waypoints.length - 1) {
      type = RECONNECT_END$1;
    } else {
      type = UPDATE_WAYPOINTS$1;
    }
    var command = type === UPDATE_WAYPOINTS$1 ? "connection.updateWaypoints" : "connection.reconnect";
    var allowed = rules.allowed(command, {
      connection,
      source,
      target
    });
    if (allowed === false) {
      allowed = rules.allowed(command, {
        connection,
        source: target,
        target: source
      });
    }
    if (allowed === false) {
      return;
    }
    dragging.init(event2, "bendpoint.move", {
      data: {
        connection,
        connectionGfx: gfx,
        context: {
          allowed,
          bendpointIndex,
          connection,
          source,
          target,
          insert,
          type
        }
      }
    });
  };
  eventBus.on("bendpoint.move.hover", function(event2) {
    var context = event2.context, connection = context.connection, source = connection.source, target = connection.target, hover = event2.hover, type = context.type;
    context.hover = hover;
    var allowed;
    if (!hover) {
      return;
    }
    var command = type === UPDATE_WAYPOINTS$1 ? "connection.updateWaypoints" : "connection.reconnect";
    allowed = context.allowed = rules.allowed(command, {
      connection,
      source: type === RECONNECT_START$1 ? hover : source,
      target: type === RECONNECT_END$1 ? hover : target
    });
    if (allowed) {
      context.source = type === RECONNECT_START$1 ? hover : source;
      context.target = type === RECONNECT_END$1 ? hover : target;
      return;
    }
    if (allowed === false) {
      allowed = context.allowed = rules.allowed(command, {
        connection,
        source: type === RECONNECT_END$1 ? hover : target,
        target: type === RECONNECT_START$1 ? hover : source
      });
    }
    if (allowed) {
      context.source = type === RECONNECT_END$1 ? hover : target;
      context.target = type === RECONNECT_START$1 ? hover : source;
    }
  });
  eventBus.on(["bendpoint.move.out", "bendpoint.move.cleanup"], function(event2) {
    var context = event2.context, type = context.type;
    context.hover = null;
    context.source = null;
    context.target = null;
    if (type !== UPDATE_WAYPOINTS$1) {
      context.allowed = false;
    }
  });
  eventBus.on("bendpoint.move.end", function(event2) {
    var context = event2.context, allowed = context.allowed, bendpointIndex = context.bendpointIndex, connection = context.connection, insert = context.insert, newWaypoints = connection.waypoints.slice(), source = context.source, target = context.target, type = context.type, hints = context.hints || {};
    var docking = {
      x: round$9(event2.x),
      y: round$9(event2.y)
    };
    if (!allowed) {
      return false;
    }
    if (type === UPDATE_WAYPOINTS$1) {
      if (insert) {
        newWaypoints.splice(bendpointIndex, 0, docking);
      } else {
        newWaypoints[bendpointIndex] = docking;
      }
      hints.bendpointMove = {
        insert,
        bendpointIndex
      };
      newWaypoints = this.cropWaypoints(connection, newWaypoints);
      modeling.updateWaypoints(connection, filterRedundantWaypoints(newWaypoints), hints);
    } else {
      if (type === RECONNECT_START$1) {
        hints.docking = "source";
        if (isReverse$2(context)) {
          hints.docking = "target";
          hints.newWaypoints = newWaypoints.reverse();
        }
      } else if (type === RECONNECT_END$1) {
        hints.docking = "target";
        if (isReverse$2(context)) {
          hints.docking = "source";
          hints.newWaypoints = newWaypoints.reverse();
        }
      }
      modeling.reconnect(connection, source, target, docking, hints);
    }
  }, this);
}
BendpointMove.$inject = [
  "injector",
  "eventBus",
  "canvas",
  "dragging",
  "rules",
  "modeling"
];
BendpointMove.prototype.cropWaypoints = function(connection, newWaypoints) {
  var connectionDocking = this._injector.get("connectionDocking", false);
  if (!connectionDocking) {
    return newWaypoints;
  }
  var waypoints = connection.waypoints;
  connection.waypoints = newWaypoints;
  connection.waypoints = connectionDocking.getCroppedWaypoints(connection);
  newWaypoints = connection.waypoints;
  connection.waypoints = waypoints;
  return newWaypoints;
};
function isReverse$2(context) {
  var hover = context.hover, source = context.source, target = context.target, type = context.type;
  if (type === RECONNECT_START$1) {
    return hover && target && hover === target && source !== target;
  }
  if (type === RECONNECT_END$1) {
    return hover && source && hover === source && source !== target;
  }
}
var RECONNECT_START = "reconnectStart", RECONNECT_END = "reconnectEnd", UPDATE_WAYPOINTS = "updateWaypoints";
var MARKER_OK$4 = "connect-ok", MARKER_NOT_OK$4 = "connect-not-ok", MARKER_CONNECT_HOVER$1 = "connect-hover", MARKER_CONNECT_UPDATING$1 = "djs-updating", MARKER_DRAGGER = "djs-dragging";
var HIGH_PRIORITY$i = 1100;
function BendpointMovePreview(bendpointMove, injector, eventBus, canvas) {
  this._injector = injector;
  var connectionPreview = injector.get("connectionPreview", false);
  eventBus.on("bendpoint.move.start", function(event2) {
    var context = event2.context, bendpointIndex = context.bendpointIndex, connection = context.connection, insert = context.insert, waypoints = connection.waypoints, newWaypoints = waypoints.slice();
    context.waypoints = waypoints;
    if (insert) {
      newWaypoints.splice(bendpointIndex, 0, { x: event2.x, y: event2.y });
    }
    connection.waypoints = newWaypoints;
    var draggerGfx = context.draggerGfx = addBendpoint(canvas.getLayer("overlays"));
    classes(draggerGfx).add("djs-dragging");
    canvas.addMarker(connection, MARKER_DRAGGER);
    canvas.addMarker(connection, MARKER_CONNECT_UPDATING$1);
  });
  eventBus.on("bendpoint.move.hover", function(event2) {
    var context = event2.context, allowed = context.allowed, hover = context.hover, type = context.type;
    if (hover) {
      canvas.addMarker(hover, MARKER_CONNECT_HOVER$1);
      if (type === UPDATE_WAYPOINTS) {
        return;
      }
      if (allowed) {
        canvas.removeMarker(hover, MARKER_NOT_OK$4);
        canvas.addMarker(hover, MARKER_OK$4);
      } else if (allowed === false) {
        canvas.removeMarker(hover, MARKER_OK$4);
        canvas.addMarker(hover, MARKER_NOT_OK$4);
      }
    }
  });
  eventBus.on([
    "bendpoint.move.out",
    "bendpoint.move.cleanup"
  ], HIGH_PRIORITY$i, function(event2) {
    var context = event2.context, hover = context.hover, target = context.target;
    if (hover) {
      canvas.removeMarker(hover, MARKER_CONNECT_HOVER$1);
      canvas.removeMarker(hover, target ? MARKER_OK$4 : MARKER_NOT_OK$4);
    }
  });
  eventBus.on("bendpoint.move.move", function(event2) {
    var context = event2.context, allowed = context.allowed, bendpointIndex = context.bendpointIndex, draggerGfx = context.draggerGfx, hover = context.hover, type = context.type, connection = context.connection, source = connection.source, target = connection.target, newWaypoints = connection.waypoints.slice(), bendpoint = { x: event2.x, y: event2.y }, hints = context.hints || {}, drawPreviewHints = {};
    if (connectionPreview) {
      if (hints.connectionStart) {
        drawPreviewHints.connectionStart = hints.connectionStart;
      }
      if (hints.connectionEnd) {
        drawPreviewHints.connectionEnd = hints.connectionEnd;
      }
      if (type === RECONNECT_START) {
        if (isReverse$2(context)) {
          drawPreviewHints.connectionEnd = drawPreviewHints.connectionEnd || bendpoint;
          drawPreviewHints.source = target;
          drawPreviewHints.target = hover || source;
          newWaypoints = newWaypoints.reverse();
        } else {
          drawPreviewHints.connectionStart = drawPreviewHints.connectionStart || bendpoint;
          drawPreviewHints.source = hover || source;
          drawPreviewHints.target = target;
        }
      } else if (type === RECONNECT_END) {
        if (isReverse$2(context)) {
          drawPreviewHints.connectionStart = drawPreviewHints.connectionStart || bendpoint;
          drawPreviewHints.source = hover || target;
          drawPreviewHints.target = source;
          newWaypoints = newWaypoints.reverse();
        } else {
          drawPreviewHints.connectionEnd = drawPreviewHints.connectionEnd || bendpoint;
          drawPreviewHints.source = source;
          drawPreviewHints.target = hover || target;
        }
      } else {
        drawPreviewHints.noCropping = true;
        drawPreviewHints.noLayout = true;
        newWaypoints[bendpointIndex] = bendpoint;
      }
      if (type === UPDATE_WAYPOINTS) {
        newWaypoints = bendpointMove.cropWaypoints(connection, newWaypoints);
      }
      drawPreviewHints.waypoints = newWaypoints;
      connectionPreview.drawPreview(context, allowed, drawPreviewHints);
    }
    translate$2(draggerGfx, event2.x, event2.y);
  }, this);
  eventBus.on([
    "bendpoint.move.end",
    "bendpoint.move.cancel"
  ], HIGH_PRIORITY$i, function(event2) {
    var context = event2.context, connection = context.connection, draggerGfx = context.draggerGfx, hover = context.hover, target = context.target, waypoints = context.waypoints;
    connection.waypoints = waypoints;
    remove$1(draggerGfx);
    canvas.removeMarker(connection, MARKER_CONNECT_UPDATING$1);
    canvas.removeMarker(connection, MARKER_DRAGGER);
    if (hover) {
      canvas.removeMarker(hover, MARKER_OK$4);
      canvas.removeMarker(hover, target ? MARKER_OK$4 : MARKER_NOT_OK$4);
    }
    if (connectionPreview) {
      connectionPreview.cleanUp(context);
    }
  });
}
BendpointMovePreview.$inject = [
  "bendpointMove",
  "injector",
  "eventBus",
  "canvas"
];
var MARKER_CONNECT_HOVER = "connect-hover", MARKER_CONNECT_UPDATING = "djs-updating";
function axisAdd(point, axis, delta2) {
  return axisSet(point, axis, point[axis] + delta2);
}
function axisSet(point, axis, value) {
  return {
    x: axis === "x" ? value : point.x,
    y: axis === "y" ? value : point.y
  };
}
function axisFenced(position, segmentStart, segmentEnd, axis) {
  var maxValue = Math.max(segmentStart[axis], segmentEnd[axis]), minValue = Math.min(segmentStart[axis], segmentEnd[axis]);
  var padding = 20;
  var fencedValue = Math.min(Math.max(minValue + padding, position[axis]), maxValue - padding);
  return axisSet(segmentStart, axis, fencedValue);
}
function flipAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getDocking$2(point, referenceElement, moveAxis) {
  var referenceMid, inverseAxis;
  if (point.original) {
    return point.original;
  } else {
    referenceMid = getMid(referenceElement);
    inverseAxis = flipAxis(moveAxis);
    return axisSet(point, inverseAxis, referenceMid[inverseAxis]);
  }
}
function ConnectionSegmentMove(injector, eventBus, canvas, dragging, graphicsFactory, modeling) {
  var connectionDocking = injector.get("connectionDocking", false);
  this.start = function(event2, connection, idx) {
    var context, gfx = canvas.getGraphics(connection), segmentStartIndex = idx - 1, segmentEndIndex = idx, waypoints = connection.waypoints, segmentStart = waypoints[segmentStartIndex], segmentEnd = waypoints[segmentEndIndex], intersection2 = getConnectionIntersection(canvas, waypoints, event2), direction, axis, dragPosition;
    direction = pointsAligned(segmentStart, segmentEnd);
    if (!direction) {
      return;
    }
    axis = direction === "v" ? "x" : "y";
    if (segmentStartIndex === 0) {
      segmentStart = getDocking$2(segmentStart, connection.source, axis);
    }
    if (segmentEndIndex === waypoints.length - 1) {
      segmentEnd = getDocking$2(segmentEnd, connection.target, axis);
    }
    if (intersection2) {
      dragPosition = intersection2.point;
    } else {
      dragPosition = {
        x: (segmentStart.x + segmentEnd.x) / 2,
        y: (segmentStart.y + segmentEnd.y) / 2
      };
    }
    context = {
      connection,
      segmentStartIndex,
      segmentEndIndex,
      segmentStart,
      segmentEnd,
      axis,
      dragPosition
    };
    dragging.init(event2, dragPosition, "connectionSegment.move", {
      cursor: axis === "x" ? "resize-ew" : "resize-ns",
      data: {
        connection,
        connectionGfx: gfx,
        context
      }
    });
  };
  function cropConnection(connection, newWaypoints) {
    if (!connectionDocking) {
      return newWaypoints;
    }
    var oldWaypoints = connection.waypoints, croppedWaypoints;
    connection.waypoints = newWaypoints;
    croppedWaypoints = connectionDocking.getCroppedWaypoints(connection);
    connection.waypoints = oldWaypoints;
    return croppedWaypoints;
  }
  function redrawConnection(data) {
    graphicsFactory.update("connection", data.connection, data.connectionGfx);
  }
  function updateDragger(context, segmentOffset, event2) {
    var newWaypoints = context.newWaypoints, segmentStartIndex = context.segmentStartIndex + segmentOffset, segmentStart = newWaypoints[segmentStartIndex], segmentEndIndex = context.segmentEndIndex + segmentOffset, segmentEnd = newWaypoints[segmentEndIndex], axis = flipAxis(context.axis);
    var draggerPosition = axisFenced(event2, segmentStart, segmentEnd, axis);
    translate$2(context.draggerGfx, draggerPosition.x, draggerPosition.y);
  }
  function filterRedundantWaypoints2(waypoints, segmentStartIndex) {
    var segmentOffset = 0;
    var filteredWaypoints = waypoints.filter(function(r2, idx) {
      if (pointsOnLine(waypoints[idx - 1], waypoints[idx + 1], r2)) {
        segmentOffset = idx <= segmentStartIndex ? segmentOffset - 1 : segmentOffset;
        return false;
      }
      return true;
    });
    return {
      waypoints: filteredWaypoints,
      segmentOffset
    };
  }
  eventBus.on("connectionSegment.move.start", function(event2) {
    var context = event2.context, connection = event2.connection, layer = canvas.getLayer("overlays");
    context.originalWaypoints = connection.waypoints.slice();
    context.draggerGfx = addSegmentDragger(layer, context.segmentStart, context.segmentEnd);
    classes(context.draggerGfx).add("djs-dragging");
    canvas.addMarker(connection, MARKER_CONNECT_UPDATING);
  });
  eventBus.on("connectionSegment.move.move", function(event2) {
    var context = event2.context, connection = context.connection, segmentStartIndex = context.segmentStartIndex, segmentEndIndex = context.segmentEndIndex, segmentStart = context.segmentStart, segmentEnd = context.segmentEnd, axis = context.axis;
    var newWaypoints = context.originalWaypoints.slice(), newSegmentStart = axisAdd(segmentStart, axis, event2["d" + axis]), newSegmentEnd = axisAdd(segmentEnd, axis, event2["d" + axis]);
    var waypointCount = newWaypoints.length, segmentOffset = 0;
    newWaypoints[segmentStartIndex] = newSegmentStart;
    newWaypoints[segmentEndIndex] = newSegmentEnd;
    var sourceToSegmentOrientation, targetToSegmentOrientation;
    if (segmentStartIndex < 2) {
      sourceToSegmentOrientation = getOrientation(connection.source, newSegmentStart);
      if (segmentStartIndex === 1) {
        if (sourceToSegmentOrientation === "intersect") {
          newWaypoints.shift();
          newWaypoints[0] = newSegmentStart;
          segmentOffset--;
        }
      } else {
        if (sourceToSegmentOrientation !== "intersect") {
          newWaypoints.unshift(segmentStart);
          segmentOffset++;
        }
      }
    }
    if (segmentEndIndex > waypointCount - 3) {
      targetToSegmentOrientation = getOrientation(connection.target, newSegmentEnd);
      if (segmentEndIndex === waypointCount - 2) {
        if (targetToSegmentOrientation === "intersect") {
          newWaypoints.pop();
          newWaypoints[newWaypoints.length - 1] = newSegmentEnd;
        }
      } else {
        if (targetToSegmentOrientation !== "intersect") {
          newWaypoints.push(segmentEnd);
        }
      }
    }
    context.newWaypoints = connection.waypoints = cropConnection(connection, newWaypoints);
    updateDragger(context, segmentOffset, event2);
    context.newSegmentStartIndex = segmentStartIndex + segmentOffset;
    redrawConnection(event2);
  });
  eventBus.on("connectionSegment.move.hover", function(event2) {
    event2.context.hover = event2.hover;
    canvas.addMarker(event2.hover, MARKER_CONNECT_HOVER);
  });
  eventBus.on([
    "connectionSegment.move.out",
    "connectionSegment.move.cleanup"
  ], function(event2) {
    var hover = event2.context.hover;
    if (hover) {
      canvas.removeMarker(hover, MARKER_CONNECT_HOVER);
    }
  });
  eventBus.on("connectionSegment.move.cleanup", function(event2) {
    var context = event2.context, connection = context.connection;
    if (context.draggerGfx) {
      remove$1(context.draggerGfx);
    }
    canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);
  });
  eventBus.on([
    "connectionSegment.move.cancel",
    "connectionSegment.move.end"
  ], function(event2) {
    var context = event2.context, connection = context.connection;
    connection.waypoints = context.originalWaypoints;
    redrawConnection(event2);
  });
  eventBus.on("connectionSegment.move.end", function(event2) {
    var context = event2.context, connection = context.connection, newWaypoints = context.newWaypoints, newSegmentStartIndex = context.newSegmentStartIndex;
    newWaypoints = newWaypoints.map(function(p2) {
      return {
        original: p2.original,
        x: Math.round(p2.x),
        y: Math.round(p2.y)
      };
    });
    var filtered = filterRedundantWaypoints2(newWaypoints, newSegmentStartIndex);
    var filteredWaypoints = filtered.waypoints, croppedWaypoints = cropConnection(connection, filteredWaypoints), segmentOffset = filtered.segmentOffset;
    var hints = {
      segmentMove: {
        segmentStartIndex: context.segmentStartIndex,
        newSegmentStartIndex: newSegmentStartIndex + segmentOffset
      }
    };
    modeling.updateWaypoints(connection, croppedWaypoints, hints);
  });
}
ConnectionSegmentMove.$inject = [
  "injector",
  "eventBus",
  "canvas",
  "dragging",
  "graphicsFactory",
  "modeling"
];
var abs$6 = Math.abs, round$8 = Math.round;
function snapTo(value, values2, tolerance) {
  tolerance = tolerance === void 0 ? 10 : tolerance;
  var idx, snapValue;
  for (idx = 0; idx < values2.length; idx++) {
    snapValue = values2[idx];
    if (abs$6(snapValue - value) <= tolerance) {
      return snapValue;
    }
  }
}
function topLeft(bounds) {
  return {
    x: bounds.x,
    y: bounds.y
  };
}
function bottomRight(bounds) {
  return {
    x: bounds.x + bounds.width,
    y: bounds.y + bounds.height
  };
}
function mid$2(bounds, defaultValue) {
  if (!bounds || isNaN(bounds.x) || isNaN(bounds.y)) {
    return defaultValue;
  }
  return {
    x: round$8(bounds.x + bounds.width / 2),
    y: round$8(bounds.y + bounds.height / 2)
  };
}
function isSnapped(event2, axis) {
  var snapped = event2.snapped;
  if (!snapped) {
    return false;
  }
  if (typeof axis === "string") {
    return snapped[axis];
  }
  return snapped.x && snapped.y;
}
function setSnapped(event2, axis, value) {
  if (typeof axis !== "string") {
    throw new Error("axis must be in [x, y]");
  }
  if (typeof value !== "number" && value !== false) {
    throw new Error("value must be Number or false");
  }
  var delta2, previousValue = event2[axis];
  var snapped = event2.snapped = event2.snapped || {};
  if (value === false) {
    snapped[axis] = false;
  } else {
    snapped[axis] = true;
    delta2 = value - previousValue;
    event2[axis] += delta2;
    event2["d" + axis] += delta2;
  }
  return previousValue;
}
function getChildren(parent) {
  return parent.children || [];
}
var abs$5 = Math.abs, round$7 = Math.round;
var TOLERANCE = 10;
function BendpointSnapping(eventBus) {
  function snapTo2(values2, value) {
    if (isArray$3(values2)) {
      var i2 = values2.length;
      while (i2--)
        if (abs$5(values2[i2] - value) <= TOLERANCE) {
          return values2[i2];
        }
    } else {
      values2 = +values2;
      var rem = value % values2;
      if (rem < TOLERANCE) {
        return value - rem;
      }
      if (rem > values2 - TOLERANCE) {
        return value - rem + values2;
      }
    }
    return value;
  }
  function getSnapPoint(element, event2) {
    if (element.waypoints) {
      return getClosestPointOnConnection(event2, element);
    }
    if (element.width) {
      return {
        x: round$7(element.width / 2 + element.x),
        y: round$7(element.height / 2 + element.y)
      };
    }
  }
  function getConnectionSegmentSnaps(event2) {
    var context = event2.context, snapPoints = context.snapPoints, connection = context.connection, waypoints = connection.waypoints, segmentStart = context.segmentStart, segmentStartIndex = context.segmentStartIndex, segmentEnd = context.segmentEnd, segmentEndIndex = context.segmentEndIndex, axis = context.axis;
    if (snapPoints) {
      return snapPoints;
    }
    var referenceWaypoints = [
      waypoints[segmentStartIndex - 1],
      segmentStart,
      segmentEnd,
      waypoints[segmentEndIndex + 1]
    ];
    if (segmentStartIndex < 2) {
      referenceWaypoints.unshift(getSnapPoint(connection.source, event2));
    }
    if (segmentEndIndex > waypoints.length - 3) {
      referenceWaypoints.unshift(getSnapPoint(connection.target, event2));
    }
    context.snapPoints = snapPoints = { horizontal: [], vertical: [] };
    forEach$1(referenceWaypoints, function(p2) {
      if (p2) {
        p2 = p2.original || p2;
        if (axis === "y") {
          snapPoints.horizontal.push(p2.y);
        }
        if (axis === "x") {
          snapPoints.vertical.push(p2.x);
        }
      }
    });
    return snapPoints;
  }
  eventBus.on("connectionSegment.move.move", 1500, function(event2) {
    var snapPoints = getConnectionSegmentSnaps(event2), x2 = event2.x, y2 = event2.y, sx, sy;
    if (!snapPoints) {
      return;
    }
    sx = snapTo2(snapPoints.vertical, x2);
    sy = snapTo2(snapPoints.horizontal, y2);
    var cx = x2 - sx, cy = y2 - sy;
    assign$1(event2, {
      dx: event2.dx - cx,
      dy: event2.dy - cy,
      x: sx,
      y: sy
    });
    if (cx || snapPoints.vertical.indexOf(x2) !== -1) {
      setSnapped(event2, "x", sx);
    }
    if (cy || snapPoints.horizontal.indexOf(y2) !== -1) {
      setSnapped(event2, "y", sy);
    }
  });
  function getBendpointSnaps(context) {
    var snapPoints = context.snapPoints, waypoints = context.connection.waypoints, bendpointIndex = context.bendpointIndex;
    if (snapPoints) {
      return snapPoints;
    }
    var referenceWaypoints = [waypoints[bendpointIndex - 1], waypoints[bendpointIndex + 1]];
    context.snapPoints = snapPoints = { horizontal: [], vertical: [] };
    forEach$1(referenceWaypoints, function(p2) {
      if (p2) {
        p2 = p2.original || p2;
        snapPoints.horizontal.push(p2.y);
        snapPoints.vertical.push(p2.x);
      }
    });
    return snapPoints;
  }
  eventBus.on([
    "connect.hover",
    "connect.move",
    "connect.end"
  ], 1500, function(event2) {
    var context = event2.context, hover = context.hover, hoverMid = hover && getSnapPoint(hover, event2);
    if (!isConnection(hover) || !hoverMid || !hoverMid.x || !hoverMid.y) {
      return;
    }
    setSnapped(event2, "x", hoverMid.x);
    setSnapped(event2, "y", hoverMid.y);
  });
  eventBus.on(["bendpoint.move.move", "bendpoint.move.end"], 1500, function(event2) {
    var context = event2.context, snapPoints = getBendpointSnaps(context), hover = context.hover, hoverMid = hover && getSnapPoint(hover, event2), x2 = event2.x, y2 = event2.y, sx, sy;
    if (!snapPoints) {
      return;
    }
    sx = snapTo2(hoverMid ? snapPoints.vertical.concat([hoverMid.x]) : snapPoints.vertical, x2);
    sy = snapTo2(hoverMid ? snapPoints.horizontal.concat([hoverMid.y]) : snapPoints.horizontal, y2);
    var cx = x2 - sx, cy = y2 - sy;
    assign$1(event2, {
      dx: event2.dx - cx,
      dy: event2.dy - cy,
      x: event2.x - cx,
      y: event2.y - cy
    });
    if (cx || snapPoints.vertical.indexOf(x2) !== -1) {
      setSnapped(event2, "x", sx);
    }
    if (cy || snapPoints.horizontal.indexOf(y2) !== -1) {
      setSnapped(event2, "y", sy);
    }
  });
}
BendpointSnapping.$inject = ["eventBus"];
const BendpointsModule = {
  __depends__: [
    DraggingModule,
    RulesModule$1
  ],
  __init__: ["bendpoints", "bendpointSnapping", "bendpointMovePreview"],
  bendpoints: ["type", Bendpoints],
  bendpointMove: ["type", BendpointMove],
  bendpointMovePreview: ["type", BendpointMovePreview],
  connectionSegmentMove: ["type", ConnectionSegmentMove],
  bendpointSnapping: ["type", BendpointSnapping]
};
function Connect(eventBus, dragging, modeling, rules) {
  function canConnect2(source, target) {
    return rules.allowed("connection.create", {
      source,
      target
    });
  }
  function canConnectReverse(source, target) {
    return canConnect2(target, source);
  }
  eventBus.on("connect.hover", function(event2) {
    var context = event2.context, start = context.start, hover = event2.hover, canExecute;
    context.hover = hover;
    canExecute = context.canExecute = canConnect2(start, hover);
    if (isNil(canExecute)) {
      return;
    }
    if (canExecute !== false) {
      context.source = start;
      context.target = hover;
      return;
    }
    canExecute = context.canExecute = canConnectReverse(start, hover);
    if (isNil(canExecute)) {
      return;
    }
    if (canExecute !== false) {
      context.source = hover;
      context.target = start;
    }
  });
  eventBus.on(["connect.out", "connect.cleanup"], function(event2) {
    var context = event2.context;
    context.hover = null;
    context.source = null;
    context.target = null;
    context.canExecute = false;
  });
  eventBus.on("connect.end", function(event2) {
    var context = event2.context, canExecute = context.canExecute, connectionStart = context.connectionStart, connectionEnd = {
      x: event2.x,
      y: event2.y
    }, source = context.source, target = context.target;
    if (!canExecute) {
      return false;
    }
    var attrs = null, hints = {
      connectionStart: isReverse$1(context) ? connectionEnd : connectionStart,
      connectionEnd: isReverse$1(context) ? connectionStart : connectionEnd
    };
    if (isObject(canExecute)) {
      attrs = canExecute;
    }
    context.connection = modeling.connect(source, target, attrs, hints);
  });
  this.start = function(event2, start, connectionStart, autoActivate) {
    if (!isObject(connectionStart)) {
      autoActivate = connectionStart;
      connectionStart = getMid(start);
    }
    dragging.init(event2, "connect", {
      autoActivate,
      data: {
        shape: start,
        context: {
          start,
          connectionStart
        }
      }
    });
  };
}
Connect.$inject = [
  "eventBus",
  "dragging",
  "modeling",
  "rules"
];
function isReverse$1(context) {
  var hover = context.hover, source = context.source, target = context.target;
  return hover && source && hover === source && source !== target;
}
var HIGH_PRIORITY$h = 1100, LOW_PRIORITY$j = 900;
var MARKER_OK$3 = "connect-ok", MARKER_NOT_OK$3 = "connect-not-ok";
function ConnectPreview(injector, eventBus, canvas) {
  var connectionPreview = injector.get("connectionPreview", false);
  connectionPreview && eventBus.on("connect.move", function(event2) {
    var context = event2.context, canConnect2 = context.canExecute, hover = context.hover, source = context.source, start = context.start, startPosition = context.startPosition, target = context.target, connectionStart = context.connectionStart || startPosition, connectionEnd = context.connectionEnd || {
      x: event2.x,
      y: event2.y
    }, previewStart = connectionStart, previewEnd = connectionEnd;
    if (isReverse$1(context)) {
      previewStart = connectionEnd;
      previewEnd = connectionStart;
    }
    connectionPreview.drawPreview(context, canConnect2, {
      source: source || start,
      target: target || hover,
      connectionStart: previewStart,
      connectionEnd: previewEnd
    });
  });
  eventBus.on("connect.hover", LOW_PRIORITY$j, function(event2) {
    var context = event2.context, hover = event2.hover, canExecute = context.canExecute;
    if (canExecute === null) {
      return;
    }
    canvas.addMarker(hover, canExecute ? MARKER_OK$3 : MARKER_NOT_OK$3);
  });
  eventBus.on([
    "connect.out",
    "connect.cleanup"
  ], HIGH_PRIORITY$h, function(event2) {
    var hover = event2.hover;
    if (hover) {
      canvas.removeMarker(hover, MARKER_OK$3);
      canvas.removeMarker(hover, MARKER_NOT_OK$3);
    }
  });
  connectionPreview && eventBus.on("connect.cleanup", function(event2) {
    connectionPreview.cleanUp(event2.context);
  });
}
ConnectPreview.$inject = [
  "injector",
  "eventBus",
  "canvas"
];
const ConnectModule = {
  __depends__: [
    SelectionModule,
    RulesModule$1,
    DraggingModule
  ],
  __init__: [
    "connectPreview"
  ],
  connect: ["type", Connect],
  connectPreview: ["type", ConnectPreview]
};
var MARKER_CONNECTION_PREVIEW = "djs-dragger";
function ConnectionPreview(injector, canvas, graphicsFactory, elementFactory) {
  this._canvas = canvas;
  this._graphicsFactory = graphicsFactory;
  this._elementFactory = elementFactory;
  this._connectionDocking = injector.get("connectionDocking", false);
  this._layouter = injector.get("layouter", false);
}
ConnectionPreview.$inject = [
  "injector",
  "canvas",
  "graphicsFactory",
  "elementFactory"
];
ConnectionPreview.prototype.drawPreview = function(context, canConnect2, hints) {
  hints = hints || {};
  var connectionPreviewGfx = context.connectionPreviewGfx, getConnection = context.getConnection, source = hints.source, target = hints.target, waypoints = hints.waypoints, connectionStart = hints.connectionStart, connectionEnd = hints.connectionEnd, noLayout = hints.noLayout, noCropping = hints.noCropping, noNoop = hints.noNoop, connection;
  var self2 = this;
  if (!connectionPreviewGfx) {
    connectionPreviewGfx = context.connectionPreviewGfx = this.createConnectionPreviewGfx();
  }
  clear(connectionPreviewGfx);
  if (!getConnection) {
    getConnection = context.getConnection = cacheReturnValues(function(canConnect3, source2, target2) {
      return self2.getConnection(canConnect3, source2, target2);
    });
  }
  if (canConnect2) {
    connection = getConnection(canConnect2, source, target);
  }
  if (!connection) {
    !noNoop && this.drawNoopPreview(connectionPreviewGfx, hints);
    return;
  }
  connection.waypoints = waypoints || [];
  if (this._layouter && !noLayout) {
    connection.waypoints = this._layouter.layoutConnection(connection, {
      source,
      target,
      connectionStart,
      connectionEnd,
      waypoints: hints.waypoints || connection.waypoints
    });
  }
  if (!connection.waypoints || !connection.waypoints.length) {
    connection.waypoints = [
      source ? getMid(source) : connectionStart,
      target ? getMid(target) : connectionEnd
    ];
  }
  if (this._connectionDocking && (source || target) && !noCropping) {
    connection.waypoints = this._connectionDocking.getCroppedWaypoints(connection, source, target);
  }
  this._graphicsFactory.drawConnection(connectionPreviewGfx, connection, {
    stroke: "var(--element-dragger-color)"
  });
};
ConnectionPreview.prototype.drawNoopPreview = function(connectionPreviewGfx, hints) {
  var source = hints.source, target = hints.target, start = hints.connectionStart || getMid(source), end = hints.connectionEnd || getMid(target);
  var waypoints = this.cropWaypoints(start, end, source, target);
  var connection = this.createNoopConnection(waypoints[0], waypoints[1]);
  append(connectionPreviewGfx, connection);
};
ConnectionPreview.prototype.cropWaypoints = function(start, end, source, target) {
  var graphicsFactory = this._graphicsFactory, sourcePath = source && graphicsFactory.getShapePath(source), targetPath = target && graphicsFactory.getShapePath(target), connectionPath = graphicsFactory.getConnectionPath({ waypoints: [start, end] });
  start = source && getElementLineIntersection(sourcePath, connectionPath, true) || start;
  end = target && getElementLineIntersection(targetPath, connectionPath, false) || end;
  return [start, end];
};
ConnectionPreview.prototype.cleanUp = function(context) {
  if (context && context.connectionPreviewGfx) {
    remove$1(context.connectionPreviewGfx);
  }
};
ConnectionPreview.prototype.getConnection = function(canConnect2) {
  var attrs = ensureConnectionAttrs(canConnect2);
  return this._elementFactory.createConnection(attrs);
};
ConnectionPreview.prototype.createConnectionPreviewGfx = function() {
  var gfx = create$1("g");
  attr(gfx, {
    pointerEvents: "none"
  });
  classes(gfx).add(MARKER_CONNECTION_PREVIEW);
  append(this._canvas.getActiveLayer(), gfx);
  return gfx;
};
ConnectionPreview.prototype.createNoopConnection = function(start, end) {
  return createLine([start, end], {
    "stroke": "#333",
    "strokeDasharray": [1],
    "strokeWidth": 2,
    "pointer-events": "none"
  });
};
function cacheReturnValues(fn) {
  var returnValues = {};
  return function(firstArgument) {
    var key = JSON.stringify(firstArgument);
    var returnValue = returnValues[key];
    if (!returnValue) {
      returnValue = returnValues[key] = fn.apply(null, arguments);
    }
    return returnValue;
  };
}
function ensureConnectionAttrs(canConnect2) {
  if (isObject(canConnect2)) {
    return canConnect2;
  } else {
    return {};
  }
}
const ConnectionPreviewModule = {
  __init__: ["connectionPreview"],
  connectionPreview: ["type", ConnectionPreview]
};
var MARKER_TYPES = [
  "marker-start",
  "marker-mid",
  "marker-end"
];
var NODES_CAN_HAVE_MARKER = [
  "circle",
  "ellipse",
  "line",
  "path",
  "polygon",
  "polyline",
  "path",
  "rect"
];
function PreviewSupport(elementRegistry, eventBus, canvas, styles) {
  this._elementRegistry = elementRegistry;
  this._canvas = canvas;
  this._styles = styles;
  this._clonedMarkers = {};
  var self2 = this;
  eventBus.on("drag.cleanup", function() {
    self2.cleanUp();
  });
}
PreviewSupport.$inject = [
  "elementRegistry",
  "eventBus",
  "canvas",
  "styles"
];
PreviewSupport.prototype.cleanUp = function() {
  var self2 = this;
  forEach$1(self2._clonedMarkers, function(clonedMarker) {
    remove$1(clonedMarker);
  });
  self2._clonedMarkers = {};
};
PreviewSupport.prototype.getGfx = function(element) {
  return this._elementRegistry.getGraphics(element);
};
PreviewSupport.prototype.addDragger = function(element, group, gfx, className = "djs-dragger") {
  gfx = gfx || this.getGfx(element);
  var dragger = clone$1(gfx);
  var bbox = gfx.getBoundingClientRect();
  this._cloneMarkers(getVisual(dragger), className);
  attr(dragger, this._styles.cls(className, [], {
    x: bbox.top,
    y: bbox.left
  }));
  append(group, dragger);
  attr(dragger, "data-preview-support-element-id", element.id);
  return dragger;
};
PreviewSupport.prototype.addFrame = function(shape, group) {
  var frame = create$1("rect", {
    class: "djs-resize-overlay",
    width: shape.width,
    height: shape.height,
    x: shape.x,
    y: shape.y
  });
  append(group, frame);
  attr(frame, "data-preview-support-element-id", shape.id);
  return frame;
};
PreviewSupport.prototype._cloneMarkers = function(gfx, className = "djs-dragger") {
  var self2 = this;
  if (gfx.childNodes) {
    for (var i2 = 0; i2 < gfx.childNodes.length; i2++) {
      self2._cloneMarkers(gfx.childNodes[i2], className);
    }
  }
  if (!canHaveMarker(gfx)) {
    return;
  }
  MARKER_TYPES.forEach(function(markerType) {
    if (attr(gfx, markerType)) {
      var marker = getMarker(gfx, markerType, self2._canvas.getContainer());
      self2._cloneMarker(gfx, marker, markerType, className);
    }
  });
};
PreviewSupport.prototype._cloneMarker = function(gfx, marker, markerType, className = "djs-dragger") {
  var markerId = marker.id + "-" + className;
  var clonedMarker = this._clonedMarkers[markerId];
  if (!clonedMarker) {
    clonedMarker = clone$1(marker);
    var clonedMarkerId = markerId + "-clone";
    clonedMarker.id = clonedMarkerId;
    classes(clonedMarker).add(className);
    this._clonedMarkers[markerId] = clonedMarker;
    var defs = query("defs", this._canvas._svg);
    if (!defs) {
      defs = create$1("defs");
      append(this._canvas._svg, defs);
    }
    append(defs, clonedMarker);
  }
  var reference = idToReference(this._clonedMarkers[markerId].id);
  attr(gfx, markerType, reference);
};
function getMarker(node2, markerType, parentNode) {
  var id = referenceToId(attr(node2, markerType));
  return query("marker#" + id, parentNode || document);
}
function referenceToId(reference) {
  return reference.match(/url\(['"]?#([^'"]*)['"]?\)/)[1];
}
function idToReference(id) {
  return "url(#" + id + ")";
}
function canHaveMarker(node2) {
  return NODES_CAN_HAVE_MARKER.indexOf(node2.nodeName) !== -1;
}
const PreviewSupportModule = {
  __init__: ["previewSupport"],
  previewSupport: ["type", PreviewSupport]
};
const LAYER_NAME = "complex-preview";
class ComplexPreview {
  constructor(canvas, graphicsFactory, previewSupport) {
    this._canvas = canvas;
    this._graphicsFactory = graphicsFactory;
    this._previewSupport = previewSupport;
    this._markers = [];
  }
  /**
   * Create complex preview.
   *
   * @param {CreateOptions} options
   */
  create(options) {
    this.cleanUp();
    const {
      created = [],
      moved = [],
      removed = [],
      resized = []
    } = options;
    const layer = this._canvas.getLayer(LAYER_NAME);
    created.filter((element) => !isHidden$2(element)).forEach((element) => {
      let gfx;
      if (isConnection(element)) {
        gfx = this._graphicsFactory._createContainer("connection", create$1("g"));
        this._graphicsFactory.drawConnection(getVisual(gfx), element);
      } else {
        gfx = this._graphicsFactory._createContainer("shape", create$1("g"));
        this._graphicsFactory.drawShape(getVisual(gfx), element);
        translate$2(gfx, element.x, element.y);
      }
      this._previewSupport.addDragger(element, layer, gfx);
    });
    moved.forEach(({ element, delta: delta2 }) => {
      this._previewSupport.addDragger(element, layer, void 0, "djs-dragging");
      this._canvas.addMarker(element, "djs-element-hidden");
      this._markers.push([element, "djs-element-hidden"]);
      const dragger = this._previewSupport.addDragger(element, layer);
      if (isConnection(element)) {
        translate$2(dragger, delta2.x, delta2.y);
      } else {
        translate$2(dragger, element.x + delta2.x, element.y + delta2.y);
      }
    });
    removed.forEach((element) => {
      this._previewSupport.addDragger(element, layer, void 0, "djs-dragging");
      this._canvas.addMarker(element, "djs-element-hidden");
      this._markers.push([element, "djs-element-hidden"]);
    });
    resized.forEach(({ shape, bounds }) => {
      this._canvas.addMarker(shape, "djs-hidden");
      this._markers.push([shape, "djs-hidden"]);
      this._previewSupport.addDragger(shape, layer, void 0, "djs-dragging");
      const gfx = this._graphicsFactory._createContainer("shape", create$1("g"));
      this._graphicsFactory.drawShape(getVisual(gfx), shape, {
        width: bounds.width,
        height: bounds.height
      });
      translate$2(gfx, bounds.x, bounds.y);
      this._previewSupport.addDragger(shape, layer, gfx);
    });
  }
  cleanUp() {
    clear(this._canvas.getLayer(LAYER_NAME));
    this._markers.forEach(([element, marker]) => this._canvas.removeMarker(element, marker));
    this._markers = [];
    this._previewSupport.cleanUp();
  }
  show() {
    this._canvas.showLayer(LAYER_NAME);
  }
  hide() {
    this._canvas.hideLayer(LAYER_NAME);
  }
}
ComplexPreview.$inject = [
  "canvas",
  "graphicsFactory",
  "previewSupport"
];
function isHidden$2(element) {
  return element.hidden;
}
const ComplexPreviewModule = {
  __depends__: [PreviewSupportModule],
  __init__: ["complexPreview"],
  complexPreview: ["type", ComplexPreview]
};
var ALIGNMENTS = [
  "top",
  "bottom",
  "left",
  "right"
];
var ELEMENT_LABEL_DISTANCE = 10;
function AdaptiveLabelPositioningBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.postExecuted([
    "connection.create",
    "connection.layout",
    "connection.updateWaypoints"
  ], function(event2) {
    var context = event2.context, connection = context.connection, source = connection.source, target = connection.target, hints = context.hints || {};
    if (hints.createElementsBehavior !== false) {
      checkLabelAdjustment(source);
      checkLabelAdjustment(target);
    }
  });
  this.postExecuted([
    "label.create"
  ], function(event2) {
    var context = event2.context, shape = context.shape, hints = context.hints || {};
    if (hints.createElementsBehavior !== false) {
      checkLabelAdjustment(shape.labelTarget);
    }
  });
  this.postExecuted([
    "elements.create"
  ], function(event2) {
    var context = event2.context, elements = context.elements, hints = context.hints || {};
    if (hints.createElementsBehavior !== false) {
      elements.forEach(function(element) {
        checkLabelAdjustment(element);
      });
    }
  });
  function checkLabelAdjustment(element) {
    if (!hasExternalLabel(element)) {
      return;
    }
    var optimalPosition = getOptimalPosition(element);
    if (!optimalPosition) {
      return;
    }
    adjustLabelPosition(element, optimalPosition);
  }
  function adjustLabelPosition(element, orientation) {
    var elementMid = getMid(element), label = element.label, labelMid = getMid(label);
    if (!label.parent) {
      return;
    }
    var elementTrbl = asTRBL(element);
    var newLabelMid;
    switch (orientation) {
      case "top":
        newLabelMid = {
          x: elementMid.x,
          y: elementTrbl.top - ELEMENT_LABEL_DISTANCE - label.height / 2
        };
        break;
      case "left":
        newLabelMid = {
          x: elementTrbl.left - ELEMENT_LABEL_DISTANCE - label.width / 2,
          y: elementMid.y
        };
        break;
      case "bottom":
        newLabelMid = {
          x: elementMid.x,
          y: elementTrbl.bottom + ELEMENT_LABEL_DISTANCE + label.height / 2
        };
        break;
      case "right":
        newLabelMid = {
          x: elementTrbl.right + ELEMENT_LABEL_DISTANCE + label.width / 2,
          y: elementMid.y
        };
        break;
    }
    var delta$1 = delta(newLabelMid, labelMid);
    modeling.moveShape(label, delta$1);
  }
}
e$3(AdaptiveLabelPositioningBehavior, CommandInterceptor);
AdaptiveLabelPositioningBehavior.$inject = [
  "eventBus",
  "modeling"
];
function getTakenHostAlignments(element) {
  var hostElement = element.host, elementMid = getMid(element), hostOrientation = getOrientation(elementMid, hostElement);
  var freeAlignments;
  if (hostOrientation.indexOf("-") >= 0) {
    freeAlignments = hostOrientation.split("-");
  } else {
    freeAlignments = [hostOrientation];
  }
  var takenAlignments = ALIGNMENTS.filter(function(alignment) {
    return freeAlignments.indexOf(alignment) === -1;
  });
  return takenAlignments;
}
function getTakenConnectionAlignments(element) {
  var elementMid = getMid(element);
  var takenAlignments = [].concat(
    element.incoming.map(function(c2) {
      return c2.waypoints[c2.waypoints.length - 2];
    }),
    element.outgoing.map(function(c2) {
      return c2.waypoints[1];
    })
  ).map(function(point) {
    return getApproximateOrientation(elementMid, point);
  });
  return takenAlignments;
}
function getOptimalPosition(element) {
  var labelMid = getMid(element.label);
  var elementMid = getMid(element);
  var labelOrientation = getApproximateOrientation(elementMid, labelMid);
  if (!isAligned(labelOrientation)) {
    return;
  }
  var takenAlignments = getTakenConnectionAlignments(element);
  if (element.host) {
    var takenHostAlignments = getTakenHostAlignments(element);
    takenAlignments = takenAlignments.concat(takenHostAlignments);
  }
  var freeAlignments = ALIGNMENTS.filter(function(alignment) {
    return takenAlignments.indexOf(alignment) === -1;
  });
  if (freeAlignments.indexOf(labelOrientation) !== -1) {
    return;
  }
  return freeAlignments[0];
}
function getApproximateOrientation(p0, p1) {
  return getOrientation(p1, p0, 5);
}
function isAligned(orientation) {
  return ALIGNMENTS.indexOf(orientation) !== -1;
}
function AppendBehavior(eventBus) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("shape.append", function(context) {
    var source = context.source, shape = context.shape;
    if (!context.position) {
      if (is$1(shape, "bpmn:TextAnnotation")) {
        context.position = {
          x: source.x + source.width / 2 + 75,
          y: source.y - 50 - shape.height / 2
        };
      } else {
        context.position = {
          x: source.x + source.width + 80 + shape.width / 2,
          y: source.y + source.height / 2
        };
      }
    }
  }, true);
}
e$3(AppendBehavior, CommandInterceptor);
AppendBehavior.$inject = [
  "eventBus"
];
function AssociationBehavior(injector, modeling) {
  injector.invoke(CommandInterceptor, this);
  this.postExecute("shape.move", function(context) {
    var newParent = context.newParent, shape = context.shape;
    var associations2 = filter(shape.incoming.concat(shape.outgoing), function(connection) {
      return is$1(connection, "bpmn:Association");
    });
    forEach$1(associations2, function(association) {
      modeling.moveConnection(association, { x: 0, y: 0 }, newParent);
    });
  }, true);
}
e$3(AssociationBehavior, CommandInterceptor);
AssociationBehavior.$inject = [
  "injector",
  "modeling"
];
var LOW_PRIORITY$i = 500;
function AttachEventBehavior(bpmnReplace, injector) {
  injector.invoke(CommandInterceptor, this);
  this._bpmnReplace = bpmnReplace;
  var self2 = this;
  this.postExecuted("elements.create", LOW_PRIORITY$i, function(context) {
    var elements = context.elements;
    elements = elements.filter(function(shape) {
      var host = shape.host;
      return shouldReplace$1(shape, host);
    });
    if (elements.length !== 1) {
      return;
    }
    elements.map(function(element) {
      return elements.indexOf(element);
    }).forEach(function(index2) {
      var host = elements[index2];
      context.elements[index2] = self2._replaceShape(elements[index2], host);
    });
  }, true);
  this.preExecute("elements.move", LOW_PRIORITY$i, function(context) {
    var shapes = context.shapes, host = context.newHost;
    if (shapes.length !== 1) {
      return;
    }
    var shape = shapes[0];
    if (shouldReplace$1(shape, host)) {
      context.shapes = [self2._replaceShape(shape, host)];
    }
  }, true);
}
AttachEventBehavior.$inject = [
  "bpmnReplace",
  "injector"
];
e$3(AttachEventBehavior, CommandInterceptor);
AttachEventBehavior.prototype._replaceShape = function(shape, host) {
  var eventDefinition = getEventDefinition$1(shape);
  var boundaryEvent = {
    type: "bpmn:BoundaryEvent",
    host
  };
  if (eventDefinition) {
    boundaryEvent.eventDefinitionType = eventDefinition.$type;
  }
  return this._bpmnReplace.replaceElement(shape, boundaryEvent, { layoutConnection: false });
};
function getEventDefinition$1(element) {
  var businessObject = getBusinessObject(element), eventDefinitions = businessObject.eventDefinitions;
  return eventDefinitions && eventDefinitions[0];
}
function shouldReplace$1(shape, host) {
  return !isLabel(shape) && isAny(shape, ["bpmn:IntermediateThrowEvent", "bpmn:IntermediateCatchEvent"]) && !!host;
}
function BoundaryEventBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  function getBoundaryEvents(element) {
    return filter(element.attachers, function(attacher) {
      return is$1(attacher, "bpmn:BoundaryEvent");
    });
  }
  this.postExecute("connection.create", function(event2) {
    var source = event2.context.source, target = event2.context.target, boundaryEvents = getBoundaryEvents(target);
    if (is$1(source, "bpmn:EventBasedGateway") && is$1(target, "bpmn:ReceiveTask") && boundaryEvents.length > 0) {
      modeling.removeElements(boundaryEvents);
    }
  });
  this.postExecute("connection.reconnect", function(event2) {
    var oldSource = event2.context.oldSource, newSource = event2.context.newSource;
    if (is$1(oldSource, "bpmn:Gateway") && is$1(newSource, "bpmn:EventBasedGateway")) {
      forEach$1(newSource.outgoing, function(connection) {
        var target = connection.target, attachedboundaryEvents = getBoundaryEvents(target);
        if (is$1(target, "bpmn:ReceiveTask") && attachedboundaryEvents.length > 0) {
          modeling.removeElements(attachedboundaryEvents);
        }
      });
    }
  });
}
BoundaryEventBehavior.$inject = [
  "eventBus",
  "modeling"
];
e$3(BoundaryEventBehavior, CommandInterceptor);
function CompensateBoundaryEventBehavior(eventBus, modeling, bpmnRules) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("shape.replace", handleReplacement, true);
  this.postExecuted("shape.replace", handleReplacementPostExecuted, true);
  this.preExecute("connection.create", handleNewConnection, true);
  this.postExecuted("connection.delete", handleConnectionRemoval, true);
  this.postExecuted("connection.reconnect", handleReconnection, true);
  this.postExecuted("element.updateProperties", handlePropertiesUpdate, true);
  function handleConnectionRemoval(context) {
    const source = context.source, target = context.target;
    if (isCompensationBoundaryEvent(source) && isForCompensation$1(target)) {
      removeIsForCompensationProperty(target);
    }
  }
  function handleNewConnection(context) {
    const connection = context.connection, source = context.source, target = context.target;
    if (isCompensationBoundaryEvent(source) && isForCompensationAllowed(target)) {
      addIsForCompensationProperty(target);
      removeExistingAssociations(source, [connection]);
    }
  }
  function handleReconnection(context) {
    const newTarget = context.newTarget, oldSource = context.oldSource, oldTarget = context.oldTarget;
    if (oldTarget !== newTarget) {
      const source = oldSource;
      if (isForCompensation$1(oldTarget)) {
        removeIsForCompensationProperty(oldTarget);
      }
      if (isCompensationBoundaryEvent(source) && isForCompensationAllowed(newTarget)) {
        addIsForCompensationProperty(newTarget);
      }
    }
  }
  function handlePropertiesUpdate(context) {
    const { element } = context;
    if (isForCompensation$1(element)) {
      removeDisallowedConnections(element);
      removeAttachments(element);
    } else if (isForCompensationAllowed(element)) {
      removeIncomingCompensationAssociations(element);
    }
  }
  function handleReplacement(context) {
    const {
      newData,
      oldShape
    } = context;
    if (isCompensationBoundaryEvent(context.oldShape) && newData.eventDefinitionType !== "bpmn:CompensateEventDefinition" || newData.type !== "bpmn:BoundaryEvent") {
      const targetConnection = oldShape.outgoing.find(
        ({ target }) => isForCompensation$1(target)
      );
      if (targetConnection && targetConnection.target) {
        context._connectionTarget = targetConnection.target;
      }
    } else if (!isCompensationBoundaryEvent(context.oldShape) && newData.eventDefinitionType === "bpmn:CompensateEventDefinition" && newData.type === "bpmn:BoundaryEvent") {
      const targetConnection = oldShape.outgoing.find(
        ({ target }) => isForCompensationAllowed(target)
      );
      if (targetConnection && targetConnection.target) {
        context._connectionTarget = targetConnection.target;
      }
      removeOutgoingSequenceFlows(oldShape);
    }
  }
  function handleReplacementPostExecuted(context) {
    const { _connectionTarget: target, newShape } = context;
    if (target) {
      modeling.connect(newShape, target);
    }
  }
  function addIsForCompensationProperty(target) {
    modeling.updateProperties(target, { isForCompensation: true });
  }
  function removeIsForCompensationProperty(target) {
    modeling.updateProperties(target, { isForCompensation: void 0 });
  }
  function removeDisallowedConnections(element) {
    for (const connection of element.incoming) {
      if (!bpmnRules.canConnect(connection.source, element)) {
        modeling.removeConnection(connection);
      }
    }
    for (const connection of element.outgoing) {
      if (!bpmnRules.canConnect(element, connection.target)) {
        modeling.removeConnection(connection);
      }
    }
  }
  function removeExistingAssociations(boundaryEvent, ignoredAssociations) {
    const associations2 = boundaryEvent.outgoing.filter((connection) => is$1(connection, "bpmn:Association"));
    const associationsToRemove = associations2.filter((association) => {
      return isForCompensation$1(association.target) && !ignoredAssociations.includes(association);
    });
    associationsToRemove.forEach((association) => modeling.removeConnection(association));
  }
  function removeAttachments(element) {
    const attachments = element.attachers.slice();
    if (!attachments.length) {
      return;
    }
    modeling.removeElements(attachments);
  }
  function removeIncomingCompensationAssociations(element) {
    const compensationAssociations = element.incoming.filter(
      (connection) => isCompensationBoundaryEvent(connection.source)
    );
    modeling.removeElements(compensationAssociations);
  }
  function removeOutgoingSequenceFlows(element) {
    const sequenceFlows = element.outgoing.filter(
      (connection) => is$1(connection, "bpmn:SequenceFlow")
    );
    modeling.removeElements(sequenceFlows);
  }
}
e$3(CompensateBoundaryEventBehavior, CommandInterceptor);
CompensateBoundaryEventBehavior.$inject = [
  "eventBus",
  "modeling",
  "bpmnRules"
];
function isForCompensation$1(element) {
  const bo = getBusinessObject(element);
  return bo && bo.get("isForCompensation");
}
function isCompensationBoundaryEvent(element) {
  return element && is$1(element, "bpmn:BoundaryEvent") && hasEventDefinition$2(element, "bpmn:CompensateEventDefinition");
}
function isForCompensationAllowed(element) {
  return element && is$1(element, "bpmn:Activity") && !isEventSubProcess(element);
}
function CreateBehavior(injector) {
  injector.invoke(CommandInterceptor, this);
  this.preExecute("shape.create", 1500, function(event2) {
    var context = event2.context, parent = context.parent, shape = context.shape;
    if (is$1(parent, "bpmn:Lane") && !is$1(shape, "bpmn:Lane")) {
      context.parent = getParent(parent, "bpmn:Participant");
    }
  });
}
CreateBehavior.$inject = ["injector"];
e$3(CreateBehavior, CommandInterceptor);
function CreateDataObjectBehavior(eventBus, bpmnFactory) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("shape.create", function(event2) {
    var context = event2.context, shape = context.shape;
    if (is$1(shape, "bpmn:DataObjectReference") && shape.type !== "label") {
      var dataObject = bpmnFactory.create("bpmn:DataObject");
      shape.businessObject.dataObjectRef = dataObject;
    }
  });
}
CreateDataObjectBehavior.$inject = [
  "eventBus",
  "bpmnFactory"
];
e$3(CreateDataObjectBehavior, CommandInterceptor);
var HORIZONTAL_PARTICIPANT_PADDING = 20, VERTICAL_PARTICIPANT_PADDING = 20;
var PARTICIPANT_BORDER_WIDTH = 30;
var HIGH_PRIORITY$g = 2e3;
function CreateParticipantBehavior(canvas, eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  eventBus.on([
    "create.start",
    "shape.move.start"
  ], HIGH_PRIORITY$g, function(event2) {
    var context = event2.context, shape = context.shape, rootElement = canvas.getRootElement();
    if (!is$1(shape, "bpmn:Participant") || !is$1(rootElement, "bpmn:Process") || !rootElement.children.length) {
      return;
    }
    var children = rootElement.children.filter(function(element) {
      return !is$1(element, "bpmn:Group") && !isLabel(element) && !isConnection(element);
    });
    if (!children.length) {
      return;
    }
    var childrenBBox = getBBox(children);
    var participantBounds = getParticipantBounds(shape, childrenBBox);
    assign$1(shape, participantBounds);
    context.createConstraints = getParticipantCreateConstraints(shape, childrenBBox);
  });
  eventBus.on("create.start", HIGH_PRIORITY$g, function(event2) {
    var context = event2.context, shape = context.shape, rootElement = canvas.getRootElement(), rootElementGfx = canvas.getGraphics(rootElement);
    function ensureHoveringProcess(event3) {
      event3.element = rootElement;
      event3.gfx = rootElementGfx;
    }
    if (is$1(shape, "bpmn:Participant") && is$1(rootElement, "bpmn:Process")) {
      eventBus.on("element.hover", HIGH_PRIORITY$g, ensureHoveringProcess);
      eventBus.once("create.cleanup", function() {
        eventBus.off("element.hover", ensureHoveringProcess);
      });
    }
  });
  function getOrCreateCollaboration() {
    var rootElement = canvas.getRootElement();
    if (is$1(rootElement, "bpmn:Collaboration")) {
      return rootElement;
    }
    return modeling.makeCollaboration();
  }
  this.preExecute("elements.create", HIGH_PRIORITY$g, function(context) {
    var elements = context.elements, parent = context.parent, participant = findParticipant(elements), hints;
    if (participant && is$1(parent, "bpmn:Process")) {
      context.parent = getOrCreateCollaboration();
      hints = context.hints = context.hints || {};
      hints.participant = participant;
      hints.process = parent;
      hints.processRef = getBusinessObject(participant).get("processRef");
    }
  }, true);
  this.preExecute("shape.create", function(context) {
    var parent = context.parent, shape = context.shape;
    if (is$1(shape, "bpmn:Participant") && is$1(parent, "bpmn:Process")) {
      context.parent = getOrCreateCollaboration();
      context.process = parent;
      context.processRef = getBusinessObject(shape).get("processRef");
    }
  }, true);
  this.execute("shape.create", function(context) {
    var hints = context.hints || {}, process = context.process || hints.process, shape = context.shape, participant = hints.participant;
    if (process && (!participant || shape === participant)) {
      getBusinessObject(shape).set("processRef", getBusinessObject(process));
    }
  }, true);
  this.revert("shape.create", function(context) {
    var hints = context.hints || {}, process = context.process || hints.process, processRef = context.processRef || hints.processRef, shape = context.shape, participant = hints.participant;
    if (process && (!participant || shape === participant)) {
      getBusinessObject(shape).set("processRef", processRef);
    }
  }, true);
  this.postExecute("shape.create", function(context) {
    var hints = context.hints || {}, process = context.process || context.hints.process, shape = context.shape, participant = hints.participant;
    if (process) {
      var children = process.children.slice();
      if (!participant) {
        modeling.moveElements(children, { x: 0, y: 0 }, shape);
      } else if (shape === participant) {
        modeling.moveElements(children, { x: 0, y: 0 }, participant);
      }
    }
  }, true);
}
CreateParticipantBehavior.$inject = [
  "canvas",
  "eventBus",
  "modeling"
];
e$3(CreateParticipantBehavior, CommandInterceptor);
function getParticipantBounds(shape, childrenBBox) {
  childrenBBox = {
    width: childrenBBox.width + HORIZONTAL_PARTICIPANT_PADDING * 2 + PARTICIPANT_BORDER_WIDTH,
    height: childrenBBox.height + VERTICAL_PARTICIPANT_PADDING * 2
  };
  var width = Math.max(shape.width, childrenBBox.width), height = Math.max(shape.height, childrenBBox.height);
  return {
    x: -width / 2,
    y: -height / 2,
    width,
    height
  };
}
function getParticipantCreateConstraints(shape, childrenBBox) {
  childrenBBox = asTRBL(childrenBBox);
  return {
    bottom: childrenBBox.top + shape.height / 2 - VERTICAL_PARTICIPANT_PADDING,
    left: childrenBBox.right - shape.width / 2 + HORIZONTAL_PARTICIPANT_PADDING,
    top: childrenBBox.bottom - shape.height / 2 + VERTICAL_PARTICIPANT_PADDING,
    right: childrenBBox.left + shape.width / 2 - HORIZONTAL_PARTICIPANT_PADDING - PARTICIPANT_BORDER_WIDTH
  };
}
function findParticipant(elements) {
  return find(elements, function(element) {
    return is$1(element, "bpmn:Participant");
  });
}
var TARGET_REF_PLACEHOLDER_NAME = "__targetRef_placeholder";
function DataInputAssociationBehavior(eventBus, bpmnFactory) {
  CommandInterceptor.call(this, eventBus);
  this.executed([
    "connection.create",
    "connection.delete",
    "connection.move",
    "connection.reconnect"
  ], ifDataInputAssociation(fixTargetRef));
  this.reverted([
    "connection.create",
    "connection.delete",
    "connection.move",
    "connection.reconnect"
  ], ifDataInputAssociation(fixTargetRef));
  function usesTargetRef(element, targetRef, removedConnection) {
    var inputAssociations = element.get("dataInputAssociations");
    return find(inputAssociations, function(association) {
      return association !== removedConnection && association.targetRef === targetRef;
    });
  }
  function getTargetRef(element, create2) {
    var properties = element.get("properties");
    var targetRefProp = find(properties, function(p2) {
      return p2.name === TARGET_REF_PLACEHOLDER_NAME;
    });
    if (!targetRefProp && create2) {
      targetRefProp = bpmnFactory.create("bpmn:Property", {
        name: TARGET_REF_PLACEHOLDER_NAME
      });
      add(properties, targetRefProp);
    }
    return targetRefProp;
  }
  function cleanupTargetRef(element, connection) {
    var targetRefProp = getTargetRef(element);
    if (!targetRefProp) {
      return;
    }
    if (!usesTargetRef(element, targetRefProp, connection)) {
      remove(element.get("properties"), targetRefProp);
    }
  }
  function fixTargetRef(event2) {
    var context = event2.context, connection = context.connection, connectionBo = connection.businessObject, target = connection.target, targetBo = target && target.businessObject, newTarget = context.newTarget, newTargetBo = newTarget && newTarget.businessObject, oldTarget = context.oldTarget || context.target, oldTargetBo = oldTarget && oldTarget.businessObject;
    var dataAssociation = connection.businessObject, targetRefProp;
    if (oldTargetBo && oldTargetBo !== targetBo) {
      cleanupTargetRef(oldTargetBo, connectionBo);
    }
    if (newTargetBo && newTargetBo !== targetBo) {
      cleanupTargetRef(newTargetBo, connectionBo);
    }
    if (targetBo) {
      targetRefProp = getTargetRef(targetBo, true);
      dataAssociation.targetRef = targetRefProp;
    } else {
      dataAssociation.targetRef = null;
    }
  }
}
DataInputAssociationBehavior.$inject = [
  "eventBus",
  "bpmnFactory"
];
e$3(DataInputAssociationBehavior, CommandInterceptor);
function ifDataInputAssociation(fn) {
  return function(event2) {
    var context = event2.context, connection = context.connection;
    if (is$1(connection, "bpmn:DataInputAssociation")) {
      return fn(event2);
    }
  };
}
function UpdateSemanticParentHandler(bpmnUpdater) {
  this._bpmnUpdater = bpmnUpdater;
}
UpdateSemanticParentHandler.$inject = ["bpmnUpdater"];
UpdateSemanticParentHandler.prototype.execute = function(context) {
  var dataStoreBo = context.dataStoreBo, dataStoreDi = context.dataStoreDi, newSemanticParent = context.newSemanticParent, newDiParent = context.newDiParent;
  context.oldSemanticParent = dataStoreBo.$parent;
  context.oldDiParent = dataStoreDi.$parent;
  this._bpmnUpdater.updateSemanticParent(dataStoreBo, newSemanticParent);
  this._bpmnUpdater.updateDiParent(dataStoreDi, newDiParent);
  return [];
};
UpdateSemanticParentHandler.prototype.revert = function(context) {
  var dataStoreBo = context.dataStoreBo, dataStoreDi = context.dataStoreDi, oldSemanticParent = context.oldSemanticParent, oldDiParent = context.oldDiParent;
  this._bpmnUpdater.updateSemanticParent(dataStoreBo, oldSemanticParent);
  this._bpmnUpdater.updateDiParent(dataStoreDi, oldDiParent);
  return [];
};
function DataStoreBehavior(canvas, commandStack, elementRegistry, eventBus) {
  CommandInterceptor.call(this, eventBus);
  commandStack.registerHandler("dataStore.updateContainment", UpdateSemanticParentHandler);
  function getFirstParticipantWithProcessRef() {
    return elementRegistry.filter(function(element) {
      return is$1(element, "bpmn:Participant") && getBusinessObject(element).processRef;
    })[0];
  }
  function getDataStores(element) {
    return element.children.filter(function(child) {
      return is$1(child, "bpmn:DataStoreReference") && !child.labelTarget;
    });
  }
  function updateDataStoreParent(dataStore, newDataStoreParent) {
    var dataStoreBo = dataStore.businessObject || dataStore;
    newDataStoreParent = newDataStoreParent || getFirstParticipantWithProcessRef();
    if (newDataStoreParent) {
      var newDataStoreParentBo = newDataStoreParent.businessObject || newDataStoreParent;
      commandStack.execute("dataStore.updateContainment", {
        dataStoreBo,
        dataStoreDi: getDi(dataStore),
        newSemanticParent: newDataStoreParentBo.processRef || newDataStoreParentBo,
        newDiParent: getDi(newDataStoreParent)
      });
    }
  }
  this.preExecute("shape.create", function(event2) {
    var context = event2.context, shape = context.shape;
    if (is$1(shape, "bpmn:DataStoreReference") && shape.type !== "label") {
      if (!context.hints) {
        context.hints = {};
      }
      context.hints.autoResize = false;
    }
  });
  this.preExecute("elements.move", function(event2) {
    var context = event2.context, shapes = context.shapes;
    var dataStoreReferences = shapes.filter(function(shape) {
      return is$1(shape, "bpmn:DataStoreReference");
    });
    if (dataStoreReferences.length) {
      if (!context.hints) {
        context.hints = {};
      }
      context.hints.autoResize = shapes.filter(function(shape) {
        return !is$1(shape, "bpmn:DataStoreReference");
      });
    }
  });
  this.postExecute("shape.create", function(event2) {
    var context = event2.context, shape = context.shape, parent = shape.parent;
    if (is$1(shape, "bpmn:DataStoreReference") && shape.type !== "label" && is$1(parent, "bpmn:Collaboration")) {
      updateDataStoreParent(shape);
    }
  });
  this.postExecute("shape.move", function(event2) {
    var context = event2.context, shape = context.shape, oldParent = context.oldParent, parent = shape.parent;
    if (is$1(oldParent, "bpmn:Collaboration")) {
      return;
    }
    if (is$1(shape, "bpmn:DataStoreReference") && shape.type !== "label" && is$1(parent, "bpmn:Collaboration")) {
      var participant = is$1(oldParent, "bpmn:Participant") ? oldParent : getAncestor(oldParent, "bpmn:Participant");
      updateDataStoreParent(shape, participant);
    }
  });
  this.postExecute("shape.delete", function(event2) {
    var context = event2.context, shape = context.shape, rootElement = canvas.getRootElement();
    if (isAny(shape, ["bpmn:Participant", "bpmn:SubProcess"]) && is$1(rootElement, "bpmn:Collaboration")) {
      getDataStores(rootElement).filter(function(dataStore) {
        return isDescendant(dataStore, shape);
      }).forEach(function(dataStore) {
        updateDataStoreParent(dataStore);
      });
    }
  });
  this.postExecute("canvas.updateRoot", function(event2) {
    var context = event2.context, oldRoot = context.oldRoot, newRoot = context.newRoot;
    var dataStores = getDataStores(oldRoot);
    dataStores.forEach(function(dataStore) {
      if (is$1(newRoot, "bpmn:Process")) {
        updateDataStoreParent(dataStore, newRoot);
      }
    });
  });
}
DataStoreBehavior.$inject = [
  "canvas",
  "commandStack",
  "elementRegistry",
  "eventBus"
];
e$3(DataStoreBehavior, CommandInterceptor);
function isDescendant(descendant, ancestor) {
  var descendantBo = descendant.businessObject || descendant, ancestorBo = ancestor.businessObject || ancestor;
  while (descendantBo.$parent) {
    if (descendantBo.$parent === ancestorBo.processRef || ancestorBo) {
      return true;
    }
    descendantBo = descendantBo.$parent;
  }
  return false;
}
function getAncestor(element, type) {
  while (element.parent) {
    if (is$1(element.parent, type)) {
      return element.parent;
    }
    element = element.parent;
  }
}
var max$5 = Math.max, min$3 = Math.min;
var DEFAULT_CHILD_BOX_PADDING = 20;
function substractTRBL(trblA, trblB) {
  return {
    top: trblA.top - trblB.top,
    right: trblA.right - trblB.right,
    bottom: trblA.bottom - trblB.bottom,
    left: trblA.left - trblB.left
  };
}
function resizeBounds$1(bounds, direction, delta2) {
  var dx = delta2.x, dy = delta2.y;
  var newBounds = {
    x: bounds.x,
    y: bounds.y,
    width: bounds.width,
    height: bounds.height
  };
  if (direction.indexOf("n") !== -1) {
    newBounds.y = bounds.y + dy;
    newBounds.height = bounds.height - dy;
  } else if (direction.indexOf("s") !== -1) {
    newBounds.height = bounds.height + dy;
  }
  if (direction.indexOf("e") !== -1) {
    newBounds.width = bounds.width + dx;
  } else if (direction.indexOf("w") !== -1) {
    newBounds.x = bounds.x + dx;
    newBounds.width = bounds.width - dx;
  }
  return newBounds;
}
function resizeTRBL(bounds, resize) {
  return {
    x: bounds.x + (resize.left || 0),
    y: bounds.y + (resize.top || 0),
    width: bounds.width - (resize.left || 0) + (resize.right || 0),
    height: bounds.height - (resize.top || 0) + (resize.bottom || 0)
  };
}
function applyConstraints(attr2, trbl, resizeConstraints) {
  var value = trbl[attr2], minValue = resizeConstraints.min && resizeConstraints.min[attr2], maxValue = resizeConstraints.max && resizeConstraints.max[attr2];
  if (isNumber(minValue)) {
    value = (/top|left/.test(attr2) ? min$3 : max$5)(value, minValue);
  }
  if (isNumber(maxValue)) {
    value = (/top|left/.test(attr2) ? max$5 : min$3)(value, maxValue);
  }
  return value;
}
function ensureConstraints$2(currentBounds, resizeConstraints) {
  if (!resizeConstraints) {
    return currentBounds;
  }
  var currentTrbl = asTRBL(currentBounds);
  return asBounds({
    top: applyConstraints("top", currentTrbl, resizeConstraints),
    right: applyConstraints("right", currentTrbl, resizeConstraints),
    bottom: applyConstraints("bottom", currentTrbl, resizeConstraints),
    left: applyConstraints("left", currentTrbl, resizeConstraints)
  });
}
function getMinResizeBounds(direction, currentBounds, minDimensions, childrenBounds) {
  var currentBox = asTRBL(currentBounds);
  var minBox = {
    top: /n/.test(direction) ? currentBox.bottom - minDimensions.height : currentBox.top,
    left: /w/.test(direction) ? currentBox.right - minDimensions.width : currentBox.left,
    bottom: /s/.test(direction) ? currentBox.top + minDimensions.height : currentBox.bottom,
    right: /e/.test(direction) ? currentBox.left + minDimensions.width : currentBox.right
  };
  var childrenBox = childrenBounds ? asTRBL(childrenBounds) : minBox;
  var combinedBox = {
    top: min$3(minBox.top, childrenBox.top),
    left: min$3(minBox.left, childrenBox.left),
    bottom: max$5(minBox.bottom, childrenBox.bottom),
    right: max$5(minBox.right, childrenBox.right)
  };
  return asBounds(combinedBox);
}
function asPadding(mayBePadding, defaultValue) {
  if (typeof mayBePadding !== "undefined") {
    return mayBePadding;
  } else {
    return DEFAULT_CHILD_BOX_PADDING;
  }
}
function addPadding$1(bbox, padding) {
  var left, right, top, bottom;
  if (typeof padding === "object") {
    left = asPadding(padding.left);
    right = asPadding(padding.right);
    top = asPadding(padding.top);
    bottom = asPadding(padding.bottom);
  } else {
    left = right = top = bottom = asPadding(padding);
  }
  return {
    x: bbox.x - left,
    y: bbox.y - top,
    width: bbox.width + left + right,
    height: bbox.height + top + bottom
  };
}
function isBBoxChild(element) {
  if (element.waypoints) {
    return false;
  }
  if (element.type === "label") {
    return false;
  }
  return true;
}
function computeChildrenBBox(shapeOrChildren, padding) {
  var elements;
  if (shapeOrChildren.length === void 0) {
    elements = filter(shapeOrChildren.children, isBBoxChild);
  } else {
    elements = shapeOrChildren;
  }
  if (elements.length) {
    return addPadding$1(getBBox(elements), padding);
  }
}
var abs$4 = Math.abs;
function getTRBLResize(oldBounds, newBounds) {
  return substractTRBL(asTRBL(newBounds), asTRBL(oldBounds));
}
var LANE_PARENTS = [
  "bpmn:Participant",
  "bpmn:Process",
  "bpmn:SubProcess"
];
var LANE_INDENTATION = 30;
function collectLanes(shape, collectedShapes) {
  collectedShapes = collectedShapes || [];
  shape.children.filter(function(s2) {
    if (is$1(s2, "bpmn:Lane")) {
      collectLanes(s2, collectedShapes);
      collectedShapes.push(s2);
    }
  });
  return collectedShapes;
}
function getChildLanes(shape) {
  return shape.children.filter(function(c2) {
    return is$1(c2, "bpmn:Lane");
  });
}
function getLanesRoot(shape) {
  return getParent(shape, LANE_PARENTS) || shape;
}
function computeLanesResize(shape, newBounds) {
  var rootElement = getLanesRoot(shape);
  var initialShapes = is$1(rootElement, "bpmn:Process") ? [] : [rootElement];
  var allLanes = collectLanes(rootElement, initialShapes), shapeTrbl = asTRBL(shape), shapeNewTrbl = asTRBL(newBounds), trblResize = getTRBLResize(shape, newBounds), resizeNeeded = [];
  var isHorizontalLane = isHorizontal$3(shape);
  allLanes.forEach(function(other) {
    if (other === shape) {
      return;
    }
    var topResize = isHorizontalLane ? 0 : trblResize.top, rightResize = isHorizontalLane ? trblResize.right : 0, bottomResize = isHorizontalLane ? 0 : trblResize.bottom, leftResize = isHorizontalLane ? trblResize.left : 0;
    var otherTrbl = asTRBL(other);
    if (trblResize.top) {
      if (abs$4(otherTrbl.bottom - shapeTrbl.top) < 10) {
        bottomResize = shapeNewTrbl.top - otherTrbl.bottom;
      }
      if (abs$4(otherTrbl.top - shapeTrbl.top) < 5) {
        topResize = shapeNewTrbl.top - otherTrbl.top;
      }
    }
    if (trblResize.left) {
      if (abs$4(otherTrbl.right - shapeTrbl.left) < 10) {
        rightResize = shapeNewTrbl.left - otherTrbl.right;
      }
      if (abs$4(otherTrbl.left - shapeTrbl.left) < 5) {
        leftResize = shapeNewTrbl.left - otherTrbl.left;
      }
    }
    if (trblResize.bottom) {
      if (abs$4(otherTrbl.top - shapeTrbl.bottom) < 10) {
        topResize = shapeNewTrbl.bottom - otherTrbl.top;
      }
      if (abs$4(otherTrbl.bottom - shapeTrbl.bottom) < 5) {
        bottomResize = shapeNewTrbl.bottom - otherTrbl.bottom;
      }
    }
    if (trblResize.right) {
      if (abs$4(otherTrbl.left - shapeTrbl.right) < 10) {
        leftResize = shapeNewTrbl.right - otherTrbl.left;
      }
      if (abs$4(otherTrbl.right - shapeTrbl.right) < 5) {
        rightResize = shapeNewTrbl.right - otherTrbl.right;
      }
    }
    if (topResize || rightResize || bottomResize || leftResize) {
      resizeNeeded.push({
        shape: other,
        newBounds: resizeTRBL(other, {
          top: topResize,
          right: rightResize,
          bottom: bottomResize,
          left: leftResize
        })
      });
    }
  });
  return resizeNeeded;
}
var LOW_PRIORITY$h = 500;
function DeleteLaneBehavior(eventBus, spaceTool) {
  CommandInterceptor.call(this, eventBus);
  function compensateLaneDelete(shape, oldParent) {
    var isHorizontalLane = isHorizontal$3(shape);
    var siblings = getChildLanes(oldParent);
    var topAffected = [];
    var bottomAffected = [];
    var leftAffected = [];
    var rightAffected = [];
    eachElement(siblings, function(element) {
      if (isHorizontalLane) {
        if (element.y > shape.y) {
          bottomAffected.push(element);
        } else {
          topAffected.push(element);
        }
      } else {
        if (element.x > shape.x) {
          rightAffected.push(element);
        } else {
          leftAffected.push(element);
        }
      }
      return element.children;
    });
    if (!siblings.length) {
      return;
    }
    var offset;
    if (isHorizontalLane) {
      if (bottomAffected.length && topAffected.length) {
        offset = shape.height / 2;
      } else {
        offset = shape.height;
      }
    } else {
      if (rightAffected.length && leftAffected.length) {
        offset = shape.width / 2;
      } else {
        offset = shape.width;
      }
    }
    var topAdjustments, bottomAdjustments, leftAdjustments, rightAdjustments;
    if (topAffected.length) {
      topAdjustments = spaceTool.calculateAdjustments(
        topAffected,
        "y",
        offset,
        shape.y - 10
      );
      spaceTool.makeSpace(
        topAdjustments.movingShapes,
        topAdjustments.resizingShapes,
        { x: 0, y: offset },
        "s"
      );
    }
    if (bottomAffected.length) {
      bottomAdjustments = spaceTool.calculateAdjustments(
        bottomAffected,
        "y",
        -offset,
        shape.y + shape.height + 10
      );
      spaceTool.makeSpace(
        bottomAdjustments.movingShapes,
        bottomAdjustments.resizingShapes,
        { x: 0, y: -offset },
        "n"
      );
    }
    if (leftAffected.length) {
      leftAdjustments = spaceTool.calculateAdjustments(
        leftAffected,
        "x",
        offset,
        shape.x - 10
      );
      spaceTool.makeSpace(
        leftAdjustments.movingShapes,
        leftAdjustments.resizingShapes,
        { x: offset, y: 0 },
        "e"
      );
    }
    if (rightAffected.length) {
      rightAdjustments = spaceTool.calculateAdjustments(
        rightAffected,
        "x",
        -offset,
        shape.x + shape.width + 10
      );
      spaceTool.makeSpace(
        rightAdjustments.movingShapes,
        rightAdjustments.resizingShapes,
        { x: -offset, y: 0 },
        "w"
      );
    }
  }
  this.postExecuted("shape.delete", LOW_PRIORITY$h, function(event2) {
    var context = event2.context, hints = context.hints, shape = context.shape, oldParent = context.oldParent;
    if (!is$1(shape, "bpmn:Lane")) {
      return;
    }
    if (hints && hints.nested) {
      return;
    }
    compensateLaneDelete(shape, oldParent);
  });
}
DeleteLaneBehavior.$inject = [
  "eventBus",
  "spaceTool"
];
e$3(DeleteLaneBehavior, CommandInterceptor);
var LOW_PRIORITY$g = 500;
function DetachEventBehavior(bpmnReplace, injector) {
  injector.invoke(CommandInterceptor, this);
  this._bpmnReplace = bpmnReplace;
  var self2 = this;
  this.postExecuted("elements.create", LOW_PRIORITY$g, function(context) {
    var elements = context.elements;
    elements.filter(function(shape) {
      var host = shape.host;
      return shouldReplace(shape, host);
    }).map(function(shape) {
      return elements.indexOf(shape);
    }).forEach(function(index2) {
      context.elements[index2] = self2._replaceShape(elements[index2]);
    });
  }, true);
  this.preExecute("elements.move", LOW_PRIORITY$g, function(context) {
    var shapes = context.shapes, newHost = context.newHost;
    shapes.forEach(function(shape, index2) {
      var host = shape.host;
      if (shouldReplace(shape, includes$7(shapes, host) ? host : newHost)) {
        shapes[index2] = self2._replaceShape(shape);
      }
    });
  }, true);
}
DetachEventBehavior.$inject = [
  "bpmnReplace",
  "injector"
];
e$3(DetachEventBehavior, CommandInterceptor);
DetachEventBehavior.prototype._replaceShape = function(shape) {
  var eventDefinition = getEventDefinition(shape), intermediateEvent;
  if (eventDefinition) {
    intermediateEvent = {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: eventDefinition.$type
    };
  } else {
    intermediateEvent = {
      type: "bpmn:IntermediateThrowEvent"
    };
  }
  return this._bpmnReplace.replaceElement(shape, intermediateEvent, { layoutConnection: false });
};
function getEventDefinition(element) {
  var businessObject = getBusinessObject(element), eventDefinitions = businessObject.eventDefinitions;
  return eventDefinitions && eventDefinitions[0];
}
function shouldReplace(shape, host) {
  return !isLabel(shape) && is$1(shape, "bpmn:BoundaryEvent") && !host;
}
function includes$7(array, item) {
  return array.indexOf(item) !== -1;
}
function DropOnFlowBehavior(eventBus, bpmnRules, modeling) {
  CommandInterceptor.call(this, eventBus);
  function insertShape(shape, targetFlow, positionOrBounds) {
    var waypoints = targetFlow.waypoints, waypointsBefore, waypointsAfter, dockingPoint, source, target, incomingConnection, outgoingConnection, oldOutgoing = shape.outgoing.slice(), oldIncoming = shape.incoming.slice();
    var mid2;
    if (isNumber(positionOrBounds.width)) {
      mid2 = getMid(positionOrBounds);
    } else {
      mid2 = positionOrBounds;
    }
    var intersection2 = getApproxIntersection(waypoints, mid2);
    if (intersection2) {
      waypointsBefore = waypoints.slice(0, intersection2.index);
      waypointsAfter = waypoints.slice(intersection2.index + (intersection2.bendpoint ? 1 : 0));
      if (!waypointsBefore.length || !waypointsAfter.length) {
        return;
      }
      dockingPoint = intersection2.bendpoint ? waypoints[intersection2.index] : mid2;
      if (waypointsBefore.length === 1 || !isPointInsideBBox(shape, waypointsBefore[waypointsBefore.length - 1])) {
        waypointsBefore.push(copy(dockingPoint));
      }
      if (waypointsAfter.length === 1 || !isPointInsideBBox(shape, waypointsAfter[0])) {
        waypointsAfter.unshift(copy(dockingPoint));
      }
    }
    source = targetFlow.source;
    target = targetFlow.target;
    if (bpmnRules.canConnect(source, shape, targetFlow)) {
      modeling.reconnectEnd(targetFlow, shape, waypointsBefore || mid2);
      incomingConnection = targetFlow;
    }
    if (bpmnRules.canConnect(shape, target, targetFlow)) {
      if (!incomingConnection) {
        modeling.reconnectStart(targetFlow, shape, waypointsAfter || mid2);
        outgoingConnection = targetFlow;
      } else {
        outgoingConnection = modeling.connect(
          shape,
          target,
          { type: targetFlow.type, waypoints: waypointsAfter }
        );
      }
    }
    var duplicateConnections = [].concat(
      incomingConnection && filter(oldIncoming, function(connection) {
        return connection.source === incomingConnection.source;
      }) || [],
      outgoingConnection && filter(oldOutgoing, function(connection) {
        return connection.target === outgoingConnection.target;
      }) || []
    );
    if (duplicateConnections.length) {
      modeling.removeElements(duplicateConnections);
    }
  }
  this.preExecute("elements.move", function(context) {
    var newParent = context.newParent, shapes = context.shapes, delta2 = context.delta, shape = shapes[0];
    if (!shape || !newParent) {
      return;
    }
    if (newParent && newParent.waypoints) {
      context.newParent = newParent = newParent.parent;
    }
    var shapeMid = getMid(shape);
    var newShapeMid = {
      x: shapeMid.x + delta2.x,
      y: shapeMid.y + delta2.y
    };
    var connection = find(newParent.children, function(element) {
      var canInsert2 = bpmnRules.canInsert(shapes, element);
      return canInsert2 && getApproxIntersection(element.waypoints, newShapeMid);
    });
    if (connection) {
      context.targetFlow = connection;
      context.position = newShapeMid;
    }
  }, true);
  this.postExecuted("elements.move", function(context) {
    var shapes = context.shapes, targetFlow = context.targetFlow, position = context.position;
    if (targetFlow) {
      insertShape(shapes[0], targetFlow, position);
    }
  }, true);
  this.preExecute("shape.create", function(context) {
    var parent = context.parent, shape = context.shape;
    if (bpmnRules.canInsert(shape, parent)) {
      context.targetFlow = parent;
      context.parent = parent.parent;
    }
  }, true);
  this.postExecuted("shape.create", function(context) {
    var shape = context.shape, targetFlow = context.targetFlow, positionOrBounds = context.position;
    if (targetFlow) {
      insertShape(shape, targetFlow, positionOrBounds);
    }
  }, true);
}
e$3(DropOnFlowBehavior, CommandInterceptor);
DropOnFlowBehavior.$inject = [
  "eventBus",
  "bpmnRules",
  "modeling"
];
function isPointInsideBBox(bbox, point) {
  var x2 = point.x, y2 = point.y;
  return x2 >= bbox.x && x2 <= bbox.x + bbox.width && y2 >= bbox.y && y2 <= bbox.y + bbox.height;
}
function copy(obj) {
  return assign$1({}, obj);
}
function EventBasedGatewayBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.preExecuted("connection.create", function(event2) {
    var context = event2.context, connection = context.connection, source = context.source, target = context.target, hints = context.hints;
    if (hints && hints.createElementsBehavior === false) {
      return;
    }
    if (!isSequenceFlow(connection)) {
      return;
    }
    var sequenceFlows = [];
    if (is$1(source, "bpmn:EventBasedGateway")) {
      sequenceFlows = target.incoming.filter(
        (flow) => flow !== connection && isSequenceFlow(flow)
      );
    } else {
      sequenceFlows = target.incoming.filter(
        (flow) => flow !== connection && isSequenceFlow(flow) && is$1(flow.source, "bpmn:EventBasedGateway")
      );
    }
    sequenceFlows.forEach(function(sequenceFlow) {
      modeling.removeConnection(sequenceFlow);
    });
  });
  this.preExecuted("shape.replace", function(event2) {
    var context = event2.context, newShape = context.newShape;
    if (!is$1(newShape, "bpmn:EventBasedGateway")) {
      return;
    }
    var targets = newShape.outgoing.filter(isSequenceFlow).reduce(function(targets2, sequenceFlow) {
      if (!targets2.includes(sequenceFlow.target)) {
        return targets2.concat(sequenceFlow.target);
      }
      return targets2;
    }, []);
    targets.forEach(function(target) {
      target.incoming.filter(isSequenceFlow).forEach(function(sequenceFlow) {
        const sequenceFlowsFromNewShape = target.incoming.filter(isSequenceFlow).filter(function(sequenceFlow2) {
          return sequenceFlow2.source === newShape;
        });
        if (sequenceFlow.source !== newShape || sequenceFlowsFromNewShape.length > 1) {
          modeling.removeConnection(sequenceFlow);
        }
      });
    });
  });
}
EventBasedGatewayBehavior.$inject = [
  "eventBus",
  "modeling"
];
e$3(EventBasedGatewayBehavior, CommandInterceptor);
function isSequenceFlow(connection) {
  return is$1(connection, "bpmn:SequenceFlow");
}
var HIGH_PRIORITY$f = 1500;
var HIGHEST_PRIORITY = 2e3;
function FixHoverBehavior(elementRegistry, eventBus, canvas) {
  eventBus.on([
    "create.hover",
    "create.move",
    "create.out",
    "create.end",
    "shape.move.hover",
    "shape.move.move",
    "shape.move.out",
    "shape.move.end"
  ], HIGH_PRIORITY$f, function(event2) {
    var context = event2.context, shape = context.shape || event2.shape, hover = event2.hover;
    if (is$1(hover, "bpmn:Lane") && !isAny(shape, ["bpmn:Lane", "bpmn:Participant"])) {
      event2.hover = getLanesRoot(hover);
      event2.hoverGfx = elementRegistry.getGraphics(event2.hover);
    }
    var rootElement = canvas.getRootElement();
    if (hover !== rootElement && (shape.labelTarget || isAny(shape, ["bpmn:Group", "bpmn:TextAnnotation"]))) {
      event2.hover = rootElement;
      event2.hoverGfx = elementRegistry.getGraphics(event2.hover);
    }
  });
  eventBus.on([
    "connect.hover",
    "connect.out",
    "connect.end",
    "connect.cleanup",
    "global-connect.hover",
    "global-connect.out",
    "global-connect.end",
    "global-connect.cleanup"
  ], HIGH_PRIORITY$f, function(event2) {
    var hover = event2.hover;
    if (is$1(hover, "bpmn:Lane")) {
      event2.hover = getLanesRoot(hover) || hover;
      event2.hoverGfx = elementRegistry.getGraphics(event2.hover);
    }
  });
  eventBus.on([
    "bendpoint.move.hover"
  ], HIGH_PRIORITY$f, function(event2) {
    var context = event2.context, hover = event2.hover, type = context.type;
    if (is$1(hover, "bpmn:Lane") && /reconnect/.test(type)) {
      event2.hover = getLanesRoot(hover) || hover;
      event2.hoverGfx = elementRegistry.getGraphics(event2.hover);
    }
  });
  eventBus.on([
    "connect.start"
  ], HIGH_PRIORITY$f, function(event2) {
    var context = event2.context, start = context.start;
    if (is$1(start, "bpmn:Lane")) {
      context.start = getLanesRoot(start) || start;
    }
  });
  eventBus.on("shape.move.start", HIGHEST_PRIORITY, function(event2) {
    var shape = event2.shape;
    if (is$1(shape, "bpmn:Lane")) {
      event2.shape = getLanesRoot(shape) || shape;
    }
  });
  eventBus.on("spaceTool.move", HIGHEST_PRIORITY, function(event2) {
    var hover = event2.hover;
    if (hover && is$1(hover, "bpmn:Lane")) {
      event2.hover = getLanesRoot(hover);
    }
  });
}
FixHoverBehavior.$inject = [
  "elementRegistry",
  "eventBus",
  "canvas"
];
function createCategory(bpmnFactory) {
  return bpmnFactory.create("bpmn:Category");
}
function createCategoryValue(bpmnFactory) {
  return bpmnFactory.create("bpmn:CategoryValue");
}
function linkCategoryValue(categoryValue, category, definitions) {
  add(category.get("categoryValue"), categoryValue);
  categoryValue.$parent = category;
  add(definitions.get("rootElements"), category);
  category.$parent = definitions;
  return categoryValue;
}
function unlinkCategoryValue(categoryValue) {
  var category = categoryValue.$parent;
  if (category) {
    remove(category.get("categoryValue"), categoryValue);
    categoryValue.$parent = null;
  }
  return categoryValue;
}
function unlinkCategory(category) {
  var definitions = category.$parent;
  if (definitions) {
    remove(definitions.get("rootElements"), category);
    category.$parent = null;
  }
  return category;
}
var LOWER_PRIORITY$1 = 770;
function GroupBehavior(bpmnFactory, bpmnjs, elementRegistry, eventBus, injector, moddleCopy) {
  injector.invoke(CommandInterceptor, this);
  function getGroupElements() {
    return elementRegistry.filter(function(e2) {
      return is$1(e2, "bpmn:Group");
    });
  }
  function isReferencedCategory(elements, category) {
    return elements.some(function(element) {
      var businessObject = getBusinessObject(element);
      var _category = businessObject.categoryValueRef && businessObject.categoryValueRef.$parent;
      return _category === category;
    });
  }
  function isReferencedCategoryValue(elements, categoryValue) {
    return elements.some(function(element) {
      var businessObject = getBusinessObject(element);
      return businessObject.categoryValueRef === categoryValue;
    });
  }
  function removeCategoryValue(categoryValue, category, businessObject) {
    var groups = getGroupElements().filter(function(element) {
      return element.businessObject !== businessObject;
    });
    if (category && !isReferencedCategory(groups, category)) {
      unlinkCategory(category);
    }
    if (categoryValue && !isReferencedCategoryValue(groups, categoryValue)) {
      unlinkCategoryValue(categoryValue);
    }
  }
  function addCategoryValue(categoryValue, category) {
    return linkCategoryValue(categoryValue, category, bpmnjs.getDefinitions());
  }
  function setCategoryValue(element, context) {
    var businessObject = getBusinessObject(element), categoryValue = businessObject.categoryValueRef;
    if (!categoryValue) {
      categoryValue = businessObject.categoryValueRef = context.categoryValue = context.categoryValue || createCategoryValue(bpmnFactory);
    }
    var category = categoryValue.$parent;
    if (!category) {
      category = categoryValue.$parent = context.category = context.category || createCategory(bpmnFactory);
    }
    addCategoryValue(categoryValue, category, bpmnjs.getDefinitions());
  }
  function unsetCategoryValue(element, context) {
    var category = context.category, categoryValue = context.categoryValue, businessObject = getBusinessObject(element);
    if (categoryValue) {
      businessObject.categoryValueRef = null;
      removeCategoryValue(categoryValue, category, businessObject);
    } else {
      removeCategoryValue(null, businessObject.categoryValueRef.$parent, businessObject);
    }
  }
  this.execute("label.create", function(event2) {
    var context = event2.context, labelTarget = context.labelTarget;
    if (!is$1(labelTarget, "bpmn:Group")) {
      return;
    }
    setCategoryValue(labelTarget, context);
  });
  this.revert("label.create", function(event2) {
    var context = event2.context, labelTarget = context.labelTarget;
    if (!is$1(labelTarget, "bpmn:Group")) {
      return;
    }
    unsetCategoryValue(labelTarget, context);
  });
  this.execute("shape.delete", function(event2) {
    var context = event2.context, shape = context.shape, businessObject = getBusinessObject(shape);
    if (!is$1(shape, "bpmn:Group") || shape.labelTarget) {
      return;
    }
    var categoryValue = context.categoryValue = businessObject.categoryValueRef, category;
    if (categoryValue) {
      category = context.category = categoryValue.$parent;
      removeCategoryValue(categoryValue, category, businessObject);
      businessObject.categoryValueRef = null;
    }
  });
  this.reverted("shape.delete", function(event2) {
    var context = event2.context, shape = context.shape;
    if (!is$1(shape, "bpmn:Group") || shape.labelTarget) {
      return;
    }
    var category = context.category, categoryValue = context.categoryValue, businessObject = getBusinessObject(shape);
    if (categoryValue) {
      businessObject.categoryValueRef = categoryValue;
      addCategoryValue(categoryValue, category);
    }
  });
  this.execute("shape.create", function(event2) {
    var context = event2.context, shape = context.shape;
    if (!is$1(shape, "bpmn:Group") || shape.labelTarget) {
      return;
    }
    if (getBusinessObject(shape).categoryValueRef) {
      setCategoryValue(shape, context);
    }
  });
  this.reverted("shape.create", function(event2) {
    var context = event2.context, shape = context.shape;
    if (!is$1(shape, "bpmn:Group") || shape.labelTarget) {
      return;
    }
    if (getBusinessObject(shape).categoryValueRef) {
      unsetCategoryValue(shape, context);
    }
  });
  function copy2(bo, clone2) {
    var targetBo = bpmnFactory.create(bo.$type);
    return moddleCopy.copyElement(bo, targetBo, null, clone2);
  }
  eventBus.on("copyPaste.copyElement", LOWER_PRIORITY$1, function(context) {
    var descriptor = context.descriptor, element = context.element;
    if (!is$1(element, "bpmn:Group") || element.labelTarget) {
      return;
    }
    var groupBo = getBusinessObject(element);
    if (groupBo.categoryValueRef) {
      var categoryValue = groupBo.categoryValueRef;
      descriptor.categoryValue = copy2(categoryValue, true);
      if (categoryValue.$parent) {
        descriptor.category = copy2(categoryValue.$parent, true);
      }
    }
  });
  eventBus.on("copyPaste.pasteElement", LOWER_PRIORITY$1, function(context) {
    var descriptor = context.descriptor, businessObject = descriptor.businessObject, categoryValue = descriptor.categoryValue, category = descriptor.category;
    if (categoryValue) {
      categoryValue = businessObject.categoryValueRef = copy2(categoryValue);
    }
    if (category) {
      categoryValue.$parent = copy2(category);
    }
    delete descriptor.category;
    delete descriptor.categoryValue;
  });
}
GroupBehavior.$inject = [
  "bpmnFactory",
  "bpmnjs",
  "elementRegistry",
  "eventBus",
  "injector",
  "moddleCopy"
];
e$3(GroupBehavior, CommandInterceptor);
function lineIntersect(l1s, l1e, l2s, l2e) {
  var denominator, a2, b2, c2, numerator;
  denominator = (l2e.y - l2s.y) * (l1e.x - l1s.x) - (l2e.x - l2s.x) * (l1e.y - l1s.y);
  if (denominator == 0) {
    return null;
  }
  a2 = l1s.y - l2s.y;
  b2 = l1s.x - l2s.x;
  numerator = (l2e.x - l2s.x) * a2 - (l2e.y - l2s.y) * b2;
  c2 = numerator / denominator;
  return {
    x: Math.round(l1s.x + c2 * (l1e.x - l1s.x)),
    y: Math.round(l1s.y + c2 * (l1e.y - l1s.y))
  };
}
function ImportDockingFix(eventBus) {
  function adjustDocking(startPoint, nextPoint, elementMid) {
    var elementTop = {
      x: elementMid.x,
      y: elementMid.y - 50
    };
    var elementLeft = {
      x: elementMid.x - 50,
      y: elementMid.y
    };
    var verticalIntersect = lineIntersect(startPoint, nextPoint, elementMid, elementTop), horizontalIntersect = lineIntersect(startPoint, nextPoint, elementMid, elementLeft);
    var centerIntersect;
    if (verticalIntersect && horizontalIntersect) {
      if (getDistance$1(verticalIntersect, elementMid) > getDistance$1(horizontalIntersect, elementMid)) {
        centerIntersect = horizontalIntersect;
      } else {
        centerIntersect = verticalIntersect;
      }
    } else {
      centerIntersect = verticalIntersect || horizontalIntersect;
    }
    startPoint.original = centerIntersect;
  }
  function fixDockings(connection) {
    var waypoints = connection.waypoints;
    adjustDocking(
      waypoints[0],
      waypoints[1],
      getMid(connection.source)
    );
    adjustDocking(
      waypoints[waypoints.length - 1],
      waypoints[waypoints.length - 2],
      getMid(connection.target)
    );
  }
  eventBus.on("bpmnElement.added", function(e2) {
    var element = e2.element;
    if (element.waypoints) {
      fixDockings(element);
    }
  });
}
ImportDockingFix.$inject = [
  "eventBus"
];
function getDistance$1(p1, p2) {
  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}
function IsHorizontalFix(eventBus) {
  CommandInterceptor.call(this, eventBus);
  var elementTypesToUpdate = [
    "bpmn:Participant",
    "bpmn:Lane"
  ];
  this.executed(["shape.move", "shape.create", "shape.resize"], function(event2) {
    var shape = event2.context.shape, bo = getBusinessObject(shape), di = getDi(shape);
    if (isAny(bo, elementTypesToUpdate)) {
      var isHorizontal2 = di.get("isHorizontal");
      if (isHorizontal2 === void 0) {
        isHorizontal2 = true;
      }
      di.set("isHorizontal", isHorizontal2);
    }
  });
}
IsHorizontalFix.$inject = ["eventBus"];
e$3(IsHorizontalFix, CommandInterceptor);
var sqrt = Math.sqrt, min$2 = Math.min, max$4 = Math.max, abs$3 = Math.abs;
function sq(n2) {
  return Math.pow(n2, 2);
}
function getDistance(p1, p2) {
  return sqrt(sq(p1.x - p2.x) + sq(p1.y - p2.y));
}
function getAttachment(point, line) {
  var idx = 0, segmentStart, segmentEnd, segmentStartDistance, segmentEndDistance, attachmentPosition, minDistance, intersections, attachment, attachmentDistance, closestAttachmentDistance, closestAttachment;
  for (idx = 0; idx < line.length - 1; idx++) {
    segmentStart = line[idx];
    segmentEnd = line[idx + 1];
    if (pointsEqual(segmentStart, segmentEnd)) {
      intersections = [segmentStart];
    } else {
      segmentStartDistance = getDistance(point, segmentStart);
      segmentEndDistance = getDistance(point, segmentEnd);
      minDistance = min$2(segmentStartDistance, segmentEndDistance);
      intersections = getCircleSegmentIntersections(segmentStart, segmentEnd, point, minDistance);
    }
    if (intersections.length < 1) {
      throw new Error("expected between [1, 2] circle -> line intersections");
    }
    if (intersections.length === 1) {
      attachment = {
        type: "bendpoint",
        position: intersections[0],
        segmentIndex: idx,
        bendpointIndex: pointsEqual(segmentStart, intersections[0]) ? idx : idx + 1
      };
    }
    if (intersections.length === 2) {
      attachmentPosition = mid$1(intersections[0], intersections[1]);
      attachment = {
        type: "segment",
        position: attachmentPosition,
        segmentIndex: idx,
        relativeLocation: getDistance(segmentStart, attachmentPosition) / getDistance(segmentStart, segmentEnd)
      };
    }
    attachmentDistance = getDistance(attachment.position, point);
    if (!closestAttachment || closestAttachmentDistance > attachmentDistance) {
      closestAttachment = attachment;
      closestAttachmentDistance = attachmentDistance;
    }
  }
  return closestAttachment;
}
function getCircleSegmentIntersections(s1, s2, cc, cr) {
  var baX = s2.x - s1.x;
  var baY = s2.y - s1.y;
  var caX = cc.x - s1.x;
  var caY = cc.y - s1.y;
  var a2 = baX * baX + baY * baY;
  var bBy2 = baX * caX + baY * caY;
  var c2 = caX * caX + caY * caY - cr * cr;
  var pBy2 = bBy2 / a2;
  var q2 = c2 / a2;
  var disc = pBy2 * pBy2 - q2;
  if (disc < 0 && disc > -1e-6) {
    disc = 0;
  }
  if (disc < 0) {
    return [];
  }
  var tmpSqrt = sqrt(disc);
  var abScalingFactor1 = -pBy2 + tmpSqrt;
  var abScalingFactor2 = -pBy2 - tmpSqrt;
  var i1 = {
    x: s1.x - baX * abScalingFactor1,
    y: s1.y - baY * abScalingFactor1
  };
  if (disc === 0) {
    return [i1];
  }
  var i2 = {
    x: s1.x - baX * abScalingFactor2,
    y: s1.y - baY * abScalingFactor2
  };
  return [i1, i2].filter(function(p2) {
    return isPointInSegment(p2, s1, s2);
  });
}
function isPointInSegment(p2, segmentStart, segmentEnd) {
  return fenced(p2.x, segmentStart.x, segmentEnd.x) && fenced(p2.y, segmentStart.y, segmentEnd.y);
}
function fenced(n2, rangeStart, rangeEnd) {
  return n2 >= min$2(rangeStart, rangeEnd) - EQUAL_THRESHOLD && n2 <= max$4(rangeStart, rangeEnd) + EQUAL_THRESHOLD;
}
function mid$1(p1, p2) {
  return {
    x: (p1.x + p2.x) / 2,
    y: (p1.y + p2.y) / 2
  };
}
var EQUAL_THRESHOLD = 0.1;
function pointsEqual(p1, p2) {
  return abs$3(p1.x - p2.x) <= EQUAL_THRESHOLD && abs$3(p1.y - p2.y) <= EQUAL_THRESHOLD;
}
function findNewLineStartIndex(oldWaypoints, newWaypoints, attachment, hints) {
  var index2 = attachment.segmentIndex;
  var offset = newWaypoints.length - oldWaypoints.length;
  if (hints.segmentMove) {
    var oldSegmentStartIndex = hints.segmentMove.segmentStartIndex, newSegmentStartIndex = hints.segmentMove.newSegmentStartIndex;
    if (index2 === oldSegmentStartIndex) {
      return newSegmentStartIndex;
    }
    if (index2 >= newSegmentStartIndex) {
      return index2 + offset < newSegmentStartIndex ? newSegmentStartIndex : index2 + offset;
    }
    return index2;
  }
  if (hints.bendpointMove) {
    var insert = hints.bendpointMove.insert, bendpointIndex = hints.bendpointMove.bendpointIndex, newIndex;
    if (offset === 0) {
      return index2;
    }
    if (index2 >= bendpointIndex) {
      newIndex = insert ? index2 + 1 : index2 - 1;
    }
    if (index2 < bendpointIndex) {
      newIndex = index2;
      if (insert && attachment.type !== "bendpoint" && bendpointIndex - 1 === index2) {
        var rel = relativePositionMidWaypoint(newWaypoints, bendpointIndex);
        if (rel < attachment.relativeLocation) {
          newIndex++;
        }
      }
    }
    return newIndex;
  }
  if (offset === 0) {
    return index2;
  }
  if (hints.connectionStart && index2 === 0) {
    return 0;
  }
  if (hints.connectionEnd && index2 === oldWaypoints.length - 2) {
    return newWaypoints.length - 2;
  }
  return Math.floor((newWaypoints.length - 2) / 2);
}
function getAnchorPointAdjustment(position, newWaypoints, oldWaypoints, hints) {
  var dx = 0, dy = 0;
  var oldPosition = {
    point: position,
    delta: { x: 0, y: 0 }
  };
  var attachment = getAttachment(position, oldWaypoints), oldLabelLineIndex = attachment.segmentIndex, newLabelLineIndex = findNewLineStartIndex(oldWaypoints, newWaypoints, attachment, hints);
  if (newLabelLineIndex < 0 || newLabelLineIndex > newWaypoints.length - 2 || newLabelLineIndex === null) {
    return oldPosition;
  }
  var oldLabelLine = getLine(oldWaypoints, oldLabelLineIndex), newLabelLine = getLine(newWaypoints, newLabelLineIndex), oldFoot = attachment.position;
  var relativeFootPosition = getRelativeFootPosition(oldLabelLine, oldFoot), angleDelta = getAngleDelta(oldLabelLine, newLabelLine);
  if (attachment.type === "bendpoint") {
    var offset = newWaypoints.length - oldWaypoints.length, oldBendpointIndex = attachment.bendpointIndex, oldBendpoint = oldWaypoints[oldBendpointIndex];
    if (newWaypoints.indexOf(oldBendpoint) !== -1) {
      return oldPosition;
    }
    if (offset === 0) {
      var newBendpoint = newWaypoints[oldBendpointIndex];
      dx = newBendpoint.x - attachment.position.x, dy = newBendpoint.y - attachment.position.y;
      return {
        delta: {
          x: dx,
          y: dy
        },
        point: {
          x: position.x + dx,
          y: position.y + dy
        }
      };
    }
    if (offset < 0 && oldBendpointIndex !== 0 && oldBendpointIndex < oldWaypoints.length - 1) {
      relativeFootPosition = relativePositionMidWaypoint(oldWaypoints, oldBendpointIndex);
    }
  }
  var newFoot = {
    x: (newLabelLine[1].x - newLabelLine[0].x) * relativeFootPosition + newLabelLine[0].x,
    y: (newLabelLine[1].y - newLabelLine[0].y) * relativeFootPosition + newLabelLine[0].y
  };
  var newLabelVector = rotateVector({
    x: position.x - oldFoot.x,
    y: position.y - oldFoot.y
  }, angleDelta);
  dx = newFoot.x + newLabelVector.x - position.x;
  dy = newFoot.y + newLabelVector.y - position.y;
  return {
    point: roundPoint(newFoot),
    delta: roundPoint({
      x: dx,
      y: dy
    })
  };
}
function relativePositionMidWaypoint(waypoints, idx) {
  var distanceSegment1 = getDistancePointPoint(waypoints[idx - 1], waypoints[idx]), distanceSegment2 = getDistancePointPoint(waypoints[idx], waypoints[idx + 1]);
  var relativePosition = distanceSegment1 / (distanceSegment1 + distanceSegment2);
  return relativePosition;
}
function getAngleDelta(l1, l2) {
  var a1 = getAngle(l1), a2 = getAngle(l2);
  return a2 - a1;
}
function getLine(waypoints, idx) {
  return [waypoints[idx], waypoints[idx + 1]];
}
function getRelativeFootPosition(line, foot) {
  var length2 = getDistancePointPoint(line[0], line[1]), lengthToFoot = getDistancePointPoint(line[0], foot);
  return length2 === 0 ? 0 : lengthToFoot / length2;
}
function getLabelAdjustment(label, newWaypoints, oldWaypoints, hints) {
  var labelPosition = getMid(label);
  return getAnchorPointAdjustment(labelPosition, newWaypoints, oldWaypoints, hints).delta;
}
function getNewAttachPoint(point, oldBounds, newBounds) {
  var oldCenter = center(oldBounds), newCenter = center(newBounds), oldDelta = delta(point, oldCenter);
  var newDelta = {
    x: oldDelta.x * (newBounds.width / oldBounds.width),
    y: oldDelta.y * (newBounds.height / oldBounds.height)
  };
  return roundPoint({
    x: newCenter.x + newDelta.x,
    y: newCenter.y + newDelta.y
  });
}
function getNewAttachShapeDelta(shape, oldBounds, newBounds) {
  var shapeCenter = center(shape), oldCenter = center(oldBounds), newCenter = center(newBounds), shapeDelta = delta(shape, shapeCenter), oldCenterDelta = delta(shapeCenter, oldCenter), stickyPositionDelta = getStickyPositionDelta(shapeCenter, oldBounds, newBounds);
  if (stickyPositionDelta) {
    return stickyPositionDelta;
  }
  var newCenterDelta = {
    x: oldCenterDelta.x * (newBounds.width / oldBounds.width),
    y: oldCenterDelta.y * (newBounds.height / oldBounds.height)
  };
  var newShapeCenter = {
    x: newCenter.x + newCenterDelta.x,
    y: newCenter.y + newCenterDelta.y
  };
  return roundPoint({
    x: newShapeCenter.x + shapeDelta.x - shape.x,
    y: newShapeCenter.y + shapeDelta.y - shape.y
  });
}
function getStickyPositionDelta(oldShapeCenter, oldBounds, newBounds) {
  var oldTRBL = asTRBL(oldBounds), newTRBL = asTRBL(newBounds);
  if (isMoved(oldTRBL, newTRBL)) {
    return null;
  }
  var oldOrientation = getOrientation(oldBounds, oldShapeCenter), stickyPositionDelta, newShapeCenter, newOrientation;
  if (oldOrientation === "top") {
    stickyPositionDelta = {
      x: 0,
      y: newTRBL.bottom - oldTRBL.bottom
    };
  } else if (oldOrientation === "bottom") {
    stickyPositionDelta = {
      x: 0,
      y: newTRBL.top - oldTRBL.top
    };
  } else if (oldOrientation === "right") {
    stickyPositionDelta = {
      x: newTRBL.left - oldTRBL.left,
      y: 0
    };
  } else if (oldOrientation === "left") {
    stickyPositionDelta = {
      x: newTRBL.right - oldTRBL.right,
      y: 0
    };
  } else {
    return null;
  }
  newShapeCenter = {
    x: oldShapeCenter.x + stickyPositionDelta.x,
    y: oldShapeCenter.y + stickyPositionDelta.y
  };
  newOrientation = getOrientation(newBounds, newShapeCenter);
  if (newOrientation !== oldOrientation) {
    return null;
  }
  return stickyPositionDelta;
}
function isMoved(oldTRBL, newTRBL) {
  return isHorizontallyMoved(oldTRBL, newTRBL) || isVerticallyMoved(oldTRBL, newTRBL);
}
function isHorizontallyMoved(oldTRBL, newTRBL) {
  return oldTRBL.right !== newTRBL.right && oldTRBL.left !== newTRBL.left;
}
function isVerticallyMoved(oldTRBL, newTRBL) {
  return oldTRBL.top !== newTRBL.top && oldTRBL.bottom !== newTRBL.bottom;
}
var NAME_PROPERTY = "name";
var TEXT_PROPERTY = "text";
function LabelBehavior(eventBus, modeling, bpmnFactory, textRenderer) {
  CommandInterceptor.call(this, eventBus);
  this.postExecute("element.updateProperties", onPropertyUpdate);
  this.postExecute("element.updateModdleProperties", (e2) => {
    const elementBo = getBusinessObject(e2.context.element);
    if (elementBo === e2.context.moddleElement) {
      onPropertyUpdate(e2);
    }
  });
  function onPropertyUpdate(e2) {
    var context = e2.context, element = context.element, properties = context.properties;
    if (NAME_PROPERTY in properties) {
      modeling.updateLabel(element, properties[NAME_PROPERTY]);
    }
    if (TEXT_PROPERTY in properties && is$1(element, "bpmn:TextAnnotation")) {
      var newBounds = textRenderer.getTextAnnotationBounds(
        {
          x: element.x,
          y: element.y,
          width: element.width,
          height: element.height
        },
        properties[TEXT_PROPERTY] || ""
      );
      modeling.updateLabel(element, properties.text, newBounds);
    }
  }
  this.postExecute(["shape.create", "connection.create"], function(e2) {
    var context = e2.context, hints = context.hints || {};
    if (hints.createElementsBehavior === false) {
      return;
    }
    var element = context.shape || context.connection;
    if (isLabel(element) || !isLabelExternal(element)) {
      return;
    }
    if (!getLabel(element)) {
      return;
    }
    modeling.updateLabel(element, getLabel(element));
  });
  this.postExecute("shape.delete", function(event2) {
    var context = event2.context, labelTarget = context.labelTarget, hints = context.hints || {};
    if (labelTarget && hints.unsetLabel !== false) {
      modeling.updateLabel(labelTarget, null, null, { removeShape: false });
    }
  });
  function getVisibleLabelAdjustment(event2) {
    var context = event2.context, connection = context.connection, label = connection.label, hints = assign$1({}, context.hints), newWaypoints = context.newWaypoints || connection.waypoints, oldWaypoints = context.oldWaypoints;
    if (typeof hints.startChanged === "undefined") {
      hints.startChanged = !!hints.connectionStart;
    }
    if (typeof hints.endChanged === "undefined") {
      hints.endChanged = !!hints.connectionEnd;
    }
    return getLabelAdjustment(label, newWaypoints, oldWaypoints, hints);
  }
  this.postExecute([
    "connection.layout",
    "connection.updateWaypoints"
  ], function(event2) {
    var context = event2.context, hints = context.hints || {};
    if (hints.labelBehavior === false) {
      return;
    }
    var connection = context.connection, label = connection.label, labelAdjustment;
    if (!label || !label.parent) {
      return;
    }
    labelAdjustment = getVisibleLabelAdjustment(event2);
    modeling.moveShape(label, labelAdjustment);
  });
  this.postExecute(["shape.replace"], function(event2) {
    var context = event2.context, newShape = context.newShape, oldShape = context.oldShape;
    var businessObject = getBusinessObject(newShape);
    if (businessObject && isLabelExternal(businessObject) && oldShape.label && newShape.label) {
      newShape.label.x = oldShape.label.x;
      newShape.label.y = oldShape.label.y;
    }
  });
  this.postExecute("shape.resize", function(event2) {
    var context = event2.context, shape = context.shape, newBounds = context.newBounds, oldBounds = context.oldBounds;
    if (hasExternalLabel(shape)) {
      var label = shape.label, labelMid = getMid(label), edges = asEdges(oldBounds);
      var referencePoint = getReferencePoint$1(labelMid, edges);
      var delta2 = getReferencePointDelta(referencePoint, oldBounds, newBounds);
      modeling.moveShape(label, delta2);
    }
  });
}
e$3(LabelBehavior, CommandInterceptor);
LabelBehavior.$inject = [
  "eventBus",
  "modeling",
  "bpmnFactory",
  "textRenderer"
];
function getReferencePointDelta(referencePoint, oldBounds, newBounds) {
  var newReferencePoint = getNewAttachPoint(referencePoint, oldBounds, newBounds);
  return roundPoint(delta(newReferencePoint, referencePoint));
}
function getReferencePoint$1(point, lines) {
  if (!lines.length) {
    return;
  }
  var nearestLine = getNearestLine(point, lines);
  return perpendicularFoot(point, nearestLine);
}
function asEdges(bounds) {
  return [
    [
      // top
      {
        x: bounds.x,
        y: bounds.y
      },
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y
      }
    ],
    [
      // right
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y
      },
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y + (bounds.height || 0)
      }
    ],
    [
      // bottom
      {
        x: bounds.x,
        y: bounds.y + (bounds.height || 0)
      },
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y + (bounds.height || 0)
      }
    ],
    [
      // left
      {
        x: bounds.x,
        y: bounds.y
      },
      {
        x: bounds.x,
        y: bounds.y + (bounds.height || 0)
      }
    ]
  ];
}
function getNearestLine(point, lines) {
  var distances = lines.map(function(l2) {
    return {
      line: l2,
      distance: getDistancePointLine(point, l2)
    };
  });
  var sorted = sortBy(distances, "distance");
  return sorted[0].line;
}
function getConnectionAdjustment(position, newWaypoints, oldWaypoints, hints) {
  return getAnchorPointAdjustment(position, newWaypoints, oldWaypoints, hints).point;
}
function LayoutConnectionBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  function getnewAnchorPoint(event2, point) {
    var context = event2.context, connection = context.connection, hints = assign$1({}, context.hints), newWaypoints = context.newWaypoints || connection.waypoints, oldWaypoints = context.oldWaypoints;
    if (typeof hints.startChanged === "undefined") {
      hints.startChanged = !!hints.connectionStart;
    }
    if (typeof hints.endChanged === "undefined") {
      hints.endChanged = !!hints.connectionEnd;
    }
    return getConnectionAdjustment(point, newWaypoints, oldWaypoints, hints);
  }
  this.postExecute([
    "connection.layout",
    "connection.updateWaypoints"
  ], function(event2) {
    var context = event2.context;
    var connection = context.connection, outgoing = connection.outgoing, incoming = connection.incoming;
    incoming.forEach(function(connection2) {
      var endPoint = connection2.waypoints[connection2.waypoints.length - 1];
      var newEndpoint = getnewAnchorPoint(event2, endPoint);
      var newWaypoints = [].concat(connection2.waypoints.slice(0, -1), [newEndpoint]);
      modeling.updateWaypoints(connection2, newWaypoints);
    });
    outgoing.forEach(function(connection2) {
      var startpoint = connection2.waypoints[0];
      var newStartpoint = getnewAnchorPoint(event2, startpoint);
      var newWaypoints = [].concat([newStartpoint], connection2.waypoints.slice(1));
      modeling.updateWaypoints(connection2, newWaypoints);
    });
  });
  this.postExecute([
    "connection.move"
  ], function(event2) {
    var context = event2.context;
    var connection = context.connection, outgoing = connection.outgoing, incoming = connection.incoming, delta2 = context.delta;
    incoming.forEach(function(connection2) {
      var endPoint = connection2.waypoints[connection2.waypoints.length - 1];
      var newEndpoint = {
        x: endPoint.x + delta2.x,
        y: endPoint.y + delta2.y
      };
      var newWaypoints = [].concat(connection2.waypoints.slice(0, -1), [newEndpoint]);
      modeling.updateWaypoints(connection2, newWaypoints);
    });
    outgoing.forEach(function(connection2) {
      var startpoint = connection2.waypoints[0];
      var newStartpoint = {
        x: startpoint.x + delta2.x,
        y: startpoint.y + delta2.y
      };
      var newWaypoints = [].concat([newStartpoint], connection2.waypoints.slice(1));
      modeling.updateWaypoints(connection2, newWaypoints);
    });
  });
}
e$3(LayoutConnectionBehavior, CommandInterceptor);
LayoutConnectionBehavior.$inject = [
  "eventBus",
  "modeling"
];
function getResizedSourceAnchor(connection, shape, oldBounds) {
  var waypoints = safeGetWaypoints(connection), waypointsInsideNewBounds = getWaypointsInsideBounds(waypoints, shape), oldAnchor = waypoints[0];
  if (waypointsInsideNewBounds.length) {
    return waypointsInsideNewBounds[waypointsInsideNewBounds.length - 1];
  }
  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, shape);
}
function getResizedTargetAnchor(connection, shape, oldBounds) {
  var waypoints = safeGetWaypoints(connection), waypointsInsideNewBounds = getWaypointsInsideBounds(waypoints, shape), oldAnchor = waypoints[waypoints.length - 1];
  if (waypointsInsideNewBounds.length) {
    return waypointsInsideNewBounds[0];
  }
  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, shape);
}
function getMovedSourceAnchor(connection, source, moveDelta) {
  var waypoints = safeGetWaypoints(connection), oldBounds = subtract(source, moveDelta), oldAnchor = waypoints[0];
  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, source);
}
function getMovedTargetAnchor(connection, target, moveDelta) {
  var waypoints = safeGetWaypoints(connection), oldBounds = subtract(target, moveDelta), oldAnchor = waypoints[waypoints.length - 1];
  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, target);
}
function subtract(bounds, delta2) {
  return {
    x: bounds.x - delta2.x,
    y: bounds.y - delta2.y,
    width: bounds.width,
    height: bounds.height
  };
}
function safeGetWaypoints(connection) {
  var waypoints = connection.waypoints;
  if (!waypoints.length) {
    throw new Error("connection#" + connection.id + ": no waypoints");
  }
  return waypoints;
}
function getWaypointsInsideBounds(waypoints, bounds) {
  var originalWaypoints = map$1(waypoints, getOriginal);
  return filter(originalWaypoints, function(waypoint) {
    return isInsideBounds(waypoint, bounds);
  });
}
function isInsideBounds(point, bounds) {
  return getOrientation(bounds, point, 1) === "intersect";
}
function getOriginal(point) {
  return point.original || point;
}
function MessageFlowBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.postExecute("shape.replace", function(context) {
    var oldShape = context.oldShape, newShape = context.newShape;
    if (!isParticipantCollapse(oldShape, newShape)) {
      return;
    }
    var messageFlows = getMessageFlows(oldShape);
    messageFlows.incoming.forEach(function(incoming) {
      var anchor = getResizedTargetAnchor(incoming, newShape, oldShape);
      modeling.reconnectEnd(incoming, newShape, anchor);
    });
    messageFlows.outgoing.forEach(function(outgoing) {
      var anchor = getResizedSourceAnchor(outgoing, newShape, oldShape);
      modeling.reconnectStart(outgoing, newShape, anchor);
    });
  }, true);
}
MessageFlowBehavior.$inject = ["eventBus", "modeling"];
e$3(MessageFlowBehavior, CommandInterceptor);
function isParticipantCollapse(oldShape, newShape) {
  return is$1(oldShape, "bpmn:Participant") && isExpanded(oldShape) && is$1(newShape, "bpmn:Participant") && !isExpanded(newShape);
}
function getMessageFlows(parent) {
  var elements = selfAndAllChildren([parent], false);
  var incoming = [], outgoing = [];
  elements.forEach(function(element) {
    if (element === parent) {
      return;
    }
    element.incoming.forEach(function(connection) {
      if (is$1(connection, "bpmn:MessageFlow")) {
        incoming.push(connection);
      }
    });
    element.outgoing.forEach(function(connection) {
      if (is$1(connection, "bpmn:MessageFlow")) {
        outgoing.push(connection);
      }
    });
  }, []);
  return {
    incoming,
    outgoing
  };
}
const NON_INTERRUPTING_EVENT_TYPES = [
  "bpmn:MessageEventDefinition",
  "bpmn:TimerEventDefinition",
  "bpmn:EscalationEventDefinition",
  "bpmn:ConditionalEventDefinition",
  "bpmn:SignalEventDefinition"
];
function canBeNonInterrupting(shape) {
  const businessObject = getBusinessObject(shape);
  if (!is$1(businessObject, "bpmn:BoundaryEvent") && !(is$1(businessObject, "bpmn:StartEvent") && isEventSubProcess(businessObject.$parent))) {
    return false;
  }
  const eventDefinitions = businessObject.get("eventDefinitions");
  if (!eventDefinitions || !eventDefinitions.length) {
    return false;
  }
  return NON_INTERRUPTING_EVENT_TYPES.some((event2) => is$1(eventDefinitions[0], event2));
}
function getInterruptingProperty(shape) {
  return is$1(shape, "bpmn:BoundaryEvent") ? "cancelActivity" : "isInterrupting";
}
function NonInterruptingBehavior(injector, modeling) {
  injector.invoke(CommandInterceptor, this);
  this.postExecuted("shape.replace", function(event2) {
    const oldShape = event2.context.oldShape;
    const newShape = event2.context.newShape;
    const hints = event2.context.hints;
    if (!canBeNonInterrupting(newShape)) {
      return;
    }
    const property = getInterruptingProperty(newShape);
    const isExplicitChange = hints.targetElement && hints.targetElement[property] !== void 0;
    if (isExplicitChange) {
      return;
    }
    const isOldInterrupting = getBusinessObject(oldShape).get(property);
    const isNewInterruptingDefault = getBusinessObject(newShape).get(property);
    if (isOldInterrupting === isNewInterruptingDefault) {
      return;
    }
    modeling.updateProperties(newShape, {
      [property]: isOldInterrupting
    });
  });
}
NonInterruptingBehavior.$inject = ["injector", "modeling"];
e$3(NonInterruptingBehavior, CommandInterceptor);
function RemoveEmbeddedLabelBoundsBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("shape.resize", function(context) {
    var shape = context.shape;
    var di = getDi(shape), label = di && di.get("label"), bounds = label && label.get("bounds");
    if (bounds) {
      modeling.updateModdleProperties(shape, label, {
        bounds: void 0
      });
    }
  }, true);
}
e$3(RemoveEmbeddedLabelBoundsBehavior, CommandInterceptor);
RemoveEmbeddedLabelBoundsBehavior.$inject = [
  "eventBus",
  "modeling"
];
function RemoveElementBehavior(eventBus, bpmnRules, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("shape.delete", function(e2) {
    var shape = e2.context.shape;
    if (shape.incoming.length !== 1 || shape.outgoing.length !== 1) {
      return;
    }
    var inConnection = shape.incoming[0], outConnection = shape.outgoing[0];
    if (!is$1(inConnection, "bpmn:SequenceFlow") || !is$1(outConnection, "bpmn:SequenceFlow")) {
      return;
    }
    if (bpmnRules.canConnect(inConnection.source, outConnection.target, inConnection)) {
      var newWaypoints = getNewWaypoints(inConnection.waypoints, outConnection.waypoints);
      modeling.reconnectEnd(inConnection, outConnection.target, newWaypoints);
    }
  });
}
e$3(RemoveElementBehavior, CommandInterceptor);
RemoveElementBehavior.$inject = [
  "eventBus",
  "bpmnRules",
  "modeling"
];
function getDocking$1(point) {
  return point.original || point;
}
function getNewWaypoints(inWaypoints, outWaypoints) {
  var intersection2 = lineIntersect(
    getDocking$1(inWaypoints[inWaypoints.length - 2]),
    getDocking$1(inWaypoints[inWaypoints.length - 1]),
    getDocking$1(outWaypoints[1]),
    getDocking$1(outWaypoints[0])
  );
  if (intersection2) {
    return [].concat(
      inWaypoints.slice(0, inWaypoints.length - 1),
      [intersection2],
      outWaypoints.slice(1)
    );
  } else {
    return [
      getDocking$1(inWaypoints[0]),
      getDocking$1(outWaypoints[outWaypoints.length - 1])
    ];
  }
}
function RemoveParticipantBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("shape.delete", function(context) {
    var shape = context.shape, parent = shape.parent;
    if (is$1(shape, "bpmn:Participant")) {
      context.collaborationRoot = parent;
    }
  }, true);
  this.postExecute("shape.delete", function(context) {
    var collaborationRoot = context.collaborationRoot;
    if (collaborationRoot && !collaborationRoot.businessObject.participants.length) {
      modeling.makeProcess();
    }
  }, true);
}
RemoveParticipantBehavior.$inject = ["eventBus", "modeling"];
e$3(RemoveParticipantBehavior, CommandInterceptor);
function ReplaceConnectionBehavior(eventBus, modeling, bpmnRules, injector) {
  CommandInterceptor.call(this, eventBus);
  var dragging = injector.get("dragging", false);
  function fixConnection(connection) {
    var source = connection.source, target = connection.target, parent = connection.parent;
    if (!parent) {
      return;
    }
    var replacementType, remove2;
    if (is$1(connection, "bpmn:SequenceFlow")) {
      if (!bpmnRules.canConnectSequenceFlow(source, target)) {
        remove2 = true;
      }
      if (bpmnRules.canConnectMessageFlow(source, target)) {
        replacementType = "bpmn:MessageFlow";
      }
    }
    if (is$1(connection, "bpmn:MessageFlow")) {
      if (!bpmnRules.canConnectMessageFlow(source, target)) {
        remove2 = true;
      }
      if (bpmnRules.canConnectSequenceFlow(source, target)) {
        replacementType = "bpmn:SequenceFlow";
      }
    }
    if (remove2) {
      modeling.removeConnection(connection);
    }
    if (replacementType) {
      modeling.connect(source, target, {
        type: replacementType,
        waypoints: connection.waypoints.slice()
      });
    }
  }
  function replaceReconnectedConnection(event2) {
    var context = event2.context, connection = context.connection, source = context.newSource || connection.source, target = context.newTarget || connection.target, allowed, replacement;
    allowed = bpmnRules.canConnect(source, target);
    if (!allowed || allowed.type === connection.type) {
      return;
    }
    replacement = modeling.connect(source, target, {
      type: allowed.type,
      associationDirection: allowed.associationDirection,
      waypoints: connection.waypoints.slice()
    });
    if (connection.parent) {
      modeling.removeConnection(connection);
    }
    context.connection = replacement;
    if (dragging) {
      cleanDraggingSelection(connection, replacement);
    }
  }
  function cleanDraggingSelection(oldConnection, newConnection) {
    var context = dragging.context(), previousSelection = context && context.payload.previousSelection, index2;
    if (!previousSelection || !previousSelection.length) {
      return;
    }
    index2 = previousSelection.indexOf(oldConnection);
    if (index2 === -1) {
      return;
    }
    previousSelection.splice(index2, 1, newConnection);
  }
  this.postExecuted("elements.move", function(context) {
    var closure = context.closure, allConnections = closure.allConnections;
    forEach$1(allConnections, fixConnection);
  }, true);
  this.preExecute("connection.reconnect", replaceReconnectedConnection);
  this.postExecuted("element.updateProperties", function(event2) {
    var context = event2.context, properties = context.properties, element = context.element, businessObject = element.businessObject, connection;
    if (properties.default) {
      connection = find(
        element.outgoing,
        matchPattern({ id: element.businessObject.default.id })
      );
      if (connection) {
        modeling.updateProperties(connection, { conditionExpression: void 0 });
      }
    }
    if (properties.conditionExpression && businessObject.sourceRef.default === businessObject) {
      modeling.updateProperties(element.source, { default: void 0 });
    }
  });
}
e$3(ReplaceConnectionBehavior, CommandInterceptor);
ReplaceConnectionBehavior.$inject = [
  "eventBus",
  "modeling",
  "bpmnRules",
  "injector"
];
function ReplaceElementBehaviour(bpmnReplace, bpmnRules, elementRegistry, injector, modeling, selection) {
  injector.invoke(CommandInterceptor, this);
  this._bpmnReplace = bpmnReplace;
  this._elementRegistry = elementRegistry;
  this._selection = selection;
  this.postExecuted(["elements.create"], 500, function(event2) {
    var context = event2.context, target = context.parent, elements = context.elements;
    var elementReplacements = reduce(elements, function(replacements, element) {
      var canReplace2 = bpmnRules.canReplace([element], element.host || element.parent || target);
      return canReplace2 ? replacements.concat(canReplace2.replacements) : replacements;
    }, []);
    if (elementReplacements.length) {
      this._replaceElements(elements, elementReplacements);
    }
  }, this);
  this.postExecuted(["elements.move"], 500, function(event2) {
    var context = event2.context, target = context.newParent, newHost = context.newHost, elements = [];
    forEach$1(context.closure.topLevel, function(topLevelElements) {
      if (isEventSubProcess(topLevelElements)) {
        elements = elements.concat(topLevelElements.children);
      } else {
        elements = elements.concat(topLevelElements);
      }
    });
    if (elements.length === 1 && newHost) {
      target = newHost;
    }
    var canReplace2 = bpmnRules.canReplace(elements, target);
    if (canReplace2) {
      this._replaceElements(elements, canReplace2.replacements, newHost);
    }
  }, this);
  this.postExecute(["shape.replace"], 1500, function(e2) {
    var context = e2.context, oldShape = context.oldShape, newShape = context.newShape, attachers = oldShape.attachers, canReplace2;
    if (attachers && attachers.length) {
      canReplace2 = bpmnRules.canReplace(attachers, newShape);
      this._replaceElements(attachers, canReplace2.replacements);
    }
  }, this);
  this.postExecuted(["shape.replace"], 1500, function(e2) {
    var context = e2.context, oldShape = context.oldShape, newShape = context.newShape;
    modeling.unclaimId(oldShape.businessObject.id, oldShape.businessObject);
    modeling.updateProperties(newShape, { id: oldShape.id });
  });
}
e$3(ReplaceElementBehaviour, CommandInterceptor);
ReplaceElementBehaviour.prototype._replaceElements = function(elements, newElements) {
  var elementRegistry = this._elementRegistry, bpmnReplace = this._bpmnReplace, selection = this._selection;
  forEach$1(newElements, function(replacement) {
    var newElement = {
      type: replacement.newElementType
    };
    var oldElement = elementRegistry.get(replacement.oldElementId);
    var idx = elements.indexOf(oldElement);
    elements[idx] = bpmnReplace.replaceElement(oldElement, newElement, { select: false });
  });
  if (newElements) {
    selection.select(elements);
  }
};
ReplaceElementBehaviour.$inject = [
  "bpmnReplace",
  "bpmnRules",
  "elementRegistry",
  "injector",
  "modeling",
  "selection"
];
var HIGH_PRIORITY$e = 1500;
var GROUP_MIN_DIMENSIONS = { width: 140, height: 120 };
var LANE_MIN_DIMENSIONS = { width: 300, height: 60 };
var VERTICAL_LANE_MIN_DIMENSIONS = { width: 60, height: 300 };
var PARTICIPANT_MIN_DIMENSIONS = { width: 300, height: 150 };
var VERTICAL_PARTICIPANT_MIN_DIMENSIONS = { width: 150, height: 300 };
var SUB_PROCESS_MIN_DIMENSIONS = { width: 140, height: 120 };
var TEXT_ANNOTATION_MIN_DIMENSIONS = { width: 50, height: 30 };
function ResizeBehavior$1(eventBus) {
  eventBus.on("resize.start", HIGH_PRIORITY$e, function(event2) {
    var context = event2.context, shape = context.shape, direction = context.direction, balanced = context.balanced;
    if (is$1(shape, "bpmn:Lane") || is$1(shape, "bpmn:Participant")) {
      context.resizeConstraints = getParticipantResizeConstraints(shape, direction, balanced);
    }
    if (is$1(shape, "bpmn:SubProcess") && isExpanded(shape)) {
      context.minDimensions = SUB_PROCESS_MIN_DIMENSIONS;
    }
    if (is$1(shape, "bpmn:TextAnnotation")) {
      context.minDimensions = TEXT_ANNOTATION_MIN_DIMENSIONS;
    }
  });
}
ResizeBehavior$1.$inject = ["eventBus"];
var abs$2 = Math.abs, min$1 = Math.min, max$3 = Math.max;
function addToTrbl(trbl, attr2, value, choice) {
  var current = trbl[attr2];
  trbl[attr2] = current === void 0 ? value : choice(value, current);
}
function addMin(trbl, attr2, value) {
  return addToTrbl(trbl, attr2, value, min$1);
}
function addMax(trbl, attr2, value) {
  return addToTrbl(trbl, attr2, value, max$3);
}
var LANE_PADDING = { top: 20, left: 50, right: 20, bottom: 20 }, VERTICAL_LANE_PADDING = { top: 50, left: 20, right: 20, bottom: 20 };
function getParticipantResizeConstraints(laneShape, resizeDirection, balanced) {
  var lanesRoot = getLanesRoot(laneShape);
  var isFirst = true, isLast = true;
  var allLanes = collectLanes(lanesRoot, [lanesRoot]);
  var laneTrbl = asTRBL(laneShape);
  var maxTrbl = {}, minTrbl = {};
  var isHorizontalLane = isHorizontal$3(laneShape);
  var minDimensions = isHorizontalLane ? LANE_MIN_DIMENSIONS : VERTICAL_LANE_MIN_DIMENSIONS;
  if (/n/.test(resizeDirection)) {
    minTrbl.top = laneTrbl.bottom - minDimensions.height;
  } else if (/e/.test(resizeDirection)) {
    minTrbl.right = laneTrbl.left + minDimensions.width;
  } else if (/s/.test(resizeDirection)) {
    minTrbl.bottom = laneTrbl.top + minDimensions.height;
  } else if (/w/.test(resizeDirection)) {
    minTrbl.left = laneTrbl.right - minDimensions.width;
  }
  allLanes.forEach(function(other) {
    var otherTrbl = asTRBL(other);
    if (/n/.test(resizeDirection)) {
      if (isHorizontalLane && otherTrbl.top < laneTrbl.top - 10) {
        isFirst = false;
      }
      if (balanced && abs$2(laneTrbl.top - otherTrbl.bottom) < 10) {
        addMax(maxTrbl, "top", otherTrbl.top + minDimensions.height);
      }
      if (abs$2(laneTrbl.top - otherTrbl.top) < 5) {
        addMin(minTrbl, "top", otherTrbl.bottom - minDimensions.height);
      }
    }
    if (/e/.test(resizeDirection)) {
      if (!isHorizontalLane && otherTrbl.right > laneTrbl.right + 10) {
        isLast = false;
      }
      if (balanced && abs$2(laneTrbl.right - otherTrbl.left) < 10) {
        addMin(maxTrbl, "right", otherTrbl.right - minDimensions.width);
      }
      if (abs$2(laneTrbl.right - otherTrbl.right) < 5) {
        addMax(minTrbl, "right", otherTrbl.left + minDimensions.width);
      }
    }
    if (/s/.test(resizeDirection)) {
      if (isHorizontalLane && otherTrbl.bottom > laneTrbl.bottom + 10) {
        isLast = false;
      }
      if (balanced && abs$2(laneTrbl.bottom - otherTrbl.top) < 10) {
        addMin(maxTrbl, "bottom", otherTrbl.bottom - minDimensions.height);
      }
      if (abs$2(laneTrbl.bottom - otherTrbl.bottom) < 5) {
        addMax(minTrbl, "bottom", otherTrbl.top + minDimensions.height);
      }
    }
    if (/w/.test(resizeDirection)) {
      if (!isHorizontalLane && otherTrbl.left < laneTrbl.left - 10) {
        isFirst = false;
      }
      if (balanced && abs$2(laneTrbl.left - otherTrbl.right) < 10) {
        addMax(maxTrbl, "left", otherTrbl.left + minDimensions.width);
      }
      if (abs$2(laneTrbl.left - otherTrbl.left) < 5) {
        addMin(minTrbl, "left", otherTrbl.right - minDimensions.width);
      }
    }
  });
  var flowElements = lanesRoot.children.filter(function(s2) {
    return !s2.hidden && !s2.waypoints && (is$1(s2, "bpmn:FlowElement") || is$1(s2, "bpmn:Artifact"));
  });
  var padding = isHorizontalLane ? LANE_PADDING : VERTICAL_LANE_PADDING;
  flowElements.forEach(function(flowElement) {
    var flowElementTrbl = asTRBL(flowElement);
    if (isFirst && /n/.test(resizeDirection)) {
      addMin(minTrbl, "top", flowElementTrbl.top - padding.top);
    }
    if (isLast && /e/.test(resizeDirection)) {
      addMax(minTrbl, "right", flowElementTrbl.right + padding.right);
    }
    if (isLast && /s/.test(resizeDirection)) {
      addMax(minTrbl, "bottom", flowElementTrbl.bottom + padding.bottom);
    }
    if (isFirst && /w/.test(resizeDirection)) {
      addMin(minTrbl, "left", flowElementTrbl.left - padding.left);
    }
  });
  return {
    min: minTrbl,
    max: maxTrbl
  };
}
var SLIGHTLY_HIGHER_PRIORITY = 1001;
function ResizeLaneBehavior(eventBus, modeling) {
  eventBus.on("resize.start", SLIGHTLY_HIGHER_PRIORITY + 500, function(event2) {
    var context = event2.context, shape = context.shape;
    if (is$1(shape, "bpmn:Lane") || is$1(shape, "bpmn:Participant")) {
      context.balanced = !hasPrimaryModifier(event2);
    }
  });
  eventBus.on("resize.end", SLIGHTLY_HIGHER_PRIORITY, function(event2) {
    var context = event2.context, shape = context.shape, canExecute = context.canExecute, newBounds = context.newBounds;
    if (is$1(shape, "bpmn:Lane") || is$1(shape, "bpmn:Participant")) {
      if (canExecute) {
        newBounds = roundBounds(newBounds);
        modeling.resizeLane(shape, newBounds, context.balanced);
      }
      return false;
    }
  });
}
ResizeLaneBehavior.$inject = [
  "eventBus",
  "modeling"
];
var LOW_PRIORITY$f = 500;
function RootElementReferenceBehavior(bpmnjs, eventBus, injector, moddleCopy, bpmnFactory) {
  injector.invoke(CommandInterceptor, this);
  function canHaveRootElementReference(element) {
    return isAny(element, ["bpmn:ReceiveTask", "bpmn:SendTask"]) || hasAnyEventDefinition(element, [
      "bpmn:ErrorEventDefinition",
      "bpmn:EscalationEventDefinition",
      "bpmn:MessageEventDefinition",
      "bpmn:SignalEventDefinition"
    ]);
  }
  function hasRootElement(rootElement) {
    var definitions = bpmnjs.getDefinitions(), rootElements = definitions.get("rootElements");
    return !!find(rootElements, matchPattern({ id: rootElement.id }));
  }
  function getRootElementReferencePropertyName(eventDefinition) {
    if (is$1(eventDefinition, "bpmn:ErrorEventDefinition")) {
      return "errorRef";
    } else if (is$1(eventDefinition, "bpmn:EscalationEventDefinition")) {
      return "escalationRef";
    } else if (is$1(eventDefinition, "bpmn:MessageEventDefinition")) {
      return "messageRef";
    } else if (is$1(eventDefinition, "bpmn:SignalEventDefinition")) {
      return "signalRef";
    }
  }
  function getRootElement2(businessObject) {
    if (isAny(businessObject, ["bpmn:ReceiveTask", "bpmn:SendTask"])) {
      return businessObject.get("messageRef");
    }
    var eventDefinitions = businessObject.get("eventDefinitions"), eventDefinition = eventDefinitions[0];
    return eventDefinition.get(getRootElementReferencePropertyName(eventDefinition));
  }
  function setRootElement(businessObject, rootElement) {
    if (isAny(businessObject, ["bpmn:ReceiveTask", "bpmn:SendTask"])) {
      return businessObject.set("messageRef", rootElement);
    }
    var eventDefinitions = businessObject.get("eventDefinitions"), eventDefinition = eventDefinitions[0];
    return eventDefinition.set(getRootElementReferencePropertyName(eventDefinition), rootElement);
  }
  this.executed([
    "shape.create",
    "element.updateProperties",
    "element.updateModdleProperties"
  ], function(context) {
    var shape = context.shape || context.element;
    if (!canHaveRootElementReference(shape)) {
      return;
    }
    var businessObject = getBusinessObject(shape), rootElement = getRootElement2(businessObject), rootElements;
    if (rootElement && !hasRootElement(rootElement)) {
      rootElements = bpmnjs.getDefinitions().get("rootElements");
      add(rootElements, rootElement);
      context.addedRootElement = rootElement;
    }
  }, true);
  this.reverted([
    "shape.create",
    "element.updateProperties",
    "element.updateModdleProperties"
  ], function(context) {
    var addedRootElement = context.addedRootElement;
    if (!addedRootElement) {
      return;
    }
    var rootElements = bpmnjs.getDefinitions().get("rootElements");
    remove(rootElements, addedRootElement);
  }, true);
  eventBus.on("copyPaste.copyElement", function(context) {
    var descriptor = context.descriptor, element = context.element;
    if (element.labelTarget || !canHaveRootElementReference(element)) {
      return;
    }
    var businessObject = getBusinessObject(element), rootElement = getRootElement2(businessObject);
    if (rootElement) {
      descriptor.referencedRootElement = rootElement;
    }
  });
  eventBus.on("copyPaste.pasteElement", LOW_PRIORITY$f, function(context) {
    var descriptor = context.descriptor, businessObject = descriptor.businessObject, referencedRootElement = descriptor.referencedRootElement;
    if (!referencedRootElement) {
      return;
    }
    if (!hasRootElement(referencedRootElement)) {
      referencedRootElement = moddleCopy.copyElement(
        referencedRootElement,
        bpmnFactory.create(referencedRootElement.$type)
      );
    }
    setRootElement(businessObject, referencedRootElement);
    delete descriptor.referencedRootElement;
  });
}
RootElementReferenceBehavior.$inject = [
  "bpmnjs",
  "eventBus",
  "injector",
  "moddleCopy",
  "bpmnFactory"
];
e$3(RootElementReferenceBehavior, CommandInterceptor);
function hasAnyEventDefinition(element, types2) {
  if (!isArray$3(types2)) {
    types2 = [types2];
  }
  return some(types2, function(type) {
    return hasEventDefinition$2(element, type);
  });
}
var max$2 = Math.max;
function SpaceToolBehavior$1(eventBus) {
  eventBus.on("spaceTool.getMinDimensions", function(context) {
    var shapes = context.shapes, axis = context.axis, start = context.start, minDimensions = {};
    forEach$1(shapes, function(shape) {
      var id = shape.id;
      if (is$1(shape, "bpmn:Participant")) {
        minDimensions[id] = getParticipantMinDimensions(shape, axis, start);
      }
      if (is$1(shape, "bpmn:Lane")) {
        minDimensions[id] = isHorizontal$3(shape) ? LANE_MIN_DIMENSIONS : VERTICAL_LANE_MIN_DIMENSIONS;
      }
      if (is$1(shape, "bpmn:SubProcess") && isExpanded(shape)) {
        minDimensions[id] = SUB_PROCESS_MIN_DIMENSIONS;
      }
      if (is$1(shape, "bpmn:TextAnnotation")) {
        minDimensions[id] = TEXT_ANNOTATION_MIN_DIMENSIONS;
      }
      if (is$1(shape, "bpmn:Group")) {
        minDimensions[id] = GROUP_MIN_DIMENSIONS;
      }
    });
    return minDimensions;
  });
}
SpaceToolBehavior$1.$inject = ["eventBus"];
function isHorizontalAxis(axis) {
  return axis === "x";
}
function getParticipantMinDimensions(participant, axis, start) {
  var isHorizontalLane = isHorizontal$3(participant);
  if (!hasChildLanes(participant)) {
    return isHorizontalLane ? PARTICIPANT_MIN_DIMENSIONS : VERTICAL_PARTICIPANT_MIN_DIMENSIONS;
  }
  var isHorizontalResize = isHorizontalAxis(axis);
  var minDimensions = {};
  if (isHorizontalResize) {
    if (isHorizontalLane) {
      minDimensions = PARTICIPANT_MIN_DIMENSIONS;
    } else {
      minDimensions = {
        width: getParticipantMinWidth(participant, start, isHorizontalResize),
        height: VERTICAL_PARTICIPANT_MIN_DIMENSIONS.height
      };
    }
  } else {
    if (isHorizontalLane) {
      minDimensions = {
        width: PARTICIPANT_MIN_DIMENSIONS.width,
        height: getParticipantMinHeight(participant, start, isHorizontalResize)
      };
    } else {
      minDimensions = VERTICAL_PARTICIPANT_MIN_DIMENSIONS;
    }
  }
  return minDimensions;
}
function getParticipantMinHeight(participant, start, isHorizontalResize) {
  var lanesMinHeight;
  lanesMinHeight = getLanesMinHeight(participant, start, isHorizontalResize);
  return max$2(PARTICIPANT_MIN_DIMENSIONS.height, lanesMinHeight);
}
function getParticipantMinWidth(participant, start, isHorizontalResize) {
  var lanesMinWidth;
  lanesMinWidth = getLanesMinWidth(participant, start, isHorizontalResize);
  return max$2(VERTICAL_PARTICIPANT_MIN_DIMENSIONS.width, lanesMinWidth);
}
function hasChildLanes(element) {
  return !!getChildLanes(element).length;
}
function getLanesMinHeight(participant, resizeStart, isHorizontalResize) {
  var lanes = getChildLanes(participant), resizedLane;
  resizedLane = findResizedLane(lanes, resizeStart, isHorizontalResize);
  return participant.height - resizedLane.height + LANE_MIN_DIMENSIONS.height;
}
function getLanesMinWidth(participant, resizeStart, isHorizontalResize) {
  var lanes = getChildLanes(participant), resizedLane;
  resizedLane = findResizedLane(lanes, resizeStart, isHorizontalResize);
  return participant.width - resizedLane.width + VERTICAL_LANE_MIN_DIMENSIONS.width;
}
function findResizedLane(lanes, resizeStart, isHorizontalResize) {
  var i2, lane, childLanes;
  for (i2 = 0; i2 < lanes.length; i2++) {
    lane = lanes[i2];
    if (!isHorizontalResize && resizeStart >= lane.y && resizeStart <= lane.y + lane.height || isHorizontalResize && resizeStart >= lane.x && resizeStart <= lane.x + lane.width) {
      childLanes = getChildLanes(lane);
      if (childLanes.length) {
        return findResizedLane(childLanes, resizeStart, isHorizontalResize);
      }
      return lane;
    }
  }
}
var LOW_PRIORITY$e = 400;
var HIGH_PRIORITY$d = 600;
var DEFAULT_POSITION = {
  x: 180,
  y: 160
};
function SubProcessPlaneBehavior(canvas, eventBus, modeling, elementFactory, bpmnFactory, bpmnjs, elementRegistry) {
  CommandInterceptor.call(this, eventBus);
  this._canvas = canvas;
  this._eventBus = eventBus;
  this._modeling = modeling;
  this._elementFactory = elementFactory;
  this._bpmnFactory = bpmnFactory;
  this._bpmnjs = bpmnjs;
  this._elementRegistry = elementRegistry;
  var self2 = this;
  function isCollapsedSubProcess2(element) {
    return is$1(element, "bpmn:SubProcess") && !isExpanded(element);
  }
  function createRoot2(context) {
    var shape = context.shape, rootElement = context.newRootElement;
    var businessObject = getBusinessObject(shape);
    rootElement = self2._addDiagram(rootElement || businessObject);
    context.newRootElement = canvas.addRootElement(rootElement);
  }
  function removeRoot(context) {
    var shape = context.shape;
    var businessObject = getBusinessObject(shape);
    self2._removeDiagram(businessObject);
    var rootElement = context.newRootElement = elementRegistry.get(getPlaneIdFromShape(businessObject));
    canvas.removeRootElement(rootElement);
  }
  this.executed("shape.create", function(context) {
    var shape = context.shape;
    if (!isCollapsedSubProcess2(shape)) {
      return;
    }
    createRoot2(context);
  }, true);
  this.postExecuted("shape.create", function(context) {
    var shape = context.shape, rootElement = context.newRootElement;
    if (!rootElement || !shape.children) {
      return;
    }
    self2._showRecursively(shape.children);
    self2._moveChildrenToShape(shape, rootElement);
  }, true);
  this.reverted("shape.create", function(context) {
    var shape = context.shape;
    if (!isCollapsedSubProcess2(shape)) {
      return;
    }
    removeRoot(context);
  }, true);
  this.preExecuted("shape.delete", function(context) {
    var shape = context.shape;
    if (!isCollapsedSubProcess2(shape)) {
      return;
    }
    var attachedRoot = elementRegistry.get(getPlaneIdFromShape(shape));
    if (!attachedRoot) {
      return;
    }
    modeling.removeElements(attachedRoot.children.slice());
  }, true);
  this.executed("shape.delete", function(context) {
    var shape = context.shape;
    if (!isCollapsedSubProcess2(shape)) {
      return;
    }
    removeRoot(context);
  }, true);
  this.reverted("shape.delete", function(context) {
    var shape = context.shape;
    if (!isCollapsedSubProcess2(shape)) {
      return;
    }
    createRoot2(context);
  }, true);
  this.preExecuted("shape.replace", function(context) {
    var oldShape = context.oldShape;
    var newShape = context.newShape;
    if (!isCollapsedSubProcess2(oldShape) || !isCollapsedSubProcess2(newShape)) {
      return;
    }
    context.oldRoot = canvas.removeRootElement(getPlaneIdFromShape(oldShape));
  }, true);
  this.postExecuted("shape.replace", function(context) {
    var newShape = context.newShape, source = context.oldRoot, target = canvas.findRoot(getPlaneIdFromShape(newShape));
    if (!source || !target) {
      return;
    }
    var elements = source.children;
    modeling.moveElements(elements, { x: 0, y: 0 }, target);
  }, true);
  this.executed("element.updateProperties", function(context) {
    var shape = context.element;
    if (!is$1(shape, "bpmn:SubProcess")) {
      return;
    }
    var properties = context.properties;
    var oldProperties = context.oldProperties;
    var oldId = oldProperties.id, newId = properties.id;
    if (oldId === newId) {
      return;
    }
    if (isPlane(shape)) {
      elementRegistry.updateId(shape, toPlaneId(newId));
      elementRegistry.updateId(oldId, newId);
      return;
    }
    var planeElement = elementRegistry.get(toPlaneId(oldId));
    if (!planeElement) {
      return;
    }
    elementRegistry.updateId(toPlaneId(oldId), toPlaneId(newId));
  }, true);
  this.reverted("element.updateProperties", function(context) {
    var shape = context.element;
    if (!is$1(shape, "bpmn:SubProcess")) {
      return;
    }
    var properties = context.properties;
    var oldProperties = context.oldProperties;
    var oldId = oldProperties.id, newId = properties.id;
    if (oldId === newId) {
      return;
    }
    if (isPlane(shape)) {
      elementRegistry.updateId(shape, toPlaneId(oldId));
      elementRegistry.updateId(newId, oldId);
      return;
    }
    var planeElement = elementRegistry.get(toPlaneId(newId));
    if (!planeElement) {
      return;
    }
    elementRegistry.updateId(planeElement, toPlaneId(oldId));
  }, true);
  eventBus.on("element.changed", function(context) {
    var element = context.element;
    if (!isPlane(element)) {
      return;
    }
    var plane = element;
    var primaryShape = elementRegistry.get(getShapeIdFromPlane(plane));
    if (!primaryShape || primaryShape === plane) {
      return;
    }
    eventBus.fire("element.changed", { element: primaryShape });
  });
  this.executed("shape.toggleCollapse", LOW_PRIORITY$e, function(context) {
    var shape = context.shape;
    if (!is$1(shape, "bpmn:SubProcess")) {
      return;
    }
    if (!isExpanded(shape)) {
      createRoot2(context);
      self2._showRecursively(shape.children);
    } else {
      removeRoot(context);
    }
  }, true);
  this.reverted("shape.toggleCollapse", LOW_PRIORITY$e, function(context) {
    var shape = context.shape;
    if (!is$1(shape, "bpmn:SubProcess")) {
      return;
    }
    if (!isExpanded(shape)) {
      createRoot2(context);
      self2._showRecursively(shape.children);
    } else {
      removeRoot(context);
    }
  }, true);
  this.postExecuted("shape.toggleCollapse", HIGH_PRIORITY$d, function(context) {
    var shape = context.shape;
    if (!is$1(shape, "bpmn:SubProcess")) {
      return;
    }
    var rootElement = context.newRootElement;
    if (!rootElement) {
      return;
    }
    if (!isExpanded(shape)) {
      self2._moveChildrenToShape(shape, rootElement);
    } else {
      self2._moveChildrenToShape(rootElement, shape);
    }
  }, true);
  eventBus.on("copyPaste.createTree", function(context) {
    var element = context.element, children = context.children;
    if (!isCollapsedSubProcess2(element)) {
      return;
    }
    var id = getPlaneIdFromShape(element);
    var parent = elementRegistry.get(id);
    if (parent) {
      children.push.apply(children, parent.children);
    }
  });
  eventBus.on("copyPaste.copyElement", function(context) {
    var descriptor = context.descriptor, element = context.element, elements = context.elements;
    var parent = element.parent;
    var isPlane2 = is$1(getDi(parent), "bpmndi:BPMNPlane");
    if (!isPlane2) {
      return;
    }
    var parentId = getShapeIdFromPlane(parent);
    var referencedShape = find(elements, function(element2) {
      return element2.id === parentId;
    });
    if (!referencedShape) {
      return;
    }
    descriptor.parent = referencedShape.id;
  });
  eventBus.on("copyPaste.pasteElement", function(context) {
    var descriptor = context.descriptor;
    if (!descriptor.parent) {
      return;
    }
    if (isCollapsedSubProcess2(descriptor.parent) || descriptor.parent.hidden) {
      descriptor.hidden = true;
    }
  });
}
e$3(SubProcessPlaneBehavior, CommandInterceptor);
SubProcessPlaneBehavior.prototype._moveChildrenToShape = function(source, target) {
  var modeling = this._modeling;
  var children = source.children;
  var offset;
  if (!children) {
    return;
  }
  children = children.concat(children.reduce(function(labels, child) {
    if (child.label && child.label.parent !== source) {
      return labels.concat(child.label);
    }
    return labels;
  }, []));
  var visibleChildren = children.filter(function(child) {
    return !child.hidden;
  });
  if (!visibleChildren.length) {
    modeling.moveElements(children, { x: 0, y: 0 }, target, { autoResize: false });
    return;
  }
  var childrenBounds = getBBox(visibleChildren);
  if (!target.x) {
    offset = {
      x: DEFAULT_POSITION.x - childrenBounds.x,
      y: DEFAULT_POSITION.y - childrenBounds.y
    };
  } else {
    var targetMid = getMid(target);
    var childrenMid = getMid(childrenBounds);
    offset = {
      x: targetMid.x - childrenMid.x,
      y: targetMid.y - childrenMid.y
    };
  }
  modeling.moveElements(children, offset, target, { autoResize: false });
};
SubProcessPlaneBehavior.prototype._showRecursively = function(elements, hidden) {
  var self2 = this;
  var result = [];
  elements.forEach(function(element) {
    element.hidden = !!hidden;
    result = result.concat(element);
    if (element.children) {
      result = result.concat(
        self2._showRecursively(element.children, element.collapsed || hidden)
      );
    }
  });
  return result;
};
SubProcessPlaneBehavior.prototype._addDiagram = function(planeElement) {
  var bpmnjs = this._bpmnjs;
  var diagrams = bpmnjs.getDefinitions().diagrams;
  if (!planeElement.businessObject) {
    planeElement = this._createNewDiagram(planeElement);
  }
  diagrams.push(planeElement.di.$parent);
  return planeElement;
};
SubProcessPlaneBehavior.prototype._createNewDiagram = function(bpmnElement) {
  var bpmnFactory = this._bpmnFactory, elementFactory = this._elementFactory;
  var diPlane = bpmnFactory.create("bpmndi:BPMNPlane", {
    bpmnElement
  });
  var diDiagram = bpmnFactory.create("bpmndi:BPMNDiagram", {
    plane: diPlane
  });
  diPlane.$parent = diDiagram;
  var planeElement = elementFactory.createRoot({
    id: getPlaneIdFromShape(bpmnElement),
    type: bpmnElement.$type,
    di: diPlane,
    businessObject: bpmnElement,
    collapsed: true
  });
  return planeElement;
};
SubProcessPlaneBehavior.prototype._removeDiagram = function(rootElement) {
  var bpmnjs = this._bpmnjs;
  var diagrams = bpmnjs.getDefinitions().diagrams;
  var removedDiagram = find(diagrams, function(diagram) {
    return diagram.plane.bpmnElement.id === rootElement.id;
  });
  diagrams.splice(diagrams.indexOf(removedDiagram), 1);
  return removedDiagram;
};
SubProcessPlaneBehavior.$inject = [
  "canvas",
  "eventBus",
  "modeling",
  "elementFactory",
  "bpmnFactory",
  "bpmnjs",
  "elementRegistry"
];
function SubProcessStartEventBehavior(injector, modeling) {
  injector.invoke(CommandInterceptor, this);
  this.postExecuted("shape.replace", function(event2) {
    var oldShape = event2.context.oldShape, newShape = event2.context.newShape;
    if (!is$1(newShape, "bpmn:SubProcess") || !(is$1(oldShape, "bpmn:Task") || is$1(oldShape, "bpmn:CallActivity")) || !isExpanded(newShape)) {
      return;
    }
    var position = getStartEventPosition(newShape);
    modeling.createShape({ type: "bpmn:StartEvent" }, position, newShape);
  });
}
SubProcessStartEventBehavior.$inject = [
  "injector",
  "modeling"
];
e$3(SubProcessStartEventBehavior, CommandInterceptor);
function getStartEventPosition(shape) {
  return {
    x: shape.x + shape.width / 6,
    y: shape.y + shape.height / 2
  };
}
function TextAnnotationBehavior(eventBus) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("connection.create", function(context) {
    const { target } = context;
    if (!is$1(target, "bpmn:TextAnnotation")) {
      return;
    }
    context.parent = target.parent;
  }, true);
  this.preExecute(["shape.create", "shape.resize", "elements.move"], function(context) {
    const shapes = context.shapes || [context.shape];
    if (shapes.length === 1 && is$1(shapes[0], "bpmn:TextAnnotation")) {
      context.hints = context.hints || {};
      context.hints.autoResize = false;
    }
  }, true);
}
e$3(TextAnnotationBehavior, CommandInterceptor);
TextAnnotationBehavior.$inject = [
  "eventBus"
];
function ToggleCollapseConnectionBehaviour(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.postExecuted("shape.toggleCollapse", 1500, function(context) {
    var shape = context.shape;
    if (isExpanded(shape)) {
      return;
    }
    var allChildren = selfAndAllChildren(shape);
    allChildren.forEach(function(child) {
      var incomingConnections = child.incoming.slice(), outgoingConnections = child.outgoing.slice();
      forEach$1(incomingConnections, function(c2) {
        handleConnection(c2, true);
      });
      forEach$1(outgoingConnections, function(c2) {
        handleConnection(c2, false);
      });
    });
    function handleConnection(c2, incoming) {
      if (allChildren.indexOf(c2.source) !== -1 && allChildren.indexOf(c2.target) !== -1) {
        return;
      }
      if (incoming) {
        modeling.reconnectEnd(c2, shape, getMid(shape));
      } else {
        modeling.reconnectStart(c2, shape, getMid(shape));
      }
    }
  }, true);
}
e$3(ToggleCollapseConnectionBehaviour, CommandInterceptor);
ToggleCollapseConnectionBehaviour.$inject = [
  "eventBus",
  "modeling"
];
var LOW_PRIORITY$d = 500;
function ToggleElementCollapseBehaviour(eventBus, elementFactory, modeling) {
  CommandInterceptor.call(this, eventBus);
  function hideEmptyLabels(children) {
    if (children.length) {
      children.forEach(function(child) {
        if (child.type === "label" && !child.businessObject.name) {
          child.hidden = true;
        }
      });
    }
  }
  function expandedBounds(shape, defaultSize) {
    var children = shape.children, newBounds = defaultSize, visibleElements, visibleBBox;
    visibleElements = filterVisible(children).concat([shape]);
    visibleBBox = computeChildrenBBox(visibleElements);
    if (visibleBBox) {
      newBounds.width = Math.max(visibleBBox.width, newBounds.width);
      newBounds.height = Math.max(visibleBBox.height, newBounds.height);
      newBounds.x = visibleBBox.x + (visibleBBox.width - newBounds.width) / 2;
      newBounds.y = visibleBBox.y + (visibleBBox.height - newBounds.height) / 2;
    } else {
      newBounds.x = shape.x + (shape.width - newBounds.width) / 2;
      newBounds.y = shape.y + (shape.height - newBounds.height) / 2;
    }
    return newBounds;
  }
  function collapsedBounds(shape, defaultSize) {
    return {
      x: shape.x + (shape.width - defaultSize.width) / 2,
      y: shape.y + (shape.height - defaultSize.height) / 2,
      width: defaultSize.width,
      height: defaultSize.height
    };
  }
  this.executed(["shape.toggleCollapse"], LOW_PRIORITY$d, function(e2) {
    var context = e2.context, shape = context.shape;
    if (!is$1(shape, "bpmn:SubProcess")) {
      return;
    }
    if (!shape.collapsed) {
      hideEmptyLabels(shape.children);
      getDi(shape).isExpanded = true;
    } else {
      getDi(shape).isExpanded = false;
    }
  });
  this.reverted(["shape.toggleCollapse"], LOW_PRIORITY$d, function(e2) {
    var context = e2.context;
    var shape = context.shape;
    if (!shape.collapsed) {
      getDi(shape).isExpanded = true;
    } else {
      getDi(shape).isExpanded = false;
    }
  });
  this.postExecuted(["shape.toggleCollapse"], LOW_PRIORITY$d, function(e2) {
    var shape = e2.context.shape, defaultSize = elementFactory.getDefaultSize(shape), newBounds;
    if (shape.collapsed) {
      newBounds = collapsedBounds(shape, defaultSize);
    } else {
      newBounds = expandedBounds(shape, defaultSize);
    }
    modeling.resizeShape(shape, newBounds, null, {
      autoResize: shape.collapsed ? false : "nwse"
    });
  });
}
e$3(ToggleElementCollapseBehaviour, CommandInterceptor);
ToggleElementCollapseBehaviour.$inject = [
  "eventBus",
  "elementFactory",
  "modeling"
];
function filterVisible(elements) {
  return elements.filter(function(e2) {
    return !e2.hidden;
  });
}
function UnclaimIdBehavior(canvas, injector, moddle, modeling) {
  injector.invoke(CommandInterceptor, this);
  this.preExecute("shape.delete", function(event2) {
    var context = event2.context, shape = context.shape, shapeBo = shape.businessObject;
    if (isLabel(shape)) {
      return;
    }
    if (is$1(shape, "bpmn:Participant") && isExpanded(shape)) {
      moddle.ids.unclaim(shapeBo.processRef.id);
    }
    modeling.unclaimId(shapeBo.id, shapeBo);
  });
  this.preExecute("connection.delete", function(event2) {
    var context = event2.context, connection = context.connection, connectionBo = connection.businessObject;
    modeling.unclaimId(connectionBo.id, connectionBo);
  });
  this.preExecute("canvas.updateRoot", function() {
    var rootElement = canvas.getRootElement(), rootElementBo = rootElement.businessObject;
    if (is$1(rootElement, "bpmn:Collaboration")) {
      moddle.ids.unclaim(rootElementBo.id);
    }
  });
}
e$3(UnclaimIdBehavior, CommandInterceptor);
UnclaimIdBehavior.$inject = ["canvas", "injector", "moddle", "modeling"];
function DeleteSequenceFlowBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("connection.delete", function(event2) {
    var context = event2.context, connection = context.connection, source = connection.source;
    if (isDefaultFlow(connection, source)) {
      modeling.updateProperties(source, {
        "default": null
      });
    }
  });
}
e$3(DeleteSequenceFlowBehavior, CommandInterceptor);
DeleteSequenceFlowBehavior.$inject = [
  "eventBus",
  "modeling"
];
function isDefaultFlow(connection, source) {
  if (!is$1(connection, "bpmn:SequenceFlow")) {
    return false;
  }
  var sourceBo = getBusinessObject(source), sequenceFlow = getBusinessObject(connection);
  return sourceBo.get("default") === sequenceFlow;
}
var LOW_PRIORITY$c = 500, HIGH_PRIORITY$c = 5e3;
function UpdateFlowNodeRefsBehavior(eventBus, modeling, translate2) {
  CommandInterceptor.call(this, eventBus);
  var context;
  function initContext() {
    context = context || new UpdateContext();
    context.enter();
    return context;
  }
  function getContext() {
    if (!context) {
      throw new Error(translate2("out of bounds release"));
    }
    return context;
  }
  function releaseContext() {
    if (!context) {
      throw new Error(translate2("out of bounds release"));
    }
    var triggerUpdate = context.leave();
    if (triggerUpdate) {
      modeling.updateLaneRefs(context.flowNodes, context.lanes);
      context = null;
    }
    return triggerUpdate;
  }
  var laneRefUpdateEvents = [
    "spaceTool",
    "lane.add",
    "lane.resize",
    "lane.split",
    "elements.create",
    "elements.delete",
    "elements.move",
    "shape.create",
    "shape.delete",
    "shape.move",
    "shape.resize"
  ];
  this.preExecute(laneRefUpdateEvents, HIGH_PRIORITY$c, function(event2) {
    initContext();
  });
  this.postExecuted(laneRefUpdateEvents, LOW_PRIORITY$c, function(event2) {
    releaseContext();
  });
  this.preExecute([
    "shape.create",
    "shape.move",
    "shape.delete",
    "shape.resize"
  ], function(event2) {
    var context2 = event2.context, shape = context2.shape;
    var updateContext = getContext();
    if (shape.labelTarget) {
      return;
    }
    if (is$1(shape, "bpmn:Lane")) {
      updateContext.addLane(shape);
    }
    if (is$1(shape, "bpmn:FlowNode")) {
      updateContext.addFlowNode(shape);
    }
  });
}
UpdateFlowNodeRefsBehavior.$inject = [
  "eventBus",
  "modeling",
  "translate"
];
e$3(UpdateFlowNodeRefsBehavior, CommandInterceptor);
function UpdateContext() {
  this.flowNodes = [];
  this.lanes = [];
  this.counter = 0;
  this.addLane = function(lane) {
    this.lanes.push(lane);
  };
  this.addFlowNode = function(flowNode) {
    this.flowNodes.push(flowNode);
  };
  this.enter = function() {
    this.counter++;
  };
  this.leave = function() {
    this.counter--;
    return !this.counter;
  };
}
const BehaviorModule = {
  __init__: [
    "adaptiveLabelPositioningBehavior",
    "appendBehavior",
    "associationBehavior",
    "attachEventBehavior",
    "boundaryEventBehavior",
    "compensateBoundaryEventBehaviour",
    "createBehavior",
    "createDataObjectBehavior",
    "createParticipantBehavior",
    "dataInputAssociationBehavior",
    "dataStoreBehavior",
    "deleteLaneBehavior",
    "detachEventBehavior",
    "dropOnFlowBehavior",
    "eventBasedGatewayBehavior",
    "fixHoverBehavior",
    "groupBehavior",
    "importDockingFix",
    "isHorizontalFix",
    "labelBehavior",
    "layoutConnectionBehavior",
    "messageFlowBehavior",
    "nonInterruptingBehavior",
    "removeElementBehavior",
    "removeEmbeddedLabelBoundsBehavior",
    "removeParticipantBehavior",
    "replaceConnectionBehavior",
    "replaceElementBehaviour",
    "resizeBehavior",
    "resizeLaneBehavior",
    "rootElementReferenceBehavior",
    "spaceToolBehavior",
    "subProcessPlaneBehavior",
    "subProcessStartEventBehavior",
    "textAnnotationBehavior",
    "toggleCollapseConnectionBehaviour",
    "toggleElementCollapseBehaviour",
    "unclaimIdBehavior",
    "updateFlowNodeRefsBehavior",
    "unsetDefaultFlowBehavior"
  ],
  adaptiveLabelPositioningBehavior: ["type", AdaptiveLabelPositioningBehavior],
  appendBehavior: ["type", AppendBehavior],
  associationBehavior: ["type", AssociationBehavior],
  attachEventBehavior: ["type", AttachEventBehavior],
  boundaryEventBehavior: ["type", BoundaryEventBehavior],
  compensateBoundaryEventBehaviour: ["type", CompensateBoundaryEventBehavior],
  createBehavior: ["type", CreateBehavior],
  createDataObjectBehavior: ["type", CreateDataObjectBehavior],
  createParticipantBehavior: ["type", CreateParticipantBehavior],
  dataInputAssociationBehavior: ["type", DataInputAssociationBehavior],
  dataStoreBehavior: ["type", DataStoreBehavior],
  deleteLaneBehavior: ["type", DeleteLaneBehavior],
  detachEventBehavior: ["type", DetachEventBehavior],
  dropOnFlowBehavior: ["type", DropOnFlowBehavior],
  eventBasedGatewayBehavior: ["type", EventBasedGatewayBehavior],
  fixHoverBehavior: ["type", FixHoverBehavior],
  groupBehavior: ["type", GroupBehavior],
  importDockingFix: ["type", ImportDockingFix],
  isHorizontalFix: ["type", IsHorizontalFix],
  labelBehavior: ["type", LabelBehavior],
  layoutConnectionBehavior: ["type", LayoutConnectionBehavior],
  messageFlowBehavior: ["type", MessageFlowBehavior],
  nonInterruptingBehavior: ["type", NonInterruptingBehavior],
  removeElementBehavior: ["type", RemoveElementBehavior],
  removeEmbeddedLabelBoundsBehavior: ["type", RemoveEmbeddedLabelBoundsBehavior],
  removeParticipantBehavior: ["type", RemoveParticipantBehavior],
  replaceConnectionBehavior: ["type", ReplaceConnectionBehavior],
  replaceElementBehaviour: ["type", ReplaceElementBehaviour],
  resizeBehavior: ["type", ResizeBehavior$1],
  resizeLaneBehavior: ["type", ResizeLaneBehavior],
  rootElementReferenceBehavior: ["type", RootElementReferenceBehavior],
  spaceToolBehavior: ["type", SpaceToolBehavior$1],
  subProcessPlaneBehavior: ["type", SubProcessPlaneBehavior],
  subProcessStartEventBehavior: ["type", SubProcessStartEventBehavior],
  textAnnotationBehavior: ["type", TextAnnotationBehavior],
  toggleCollapseConnectionBehaviour: ["type", ToggleCollapseConnectionBehaviour],
  toggleElementCollapseBehaviour: ["type", ToggleElementCollapseBehaviour],
  unclaimIdBehavior: ["type", UnclaimIdBehavior],
  unsetDefaultFlowBehavior: ["type", DeleteSequenceFlowBehavior],
  updateFlowNodeRefsBehavior: ["type", UpdateFlowNodeRefsBehavior]
};
function getBoundaryAttachment(position, targetBounds) {
  var orientation = getOrientation(position, targetBounds, -15);
  if (orientation !== "intersect") {
    return orientation;
  } else {
    return null;
  }
}
function BpmnRules(eventBus) {
  RuleProvider.call(this, eventBus);
}
e$3(BpmnRules, RuleProvider);
BpmnRules.$inject = ["eventBus"];
BpmnRules.prototype.init = function() {
  this.addRule("connection.start", function(context) {
    var source = context.source;
    return canStartConnection(source);
  });
  this.addRule("connection.create", function(context) {
    var source = context.source, target = context.target, hints = context.hints || {}, targetParent = hints.targetParent, targetAttach = hints.targetAttach;
    if (targetAttach) {
      return false;
    }
    if (targetParent) {
      target.parent = targetParent;
    }
    try {
      return canConnect(source, target);
    } finally {
      if (targetParent) {
        target.parent = null;
      }
    }
  });
  this.addRule("connection.reconnect", function(context) {
    var connection = context.connection, source = context.source, target = context.target;
    return canConnect(source, target, connection);
  });
  this.addRule("connection.updateWaypoints", function(context) {
    return {
      type: context.connection.type
    };
  });
  this.addRule("shape.resize", function(context) {
    var shape = context.shape, newBounds = context.newBounds;
    return canResize(shape, newBounds);
  });
  this.addRule("elements.create", function(context) {
    var elements = context.elements, position = context.position, target = context.target;
    if (isConnection(target) && !canInsert(elements, target)) {
      return false;
    }
    return every(elements, function(element) {
      if (isConnection(element)) {
        return canConnect(element.source, element.target, element);
      }
      if (element.host) {
        return canAttach(element, element.host, null, position);
      }
      return canCreate(element, target, null);
    });
  });
  this.addRule("elements.move", function(context) {
    var target = context.target, shapes = context.shapes, position = context.position;
    return canAttach(shapes, target, null, position) || canReplace(shapes, target, position) || canMove(shapes, target) || canInsert(shapes, target);
  });
  this.addRule("shape.create", function(context) {
    return canCreate(
      context.shape,
      context.target,
      context.source,
      context.position
    );
  });
  this.addRule("shape.attach", function(context) {
    return canAttach(
      context.shape,
      context.target,
      null,
      context.position
    );
  });
  this.addRule("element.copy", function(context) {
    var element = context.element, elements = context.elements;
    return canCopy(elements, element);
  });
};
BpmnRules.prototype.canConnectMessageFlow = canConnectMessageFlow;
BpmnRules.prototype.canConnectSequenceFlow = canConnectSequenceFlow;
BpmnRules.prototype.canConnectDataAssociation = canConnectDataAssociation;
BpmnRules.prototype.canConnectAssociation = canConnectAssociation;
BpmnRules.prototype.canConnectCompensationAssociation = canConnectCompensationAssociation;
BpmnRules.prototype.canMove = canMove;
BpmnRules.prototype.canAttach = canAttach;
BpmnRules.prototype.canReplace = canReplace;
BpmnRules.prototype.canDrop = canDrop;
BpmnRules.prototype.canInsert = canInsert;
BpmnRules.prototype.canCreate = canCreate;
BpmnRules.prototype.canConnect = canConnect;
BpmnRules.prototype.canResize = canResize;
BpmnRules.prototype.canCopy = canCopy;
function canStartConnection(element) {
  if (nonExistingOrLabel(element)) {
    return null;
  }
  return isAny(element, [
    "bpmn:FlowNode",
    "bpmn:InteractionNode",
    "bpmn:DataObjectReference",
    "bpmn:DataStoreReference",
    "bpmn:Group",
    "bpmn:TextAnnotation"
  ]);
}
function nonExistingOrLabel(element) {
  return !element || isLabel(element);
}
function isSame$1(a2, b2) {
  return a2 === b2;
}
function getOrganizationalParent(element) {
  do {
    if (is$1(element, "bpmn:Process")) {
      return getBusinessObject(element);
    }
    if (is$1(element, "bpmn:Participant")) {
      return getBusinessObject(element).processRef || getBusinessObject(element);
    }
  } while (element = element.parent);
}
function isTextAnnotation(element) {
  return is$1(element, "bpmn:TextAnnotation");
}
function isGroup(element) {
  return is$1(element, "bpmn:Group") && !element.labelTarget;
}
function isCompensationBoundary(element) {
  return is$1(element, "bpmn:BoundaryEvent") && hasEventDefinition$1(element, "bpmn:CompensateEventDefinition");
}
function isForCompensation(element) {
  return getBusinessObject(element).isForCompensation;
}
function isSameOrganization(a2, b2) {
  var parentA = getOrganizationalParent(a2), parentB = getOrganizationalParent(b2);
  return parentA === parentB;
}
function isMessageFlowSource(element) {
  return is$1(element, "bpmn:InteractionNode") && !is$1(element, "bpmn:BoundaryEvent") && (!is$1(element, "bpmn:Event") || is$1(element, "bpmn:ThrowEvent") && hasEventDefinitionOrNone(element, "bpmn:MessageEventDefinition"));
}
function isMessageFlowTarget(element) {
  return is$1(element, "bpmn:InteractionNode") && !isForCompensation(element) && (!is$1(element, "bpmn:Event") || is$1(element, "bpmn:CatchEvent") && hasEventDefinitionOrNone(element, "bpmn:MessageEventDefinition")) && !(is$1(element, "bpmn:BoundaryEvent") && !hasEventDefinition$1(element, "bpmn:MessageEventDefinition"));
}
function getScopeParent(element) {
  var parent = element;
  while (parent = parent.parent) {
    if (is$1(parent, "bpmn:FlowElementsContainer")) {
      return getBusinessObject(parent);
    }
    if (is$1(parent, "bpmn:Participant")) {
      return getBusinessObject(parent).processRef;
    }
  }
  return null;
}
function isSameScope(a2, b2) {
  var scopeParentA = getScopeParent(a2), scopeParentB = getScopeParent(b2);
  return scopeParentA === scopeParentB;
}
function hasEventDefinition$1(element, eventDefinition) {
  var businessObject = getBusinessObject(element);
  return !!find(businessObject.eventDefinitions || [], function(definition) {
    return is$1(definition, eventDefinition);
  });
}
function hasEventDefinitionOrNone(element, eventDefinition) {
  var businessObject = getBusinessObject(element);
  return (businessObject.eventDefinitions || []).every(function(definition) {
    return is$1(definition, eventDefinition);
  });
}
function isSequenceFlowSource(element) {
  return is$1(element, "bpmn:FlowNode") && !is$1(element, "bpmn:EndEvent") && !isEventSubProcess(element) && !(is$1(element, "bpmn:IntermediateThrowEvent") && hasEventDefinition$1(element, "bpmn:LinkEventDefinition")) && !isCompensationBoundary(element) && !isForCompensation(element);
}
function isSequenceFlowTarget(element) {
  return is$1(element, "bpmn:FlowNode") && !is$1(element, "bpmn:StartEvent") && !is$1(element, "bpmn:BoundaryEvent") && !isEventSubProcess(element) && !(is$1(element, "bpmn:IntermediateCatchEvent") && hasEventDefinition$1(element, "bpmn:LinkEventDefinition")) && !isForCompensation(element);
}
function isEventBasedTarget(element) {
  return is$1(element, "bpmn:ReceiveTask") || is$1(element, "bpmn:IntermediateCatchEvent") && (hasEventDefinition$1(element, "bpmn:MessageEventDefinition") || hasEventDefinition$1(element, "bpmn:TimerEventDefinition") || hasEventDefinition$1(element, "bpmn:ConditionalEventDefinition") || hasEventDefinition$1(element, "bpmn:SignalEventDefinition"));
}
function getParents(element) {
  var parents = [];
  while (element) {
    element = element.parent;
    if (element) {
      parents.push(element);
    }
  }
  return parents;
}
function isParent(possibleParent, element) {
  var allParents = getParents(element);
  return allParents.indexOf(possibleParent) !== -1;
}
function canConnect(source, target, connection) {
  if (nonExistingOrLabel(source) || nonExistingOrLabel(target)) {
    return null;
  }
  if (!is$1(connection, "bpmn:DataAssociation")) {
    if (canConnectMessageFlow(source, target)) {
      return { type: "bpmn:MessageFlow" };
    }
    if (canConnectSequenceFlow(source, target)) {
      return { type: "bpmn:SequenceFlow" };
    }
  }
  var connectDataAssociation = canConnectDataAssociation(source, target);
  if (connectDataAssociation) {
    return connectDataAssociation;
  }
  if (canConnectCompensationAssociation(source, target)) {
    return {
      type: "bpmn:Association",
      associationDirection: "One"
    };
  }
  if (canConnectAssociation(source, target)) {
    return {
      type: "bpmn:Association",
      associationDirection: "None"
    };
  }
  return false;
}
function canDrop(element, target) {
  if (isLabel(element) || isGroup(element)) {
    return true;
  }
  if (is$1(target, "bpmn:Participant") && !isExpanded(target)) {
    return false;
  }
  if (is$1(element, "bpmn:Participant")) {
    return is$1(target, "bpmn:Process") || is$1(target, "bpmn:Collaboration");
  }
  if (isAny(element, ["bpmn:DataInput", "bpmn:DataOutput"])) {
    if (element.parent) {
      return target === element.parent;
    }
  }
  if (is$1(element, "bpmn:Lane")) {
    return is$1(target, "bpmn:Participant") || is$1(target, "bpmn:Lane");
  }
  if (is$1(element, "bpmn:BoundaryEvent") && !isDroppableBoundaryEvent(element)) {
    return false;
  }
  if (is$1(element, "bpmn:FlowElement") && !is$1(element, "bpmn:DataStoreReference")) {
    if (is$1(target, "bpmn:FlowElementsContainer")) {
      return isExpanded(target);
    }
    return isAny(target, ["bpmn:Participant", "bpmn:Lane"]);
  }
  if (is$1(element, "bpmn:DataStoreReference") && is$1(target, "bpmn:Collaboration")) {
    return some(getBusinessObject(target).get("participants"), function(participant) {
      return !!participant.get("processRef");
    });
  }
  if (isAny(element, ["bpmn:Artifact", "bpmn:DataAssociation", "bpmn:DataStoreReference"])) {
    return isAny(target, [
      "bpmn:Collaboration",
      "bpmn:Lane",
      "bpmn:Participant",
      "bpmn:Process",
      "bpmn:SubProcess"
    ]);
  }
  if (is$1(element, "bpmn:MessageFlow")) {
    return is$1(target, "bpmn:Collaboration") || element.source.parent == target || element.target.parent == target;
  }
  return false;
}
function isDroppableBoundaryEvent(event2) {
  return getBusinessObject(event2).cancelActivity && (hasNoEventDefinition(event2) || hasCommonBoundaryIntermediateEventDefinition(event2));
}
function isBoundaryEvent(element) {
  return !isLabel(element) && is$1(element, "bpmn:BoundaryEvent");
}
function isLane(element) {
  return is$1(element, "bpmn:Lane");
}
function isBoundaryCandidate(element) {
  if (isBoundaryEvent(element)) {
    return true;
  }
  if (is$1(element, "bpmn:IntermediateThrowEvent") && hasNoEventDefinition(element)) {
    return true;
  }
  return is$1(element, "bpmn:IntermediateCatchEvent") && hasCommonBoundaryIntermediateEventDefinition(element);
}
function hasNoEventDefinition(element) {
  var businessObject = getBusinessObject(element);
  return businessObject && !(businessObject.eventDefinitions && businessObject.eventDefinitions.length);
}
function hasCommonBoundaryIntermediateEventDefinition(element) {
  return hasOneOfEventDefinitions(element, [
    "bpmn:MessageEventDefinition",
    "bpmn:TimerEventDefinition",
    "bpmn:SignalEventDefinition",
    "bpmn:ConditionalEventDefinition"
  ]);
}
function hasOneOfEventDefinitions(element, eventDefinitions) {
  return eventDefinitions.some(function(definition) {
    return hasEventDefinition$1(element, definition);
  });
}
function isReceiveTaskAfterEventBasedGateway(element) {
  return is$1(element, "bpmn:ReceiveTask") && find(element.incoming, function(incoming) {
    return is$1(incoming.source, "bpmn:EventBasedGateway");
  });
}
function canAttach(elements, target, source, position) {
  if (!Array.isArray(elements)) {
    elements = [elements];
  }
  if (elements.length !== 1) {
    return false;
  }
  var element = elements[0];
  if (isLabel(element)) {
    return false;
  }
  if (!isBoundaryCandidate(element)) {
    return false;
  }
  if (isEventSubProcess(target)) {
    return false;
  }
  if (!is$1(target, "bpmn:Activity") || isForCompensation(target)) {
    return false;
  }
  if (position && !getBoundaryAttachment(position, target)) {
    return false;
  }
  if (isReceiveTaskAfterEventBasedGateway(target)) {
    return false;
  }
  return "attach";
}
function canReplace(elements, target, position) {
  if (!target) {
    return false;
  }
  var canExecute = {
    replacements: []
  };
  forEach$1(elements, function(element) {
    if (!isEventSubProcess(target)) {
      if (is$1(element, "bpmn:StartEvent") && element.type !== "label" && canDrop(element, target)) {
        if (!isInterrupting(element)) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: "bpmn:StartEvent"
          });
        }
        if (hasErrorEventDefinition(element) || hasEscalationEventDefinition(element) || hasCompensateEventDefinition(element)) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: "bpmn:StartEvent"
          });
        }
        if (hasOneOfEventDefinitions(
          element,
          [
            "bpmn:MessageEventDefinition",
            "bpmn:TimerEventDefinition",
            "bpmn:SignalEventDefinition",
            "bpmn:ConditionalEventDefinition"
          ]
        ) && is$1(target, "bpmn:SubProcess")) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: "bpmn:StartEvent"
          });
        }
      }
    }
    if (!is$1(target, "bpmn:Transaction")) {
      if (hasEventDefinition$1(element, "bpmn:CancelEventDefinition") && element.type !== "label") {
        if (is$1(element, "bpmn:EndEvent") && canDrop(element, target)) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: "bpmn:EndEvent"
          });
        }
        if (is$1(element, "bpmn:BoundaryEvent") && canAttach(element, target, null, position)) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: "bpmn:BoundaryEvent"
          });
        }
      }
    }
  });
  return canExecute.replacements.length ? canExecute : false;
}
function canMove(elements, target) {
  if (some(elements, isLane)) {
    return false;
  }
  if (!target) {
    return true;
  }
  return elements.every(function(element) {
    return canDrop(element, target);
  });
}
function canCreate(shape, target, source, position) {
  if (!target) {
    return false;
  }
  if (isLabel(shape) || isGroup(shape)) {
    return true;
  }
  if (isSame$1(source, target)) {
    return false;
  }
  if (source && isParent(source, target)) {
    return false;
  }
  return canDrop(shape, target) || canInsert(shape, target);
}
function canResize(shape, newBounds) {
  if (is$1(shape, "bpmn:SubProcess")) {
    return isExpanded(shape) && (!newBounds || newBounds.width >= 100 && newBounds.height >= 80);
  }
  if (is$1(shape, "bpmn:Lane")) {
    return true;
  }
  if (is$1(shape, "bpmn:Participant")) {
    return true;
  }
  if (isTextAnnotation(shape)) {
    return true;
  }
  if (isGroup(shape)) {
    return true;
  }
  return false;
}
function isOneTextAnnotation(source, target) {
  var sourceTextAnnotation = isTextAnnotation(source), targetTextAnnotation = isTextAnnotation(target);
  return (sourceTextAnnotation || targetTextAnnotation) && sourceTextAnnotation !== targetTextAnnotation;
}
function canConnectAssociation(source, target) {
  if (isParent(target, source) || isParent(source, target)) {
    return false;
  }
  if (isOneTextAnnotation(source, target)) {
    return true;
  }
  return !!canConnectDataAssociation(source, target);
}
function canConnectCompensationAssociation(source, target) {
  return isSameScope(source, target) && isCompensationBoundary(source) && is$1(target, "bpmn:Activity") && !isHostOfElement(target, source) && !isEventSubProcess(target);
}
function canConnectMessageFlow(source, target) {
  if (getRootElement(source) && !getRootElement(target)) {
    return false;
  }
  return isMessageFlowSource(source) && isMessageFlowTarget(target) && !isSameOrganization(source, target);
}
function canConnectSequenceFlow(source, target) {
  return isSequenceFlowSource(source) && isSequenceFlowTarget(target) && isSameScope(source, target) && !(is$1(source, "bpmn:EventBasedGateway") && !isEventBasedTarget(target));
}
function canConnectDataAssociation(source, target) {
  if (isAny(source, ["bpmn:DataObjectReference", "bpmn:DataStoreReference"]) && isAny(target, ["bpmn:Activity", "bpmn:ThrowEvent"])) {
    return { type: "bpmn:DataInputAssociation" };
  }
  if (isAny(target, ["bpmn:DataObjectReference", "bpmn:DataStoreReference"]) && isAny(source, ["bpmn:Activity", "bpmn:CatchEvent"])) {
    return { type: "bpmn:DataOutputAssociation" };
  }
  return false;
}
function canInsert(shape, connection, position) {
  if (!connection) {
    return false;
  }
  if (Array.isArray(shape)) {
    if (shape.length !== 1) {
      return false;
    }
    shape = shape[0];
  }
  if (connection.source === shape || connection.target === shape) {
    return false;
  }
  return isAny(connection, ["bpmn:SequenceFlow", "bpmn:MessageFlow"]) && !isLabel(connection) && is$1(shape, "bpmn:FlowNode") && !is$1(shape, "bpmn:BoundaryEvent") && canDrop(shape, connection.parent);
}
function includes$6(elements, element) {
  return elements && element && elements.indexOf(element) !== -1;
}
function canCopy(elements, element) {
  if (isLabel(element)) {
    return true;
  }
  if (is$1(element, "bpmn:Lane") && !includes$6(elements, element.parent)) {
    return false;
  }
  return true;
}
function getRootElement(element) {
  return getParent(element, "bpmn:Process") || getParent(element, "bpmn:Collaboration");
}
function isHostOfElement(potentialHost, element) {
  return potentialHost.attachers.includes(element);
}
const RulesModule = {
  __depends__: [
    RulesModule$1
  ],
  __init__: ["bpmnRules"],
  bpmnRules: ["type", BpmnRules]
};
var HIGH_PRIORITY$b = 2e3;
function BpmnDiOrdering(eventBus, canvas) {
  eventBus.on("saveXML.start", HIGH_PRIORITY$b, orderDi);
  function orderDi() {
    var rootElements = canvas.getRootElements();
    forEach$1(rootElements, function(root) {
      var rootDi = getDi(root), elements, diElements;
      elements = selfAndAllChildren([root], false);
      elements = filter(elements, function(element) {
        return element !== root && !element.labelTarget;
      });
      diElements = map$1(elements, getDi);
      rootDi.set("planeElement", diElements);
    });
  }
}
BpmnDiOrdering.$inject = ["eventBus", "canvas"];
const DiOrderingModule = {
  __init__: [
    "bpmnDiOrdering"
  ],
  bpmnDiOrdering: ["type", BpmnDiOrdering]
};
function OrderingProvider(eventBus) {
  CommandInterceptor.call(this, eventBus);
  var self2 = this;
  this.preExecute(["shape.create", "connection.create"], function(event2) {
    var context = event2.context, element = context.shape || context.connection, parent = context.parent;
    var ordering = self2.getOrdering(element, parent);
    if (ordering) {
      if (ordering.parent !== void 0) {
        context.parent = ordering.parent;
      }
      context.parentIndex = ordering.index;
    }
  });
  this.preExecute(["shape.move", "connection.move"], function(event2) {
    var context = event2.context, element = context.shape || context.connection, parent = context.newParent || element.parent;
    var ordering = self2.getOrdering(element, parent);
    if (ordering) {
      if (ordering.parent !== void 0) {
        context.newParent = ordering.parent;
      }
      context.newParentIndex = ordering.index;
    }
  });
}
OrderingProvider.prototype.getOrdering = function(element, newParent) {
  return null;
};
e$3(OrderingProvider, CommandInterceptor);
function BpmnOrderingProvider(eventBus, canvas, translate2) {
  OrderingProvider.call(this, eventBus);
  var orders = [
    { type: "bpmn:SubProcess", order: { level: 6 } },
    // handle SequenceFlow(s) like message flows and render them always on top
    {
      type: "bpmn:SequenceFlow",
      order: {
        level: 9,
        containers: [
          "bpmn:Participant",
          "bpmn:FlowElementsContainer"
        ]
      }
    },
    // handle DataAssociation(s) like message flows and render them always on top
    {
      type: "bpmn:DataAssociation",
      order: {
        level: 9,
        containers: [
          "bpmn:Collaboration",
          "bpmn:FlowElementsContainer"
        ]
      }
    },
    {
      type: "bpmn:TextAnnotation",
      order: {
        level: 9
      }
    },
    {
      type: "bpmn:MessageFlow",
      order: {
        level: 9,
        containers: ["bpmn:Collaboration"]
      }
    },
    {
      type: "bpmn:Association",
      order: {
        level: 6,
        containers: [
          "bpmn:Participant",
          "bpmn:FlowElementsContainer",
          "bpmn:Collaboration"
        ]
      }
    },
    { type: "bpmn:BoundaryEvent", order: { level: 8 } },
    {
      type: "bpmn:Group",
      order: {
        level: 10,
        containers: [
          "bpmn:Collaboration",
          "bpmn:FlowElementsContainer"
        ]
      }
    },
    { type: "bpmn:FlowElement", order: { level: 5 } },
    { type: "bpmn:Participant", order: { level: -2 } },
    { type: "bpmn:Lane", order: { level: -1 } }
  ];
  function computeOrder(element) {
    if (element.labelTarget) {
      return { level: 10 };
    }
    var entry = find(orders, function(o2) {
      return isAny(element, [o2.type]);
    });
    return entry && entry.order || { level: 1 };
  }
  function getOrder(element) {
    var order = element.order;
    if (!order) {
      element.order = order = computeOrder(element);
    }
    if (!order) {
      throw new Error("no order for <" + element.id + ">");
    }
    return order;
  }
  function findActualParent(element, newParent, containers) {
    var actualParent = newParent;
    while (actualParent) {
      if (isAny(actualParent, containers)) {
        break;
      }
      actualParent = actualParent.parent;
    }
    if (!actualParent) {
      throw new Error("no parent for <" + element.id + "> in <" + (newParent && newParent.id) + ">");
    }
    return actualParent;
  }
  this.getOrdering = function(element, newParent) {
    if (element.labelTarget || is$1(element, "bpmn:TextAnnotation")) {
      return {
        parent: canvas.findRoot(newParent) || canvas.getRootElement(),
        index: -1
      };
    }
    var elementOrder = getOrder(element);
    if (elementOrder.containers) {
      newParent = findActualParent(element, newParent, elementOrder.containers);
    }
    var currentIndex = newParent.children.indexOf(element);
    var insertIndex = findIndex(newParent.children, function(child) {
      if (!element.labelTarget && child.labelTarget) {
        return false;
      }
      return elementOrder.level < getOrder(child).level;
    });
    if (insertIndex !== -1) {
      if (currentIndex !== -1 && currentIndex < insertIndex) {
        insertIndex -= 1;
      }
    }
    return {
      index: insertIndex,
      parent: newParent
    };
  };
}
BpmnOrderingProvider.$inject = ["eventBus", "canvas", "translate"];
e$3(BpmnOrderingProvider, OrderingProvider);
const OrderingModule = {
  __depends__: [
    translate
  ],
  __init__: ["bpmnOrderingProvider"],
  bpmnOrderingProvider: ["type", BpmnOrderingProvider]
};
function Clipboard() {
}
Clipboard.prototype.get = function() {
  return this._data;
};
Clipboard.prototype.set = function(data) {
  this._data = data;
};
Clipboard.prototype.clear = function() {
  var data = this._data;
  delete this._data;
  return data;
};
Clipboard.prototype.isEmpty = function() {
  return !this._data;
};
const ClipboardModule = {
  clipboard: ["type", Clipboard]
};
var MARKER_OK$2 = "drop-ok", MARKER_NOT_OK$2 = "drop-not-ok", MARKER_ATTACH$2 = "attach-ok", MARKER_NEW_PARENT$1 = "new-parent";
var PREFIX = "create";
var HIGH_PRIORITY$a = 2e3;
function Create(canvas, dragging, eventBus, modeling, rules) {
  function canCreate2(elements, target, position, source, hints) {
    if (!target) {
      return false;
    }
    elements = filter(elements, function(element) {
      var labelTarget = element.labelTarget;
      return !element.parent && !(isLabel(element) && elements.indexOf(labelTarget) !== -1);
    });
    var shape = find(elements, function(element) {
      return !isConnection(element);
    });
    var attach = false, connect = false, create2 = false;
    if (isSingleShape(elements)) {
      attach = rules.allowed("shape.attach", {
        position,
        shape,
        target
      });
    }
    if (!attach) {
      if (isSingleShape(elements)) {
        create2 = rules.allowed("shape.create", {
          position,
          shape,
          source,
          target
        });
      } else {
        create2 = rules.allowed("elements.create", {
          elements,
          position,
          target
        });
      }
    }
    var connectionTarget = hints.connectionTarget;
    if (create2 || attach) {
      if (shape && source) {
        connect = rules.allowed("connection.create", {
          source: connectionTarget === source ? shape : source,
          target: connectionTarget === source ? source : shape,
          hints: {
            targetParent: target,
            targetAttach: attach
          }
        });
      }
      return {
        attach,
        connect
      };
    }
    if (create2 === null || attach === null) {
      return null;
    }
    return false;
  }
  function setMarker(element, marker) {
    [MARKER_ATTACH$2, MARKER_OK$2, MARKER_NOT_OK$2, MARKER_NEW_PARENT$1].forEach(function(m2) {
      if (m2 === marker) {
        canvas.addMarker(element, m2);
      } else {
        canvas.removeMarker(element, m2);
      }
    });
  }
  eventBus.on(["create.move", "create.hover"], function(event2) {
    var context = event2.context, elements = context.elements, hover = event2.hover, source = context.source, hints = context.hints || {};
    if (!hover) {
      context.canExecute = false;
      context.target = null;
      return;
    }
    ensureConstraints$1(event2);
    var position = {
      x: event2.x,
      y: event2.y
    };
    var canExecute = context.canExecute = hover && canCreate2(elements, hover, position, source, hints);
    if (hover && canExecute !== null) {
      context.target = hover;
      if (canExecute && canExecute.attach) {
        setMarker(hover, MARKER_ATTACH$2);
      } else {
        setMarker(hover, canExecute ? MARKER_NEW_PARENT$1 : MARKER_NOT_OK$2);
      }
    }
  });
  eventBus.on(["create.end", "create.out", "create.cleanup"], function(event2) {
    var hover = event2.hover;
    if (hover) {
      setMarker(hover, null);
    }
  });
  eventBus.on("create.end", function(event2) {
    var context = event2.context, source = context.source, shape = context.shape, elements = context.elements, target = context.target, canExecute = context.canExecute, attach = canExecute && canExecute.attach, connect = canExecute && canExecute.connect, hints = context.hints || {};
    if (canExecute === false || !target) {
      return false;
    }
    ensureConstraints$1(event2);
    var position = {
      x: event2.x,
      y: event2.y
    };
    if (connect) {
      shape = modeling.appendShape(source, shape, position, target, {
        attach,
        connection: connect === true ? {} : connect,
        connectionTarget: hints.connectionTarget
      });
    } else {
      elements = modeling.createElements(elements, position, target, assign$1({}, hints, {
        attach
      }));
      shape = find(elements, function(element) {
        return !isConnection(element);
      });
    }
    assign$1(context, {
      elements,
      shape
    });
    assign$1(event2, {
      elements,
      shape
    });
  });
  function cancel() {
    var context = dragging.context();
    if (context && context.prefix === PREFIX) {
      dragging.cancel();
    }
  }
  eventBus.on("create.init", function() {
    eventBus.on("elements.changed", cancel);
    eventBus.once(["create.cancel", "create.end"], HIGH_PRIORITY$a, function() {
      eventBus.off("elements.changed", cancel);
    });
  });
  this.start = function(event2, elements, context) {
    if (!isArray$3(elements)) {
      elements = [elements];
    }
    var shape = find(elements, function(element) {
      return !isConnection(element);
    });
    if (!shape) {
      return;
    }
    context = assign$1({
      elements,
      hints: {},
      shape
    }, context || {});
    forEach$1(elements, function(element) {
      if (!isNumber(element.x)) {
        element.x = 0;
      }
      if (!isNumber(element.y)) {
        element.y = 0;
      }
    });
    var visibleElements = filter(elements, function(element) {
      return !element.hidden;
    });
    var bbox = getBBox(visibleElements);
    forEach$1(elements, function(element) {
      if (isConnection(element)) {
        element.waypoints = map$1(element.waypoints, function(waypoint) {
          return {
            x: waypoint.x - bbox.x - bbox.width / 2,
            y: waypoint.y - bbox.y - bbox.height / 2
          };
        });
      }
      assign$1(element, {
        x: element.x - bbox.x - bbox.width / 2,
        y: element.y - bbox.y - bbox.height / 2
      });
    });
    dragging.init(event2, PREFIX, {
      cursor: "grabbing",
      autoActivate: true,
      data: {
        shape,
        elements,
        context
      }
    });
  };
}
Create.$inject = [
  "canvas",
  "dragging",
  "eventBus",
  "modeling",
  "rules"
];
function ensureConstraints$1(event2) {
  var context = event2.context, createConstraints = context.createConstraints;
  if (!createConstraints) {
    return;
  }
  if (createConstraints.left) {
    event2.x = Math.max(event2.x, createConstraints.left);
  }
  if (createConstraints.right) {
    event2.x = Math.min(event2.x, createConstraints.right);
  }
  if (createConstraints.top) {
    event2.y = Math.max(event2.y, createConstraints.top);
  }
  if (createConstraints.bottom) {
    event2.y = Math.min(event2.y, createConstraints.bottom);
  }
}
function isSingleShape(elements) {
  return elements && elements.length === 1 && !isConnection(elements[0]);
}
var LOW_PRIORITY$b = 750;
function CreatePreview(canvas, eventBus, graphicsFactory, previewSupport, styles) {
  function createDragGroup(elements) {
    var dragGroup = create$1("g");
    attr(dragGroup, styles.cls("djs-drag-group", ["no-events"]));
    var childrenGfx = create$1("g");
    elements.forEach(function(element) {
      var gfx;
      if (element.hidden) {
        return;
      }
      if (element.waypoints) {
        gfx = graphicsFactory._createContainer("connection", childrenGfx);
        graphicsFactory.drawConnection(getVisual(gfx), element);
      } else {
        gfx = graphicsFactory._createContainer("shape", childrenGfx);
        graphicsFactory.drawShape(getVisual(gfx), element);
        translate$2(gfx, element.x, element.y);
      }
      previewSupport.addDragger(element, dragGroup, gfx);
    });
    return dragGroup;
  }
  eventBus.on("create.move", LOW_PRIORITY$b, function(event2) {
    var hover = event2.hover, context = event2.context, elements = context.elements, dragGroup = context.dragGroup;
    if (!dragGroup) {
      dragGroup = context.dragGroup = createDragGroup(elements);
    }
    var activeLayer;
    if (hover) {
      if (!dragGroup.parentNode) {
        activeLayer = canvas.getActiveLayer();
        append(activeLayer, dragGroup);
      }
      translate$2(dragGroup, event2.x, event2.y);
    } else {
      remove$1(dragGroup);
    }
  });
  eventBus.on("create.cleanup", function(event2) {
    var context = event2.context, dragGroup = context.dragGroup;
    if (dragGroup) {
      remove$1(dragGroup);
    }
  });
}
CreatePreview.$inject = [
  "canvas",
  "eventBus",
  "graphicsFactory",
  "previewSupport",
  "styles"
];
const CreateModule = {
  __depends__: [
    DraggingModule,
    PreviewSupportModule,
    RulesModule$1,
    SelectionModule
  ],
  __init__: [
    "create",
    "createPreview"
  ],
  create: ["type", Create],
  createPreview: ["type", CreatePreview]
};
function Mouse(eventBus) {
  var self2 = this;
  this._lastMoveEvent = null;
  function setLastMoveEvent(mousemoveEvent) {
    self2._lastMoveEvent = mousemoveEvent;
  }
  eventBus.on("canvas.init", function(context) {
    var svg = self2._svg = context.svg;
    svg.addEventListener("mousemove", setLastMoveEvent);
  });
  eventBus.on("canvas.destroy", function() {
    self2._lastMouseEvent = null;
    self2._svg.removeEventListener("mousemove", setLastMoveEvent);
  });
}
Mouse.$inject = ["eventBus"];
Mouse.prototype.getLastMoveEvent = function() {
  return this._lastMoveEvent || createMoveEvent(0, 0);
};
function createMoveEvent(x2, y2) {
  var event2 = document.createEvent("MouseEvent");
  var screenX = x2, screenY = y2, clientX = x2, clientY = y2;
  if (event2.initMouseEvent) {
    event2.initMouseEvent(
      "mousemove",
      true,
      true,
      window,
      0,
      screenX,
      screenY,
      clientX,
      clientY,
      false,
      false,
      false,
      false,
      0,
      null
    );
  }
  return event2;
}
const MouseModule = {
  __init__: ["mouse"],
  mouse: ["type", Mouse]
};
function CopyPaste(canvas, create2, clipboard, elementFactory, eventBus, modeling, mouse, rules) {
  this._canvas = canvas;
  this._create = create2;
  this._clipboard = clipboard;
  this._elementFactory = elementFactory;
  this._eventBus = eventBus;
  this._modeling = modeling;
  this._mouse = mouse;
  this._rules = rules;
  eventBus.on("copyPaste.copyElement", function(context) {
    var descriptor = context.descriptor, element = context.element, elements = context.elements;
    descriptor.priority = 1;
    descriptor.id = element.id;
    var parentCopied = find(elements, function(e2) {
      return e2 === element.parent;
    });
    if (parentCopied) {
      descriptor.parent = element.parent.id;
    }
    if (isAttacher$2(element)) {
      descriptor.priority = 2;
      descriptor.host = element.host.id;
    }
    if (isConnection(element)) {
      descriptor.priority = 3;
      descriptor.source = element.source.id;
      descriptor.target = element.target.id;
      descriptor.waypoints = copyWaypoints$1(element);
    }
    if (isLabel(element)) {
      descriptor.priority = 4;
      descriptor.labelTarget = element.labelTarget.id;
    }
    forEach$1(["x", "y", "width", "height"], function(property) {
      if (isNumber(element[property])) {
        descriptor[property] = element[property];
      }
    });
    descriptor.hidden = element.hidden;
    descriptor.collapsed = element.collapsed;
  });
  eventBus.on("copyPaste.pasteElements", function(context) {
    var hints = context.hints;
    assign$1(hints, {
      createElementsBehavior: false
    });
  });
}
CopyPaste.$inject = [
  "canvas",
  "create",
  "clipboard",
  "elementFactory",
  "eventBus",
  "modeling",
  "mouse",
  "rules"
];
CopyPaste.prototype.copy = function(elements) {
  var allowed, tree;
  if (!isArray$3(elements)) {
    elements = elements ? [elements] : [];
  }
  allowed = this._eventBus.fire("copyPaste.canCopyElements", {
    elements
  });
  if (allowed === false) {
    tree = {};
  } else {
    tree = this.createTree(isArray$3(allowed) ? allowed : elements);
  }
  this._clipboard.set(tree);
  this._eventBus.fire("copyPaste.elementsCopied", {
    elements,
    tree
  });
  return tree;
};
CopyPaste.prototype.paste = function(context) {
  var tree = this._clipboard.get();
  if (this._clipboard.isEmpty()) {
    return;
  }
  var hints = context && context.hints || {};
  this._eventBus.fire("copyPaste.pasteElements", {
    hints
  });
  var elements = this._createElements(tree);
  if (context && context.element && context.point) {
    return this._paste(elements, context.element, context.point, hints);
  }
  this._create.start(this._mouse.getLastMoveEvent(), elements, {
    hints: hints || {}
  });
};
CopyPaste.prototype._paste = function(elements, target, position, hints) {
  forEach$1(elements, function(element) {
    if (!isNumber(element.x)) {
      element.x = 0;
    }
    if (!isNumber(element.y)) {
      element.y = 0;
    }
  });
  var bbox = getBBox(elements);
  forEach$1(elements, function(element) {
    if (isConnection(element)) {
      element.waypoints = map$1(element.waypoints, function(waypoint) {
        return {
          x: waypoint.x - bbox.x - bbox.width / 2,
          y: waypoint.y - bbox.y - bbox.height / 2
        };
      });
    }
    assign$1(element, {
      x: element.x - bbox.x - bbox.width / 2,
      y: element.y - bbox.y - bbox.height / 2
    });
  });
  return this._modeling.createElements(elements, position, target, assign$1({}, hints));
};
CopyPaste.prototype._createElements = function(tree) {
  var self2 = this;
  var eventBus = this._eventBus;
  var cache = {};
  var elements = [];
  forEach$1(tree, function(branch, depth) {
    branch = sortBy(branch, "priority");
    forEach$1(branch, function(descriptor) {
      var attrs = assign$1({}, omit(descriptor, ["priority"]));
      if (cache[descriptor.parent]) {
        attrs.parent = cache[descriptor.parent];
      } else {
        delete attrs.parent;
      }
      eventBus.fire("copyPaste.pasteElement", {
        cache,
        descriptor: attrs
      });
      var element;
      if (isConnection(attrs)) {
        attrs.source = cache[descriptor.source];
        attrs.target = cache[descriptor.target];
        element = cache[descriptor.id] = self2.createConnection(attrs);
        elements.push(element);
        return;
      }
      if (isLabel(attrs)) {
        attrs.labelTarget = cache[attrs.labelTarget];
        element = cache[descriptor.id] = self2.createLabel(attrs);
        elements.push(element);
        return;
      }
      if (attrs.host) {
        attrs.host = cache[attrs.host];
      }
      element = cache[descriptor.id] = self2.createShape(attrs);
      elements.push(element);
    });
  });
  return elements;
};
CopyPaste.prototype.createConnection = function(attrs) {
  var connection = this._elementFactory.createConnection(omit(attrs, ["id"]));
  return connection;
};
CopyPaste.prototype.createLabel = function(attrs) {
  var label = this._elementFactory.createLabel(omit(attrs, ["id"]));
  return label;
};
CopyPaste.prototype.createShape = function(attrs) {
  var shape = this._elementFactory.createShape(omit(attrs, ["id"]));
  return shape;
};
CopyPaste.prototype.hasRelations = function(element, elements) {
  var labelTarget, source, target;
  if (isConnection(element)) {
    source = find(elements, matchPattern({ id: element.source.id }));
    target = find(elements, matchPattern({ id: element.target.id }));
    if (!source || !target) {
      return false;
    }
  }
  if (isLabel(element)) {
    labelTarget = find(elements, matchPattern({ id: element.labelTarget.id }));
    if (!labelTarget) {
      return false;
    }
  }
  return true;
};
CopyPaste.prototype.createTree = function(elements) {
  var rules = this._rules, self2 = this;
  var tree = {}, elementsData = [];
  var parents = getParents$1(elements);
  function canCopy2(element, elements2) {
    return rules.allowed("element.copy", {
      element,
      elements: elements2
    });
  }
  function addElementData(element, depth) {
    var foundElementData = find(elementsData, function(elementsData2) {
      return element === elementsData2.element;
    });
    if (!foundElementData) {
      elementsData.push({
        element,
        depth
      });
      return;
    }
    if (foundElementData.depth < depth) {
      elementsData = removeElementData(foundElementData, elementsData);
      elementsData.push({
        element: foundElementData.element,
        depth
      });
    }
  }
  function removeElementData(elementData2, elementsData2) {
    var index2 = elementsData2.indexOf(elementData2);
    if (index2 !== -1) {
      elementsData2.splice(index2, 1);
    }
    return elementsData2;
  }
  eachElement(parents, function(element, _index, depth) {
    if (isLabel(element)) {
      return;
    }
    forEach$1(element.labels, function(label) {
      addElementData(label, depth);
    });
    function addRelatedElements(elements2) {
      elements2 && elements2.length && forEach$1(elements2, function(element2) {
        forEach$1(element2.labels, function(label) {
          addElementData(label, depth);
        });
        addElementData(element2, depth);
      });
    }
    forEach$1([element.attachers, element.incoming, element.outgoing], addRelatedElements);
    addElementData(element, depth);
    var children = [];
    if (element.children) {
      children = element.children.slice();
    }
    self2._eventBus.fire("copyPaste.createTree", {
      element,
      children
    });
    return children;
  });
  elements = map$1(elementsData, function(elementData2) {
    return elementData2.element;
  });
  elementsData = map$1(elementsData, function(elementData2) {
    elementData2.descriptor = {};
    self2._eventBus.fire("copyPaste.copyElement", {
      descriptor: elementData2.descriptor,
      element: elementData2.element,
      elements
    });
    return elementData2;
  });
  elementsData = sortBy(elementsData, function(elementData2) {
    return elementData2.descriptor.priority;
  });
  elements = map$1(elementsData, function(elementData2) {
    return elementData2.element;
  });
  forEach$1(elementsData, function(elementData2) {
    var depth = elementData2.depth;
    if (!self2.hasRelations(elementData2.element, elements)) {
      removeElement(elementData2.element, elements);
      return;
    }
    if (!canCopy2(elementData2.element, elements)) {
      removeElement(elementData2.element, elements);
      return;
    }
    if (!tree[depth]) {
      tree[depth] = [];
    }
    tree[depth].push(elementData2.descriptor);
  });
  return tree;
};
function isAttacher$2(element) {
  return !!element.host;
}
function copyWaypoints$1(element) {
  return map$1(element.waypoints, function(waypoint) {
    waypoint = copyWaypoint$1(waypoint);
    if (waypoint.original) {
      waypoint.original = copyWaypoint$1(waypoint.original);
    }
    return waypoint;
  });
}
function copyWaypoint$1(waypoint) {
  return assign$1({}, waypoint);
}
function removeElement(element, elements) {
  var index2 = elements.indexOf(element);
  if (index2 === -1) {
    return elements;
  }
  return elements.splice(index2, 1);
}
const CopyPasteModule$1 = {
  __depends__: [
    ClipboardModule,
    CreateModule,
    MouseModule,
    RulesModule$1
  ],
  __init__: ["copyPaste"],
  copyPaste: ["type", CopyPaste]
};
function copyProperties$1(source, target, properties) {
  if (!isArray$3(properties)) {
    properties = [properties];
  }
  forEach$1(properties, function(property) {
    if (!isUndefined$2(source[property])) {
      target[property] = source[property];
    }
  });
}
var LOW_PRIORITY$a = 750;
function BpmnCopyPaste(bpmnFactory, eventBus, moddleCopy) {
  function copy2(bo, clone2) {
    var targetBo = bpmnFactory.create(bo.$type);
    return moddleCopy.copyElement(bo, targetBo, null, clone2);
  }
  eventBus.on("copyPaste.copyElement", LOW_PRIORITY$a, function(context) {
    var descriptor = context.descriptor, element = context.element, businessObject = getBusinessObject(element);
    if (isLabel(element)) {
      return descriptor;
    }
    var businessObjectCopy = descriptor.businessObject = copy2(businessObject, true);
    var diCopy = descriptor.di = copy2(getDi(element), true);
    diCopy.bpmnElement = businessObjectCopy;
    copyProperties$1(businessObjectCopy, descriptor, "name");
    copyProperties$1(diCopy, descriptor, "isExpanded");
    if (businessObject.default) {
      descriptor.default = businessObject.default.id;
    }
  });
  var referencesKey = "-bpmn-js-refs";
  function getReferences(cache) {
    return cache[referencesKey] = cache[referencesKey] || {};
  }
  function setReferences(cache, references) {
    cache[referencesKey] = references;
  }
  function resolveReferences(descriptor, cache, references) {
    var businessObject = getBusinessObject(descriptor);
    if (descriptor.default) {
      references[descriptor.default] = {
        element: businessObject,
        property: "default"
      };
    }
    if (descriptor.host) {
      getBusinessObject(descriptor).attachedToRef = getBusinessObject(cache[descriptor.host]);
    }
    return omit(references, reduce(references, function(array, reference, key) {
      var element = reference.element, property = reference.property;
      if (key === descriptor.id) {
        element.set(property, businessObject);
        array.push(descriptor.id);
      }
      return array;
    }, []));
  }
  eventBus.on("copyPaste.pasteElement", function(context) {
    var cache = context.cache, descriptor = context.descriptor, businessObject = descriptor.businessObject, di = descriptor.di;
    if (isLabel(descriptor)) {
      descriptor.businessObject = getBusinessObject(cache[descriptor.labelTarget]);
      descriptor.di = getDi(cache[descriptor.labelTarget]);
      return;
    }
    businessObject = descriptor.businessObject = copy2(businessObject);
    di = descriptor.di = copy2(di);
    di.bpmnElement = businessObject;
    copyProperties$1(descriptor, businessObject, [
      "isExpanded",
      "name"
    ]);
    descriptor.type = businessObject.$type;
  });
  eventBus.on("copyPaste.copyElement", LOW_PRIORITY$a, function(context) {
    var descriptor = context.descriptor, element = context.element;
    if (!is$1(element, "bpmn:Participant")) {
      return;
    }
    var participantBo = getBusinessObject(element);
    if (participantBo.processRef) {
      descriptor.processRef = copy2(participantBo.processRef, true);
    }
  });
  eventBus.on("copyPaste.pasteElement", function(context) {
    var descriptor = context.descriptor, processRef = descriptor.processRef;
    if (processRef) {
      descriptor.processRef = copy2(processRef);
    }
  });
  eventBus.on("copyPaste.pasteElement", LOW_PRIORITY$a, function(context) {
    var cache = context.cache, descriptor = context.descriptor;
    setReferences(
      cache,
      resolveReferences(descriptor, cache, getReferences(cache))
    );
  });
}
BpmnCopyPaste.$inject = [
  "bpmnFactory",
  "eventBus",
  "moddleCopy"
];
var DISALLOWED_PROPERTIES = [
  "artifacts",
  "dataInputAssociations",
  "dataOutputAssociations",
  "default",
  "flowElements",
  "lanes",
  "incoming",
  "outgoing",
  "categoryValue"
];
function ModdleCopy(eventBus, bpmnFactory, moddle) {
  this._bpmnFactory = bpmnFactory;
  this._eventBus = eventBus;
  this._moddle = moddle;
  eventBus.on("moddleCopy.canCopyProperties", function(context) {
    var propertyNames = context.propertyNames;
    if (!propertyNames || !propertyNames.length) {
      return;
    }
    return sortBy(propertyNames, function(propertyName) {
      return propertyName === "extensionElements";
    });
  });
  eventBus.on("moddleCopy.canCopyProperty", function(context) {
    var parent = context.parent, parentDescriptor = isObject(parent) && parent.$descriptor, propertyName = context.propertyName;
    if (propertyName && DISALLOWED_PROPERTIES.indexOf(propertyName) !== -1) {
      return false;
    }
    if (propertyName && parentDescriptor && !find(parentDescriptor.properties, matchPattern({ name: propertyName }))) {
      return false;
    }
  });
  eventBus.on("moddleCopy.canSetCopiedProperty", function(context) {
    var property = context.property;
    if (is(property, "bpmn:ExtensionElements") && (!property.values || !property.values.length)) {
      return false;
    }
  });
}
ModdleCopy.$inject = [
  "eventBus",
  "bpmnFactory",
  "moddle"
];
ModdleCopy.prototype.copyElement = function(sourceElement, targetElement, propertyNames, clone2 = false) {
  var self2 = this;
  if (propertyNames && !isArray$3(propertyNames)) {
    propertyNames = [propertyNames];
  }
  propertyNames = propertyNames || getPropertyNames(sourceElement.$descriptor);
  var canCopyProperties = this._eventBus.fire("moddleCopy.canCopyProperties", {
    propertyNames,
    sourceElement,
    targetElement,
    clone: clone2
  });
  if (canCopyProperties === false) {
    return targetElement;
  }
  if (isArray$3(canCopyProperties)) {
    propertyNames = canCopyProperties;
  }
  forEach$1(propertyNames, function(propertyName) {
    var sourceProperty;
    if (has$1(sourceElement, propertyName)) {
      sourceProperty = sourceElement.get(propertyName);
    }
    var copiedProperty = self2.copyProperty(sourceProperty, targetElement, propertyName, clone2);
    if (!isDefined(copiedProperty)) {
      return;
    }
    var canSetProperty = self2._eventBus.fire("moddleCopy.canSetCopiedProperty", {
      parent: targetElement,
      property: copiedProperty,
      propertyName
    });
    if (canSetProperty === false) {
      return;
    }
    targetElement.set(propertyName, copiedProperty);
  });
  return targetElement;
};
ModdleCopy.prototype.copyProperty = function(property, parent, propertyName, clone2 = false) {
  var self2 = this;
  var copiedProperty = this._eventBus.fire("moddleCopy.canCopyProperty", {
    parent,
    property,
    propertyName,
    clone: clone2
  });
  if (copiedProperty === false) {
    return;
  }
  if (copiedProperty) {
    if (isObject(copiedProperty) && copiedProperty.$type && !copiedProperty.$parent) {
      copiedProperty.$parent = parent;
    }
    return copiedProperty;
  }
  var propertyDescriptor = this._moddle.getPropertyDescriptor(parent, propertyName);
  if (propertyDescriptor.isReference) {
    return;
  }
  if (propertyDescriptor.isId) {
    return property && this._copyId(property, parent, clone2);
  }
  if (isArray$3(property)) {
    return reduce(property, function(childProperties, childProperty) {
      copiedProperty = self2.copyProperty(childProperty, parent, propertyName, clone2);
      if (copiedProperty) {
        return childProperties.concat(copiedProperty);
      }
      return childProperties;
    }, []);
  }
  if (isObject(property) && property.$type) {
    if (this._moddle.getElementDescriptor(property).isGeneric) {
      return;
    }
    copiedProperty = self2._bpmnFactory.create(property.$type);
    copiedProperty.$parent = parent;
    copiedProperty = self2.copyElement(property, copiedProperty, null, clone2);
    return copiedProperty;
  }
  return property;
};
ModdleCopy.prototype._copyId = function(id, element, clone2 = false) {
  if (clone2) {
    return id;
  }
  if (this._moddle.ids.assigned(id)) {
    return;
  } else {
    this._moddle.ids.claim(id, element);
    return id;
  }
};
function getPropertyNames(descriptor, keepDefaultProperties) {
  return reduce(descriptor.properties, function(properties, property) {
    if (keepDefaultProperties && property.default) {
      return properties;
    }
    return properties.concat(property.name);
  }, []);
}
function is(element, type) {
  return element && isFunction(element.$instanceOf) && element.$instanceOf(type);
}
const CopyPasteModule = {
  __depends__: [
    CopyPasteModule$1
  ],
  __init__: ["bpmnCopyPaste", "moddleCopy"],
  bpmnCopyPaste: ["type", BpmnCopyPaste],
  moddleCopy: ["type", ModdleCopy]
};
var round$6 = Math.round;
function Replace(modeling, eventBus) {
  this._modeling = modeling;
  this._eventBus = eventBus;
}
Replace.$inject = ["modeling", "eventBus"];
Replace.prototype.replaceElement = function(oldElement, attrs, hints) {
  if (oldElement.waypoints) {
    return null;
  }
  var modeling = this._modeling;
  var eventBus = this._eventBus;
  eventBus.fire("replace.start", {
    element: oldElement,
    attrs,
    hints
  });
  var width = attrs.width || oldElement.width, height = attrs.height || oldElement.height, x2 = attrs.x || oldElement.x, y2 = attrs.y || oldElement.y, centerX = round$6(x2 + width / 2), centerY = round$6(y2 + height / 2);
  var newElement = modeling.replaceShape(
    oldElement,
    assign$1(
      {},
      attrs,
      {
        x: centerX,
        y: centerY,
        width,
        height
      }
    ),
    hints
  );
  eventBus.fire("replace.end", {
    element: oldElement,
    newElement,
    hints
  });
  return newElement;
};
function ReplaceSelectionBehavior(selection, eventBus) {
  eventBus.on("replace.end", 500, function(event2) {
    const {
      newElement,
      hints = {}
    } = event2;
    if (hints.select === false) {
      return;
    }
    selection.select(newElement);
  });
}
ReplaceSelectionBehavior.$inject = ["selection", "eventBus"];
const ReplaceModule$1 = {
  __init__: ["replace", "replaceSelectionBehavior"],
  replaceSelectionBehavior: ["type", ReplaceSelectionBehavior],
  replace: ["type", Replace]
};
function copyProperties(source, target, properties) {
  if (!isArray$3(properties)) {
    properties = [properties];
  }
  forEach$1(properties, function(property) {
    if (!isUndefined$2(source[property])) {
      target[property] = source[property];
    }
  });
}
var CUSTOM_PROPERTIES = [
  "cancelActivity",
  "instantiate",
  "eventGatewayType",
  "triggeredByEvent",
  "isInterrupting"
];
function shouldToggleCollapsed(element, targetElement) {
  var oldCollapsed = element && has$1(element, "collapsed") ? element.collapsed : !isExpanded(element);
  var targetCollapsed;
  if (targetElement && (has$1(targetElement, "collapsed") || has$1(targetElement, "isExpanded"))) {
    targetCollapsed = has$1(targetElement, "collapsed") ? targetElement.collapsed : !targetElement.isExpanded;
  } else {
    targetCollapsed = oldCollapsed;
  }
  if (oldCollapsed !== targetCollapsed) {
    return true;
  }
  return false;
}
function BpmnReplace(bpmnFactory, elementFactory, moddleCopy, modeling, replace, rules) {
  function replaceElement(element, targetElement, hints) {
    hints = hints || {};
    var type = targetElement.type, oldBusinessObject = element.businessObject;
    if (isSubProcess(oldBusinessObject) && type === "bpmn:SubProcess") {
      if (shouldToggleCollapsed(element, targetElement)) {
        modeling.toggleCollapse(element);
        return element;
      }
    }
    var newBusinessObject = bpmnFactory.create(type);
    var newElement = {
      type,
      businessObject: newBusinessObject
    };
    newElement.di = {};
    if (type === "bpmn:ExclusiveGateway") {
      newElement.di.isMarkerVisible = true;
    }
    copyProperties(element.di, newElement.di, [
      "fill",
      "stroke",
      "background-color",
      "border-color",
      "color"
    ]);
    var elementProps = getPropertyNames(oldBusinessObject.$descriptor), newElementProps = getPropertyNames(newBusinessObject.$descriptor, true), copyProps = intersection(elementProps, newElementProps);
    assign$1(newBusinessObject, pick(targetElement, CUSTOM_PROPERTIES));
    var properties = filter(copyProps, function(propertyName) {
      if (propertyName === "eventDefinitions") {
        return hasEventDefinition(element, targetElement.eventDefinitionType);
      }
      if (propertyName === "loopCharacteristics") {
        return !isEventSubProcess(newBusinessObject);
      }
      if (has$1(newBusinessObject, propertyName)) {
        return false;
      }
      if (propertyName === "processRef" && targetElement.isExpanded === false) {
        return false;
      }
      if (propertyName === "triggeredByEvent") {
        return false;
      }
      if (propertyName === "isForCompensation") {
        return !isEventSubProcess(newBusinessObject);
      }
      return true;
    });
    newBusinessObject = moddleCopy.copyElement(
      oldBusinessObject,
      newBusinessObject,
      properties
    );
    if (targetElement.eventDefinitionType) {
      if (!hasEventDefinition(newBusinessObject, targetElement.eventDefinitionType)) {
        newElement.eventDefinitionType = targetElement.eventDefinitionType;
        newElement.eventDefinitionAttrs = targetElement.eventDefinitionAttrs;
      }
    }
    if (is$1(oldBusinessObject, "bpmn:Activity")) {
      if (isSubProcess(oldBusinessObject)) {
        newElement.isExpanded = isExpanded(element);
      } else if (targetElement && has$1(targetElement, "isExpanded")) {
        newElement.isExpanded = targetElement.isExpanded;
        var defaultSize = elementFactory.getDefaultSize(newBusinessObject, {
          isExpanded: newElement.isExpanded
        });
        newElement.width = defaultSize.width;
        newElement.height = defaultSize.height;
        newElement.x = element.x - (newElement.width - element.width) / 2;
        newElement.y = element.y - (newElement.height - element.height) / 2;
      }
      if (isExpanded(element) && !is$1(oldBusinessObject, "bpmn:Task") && newElement.isExpanded) {
        newElement.width = element.width;
        newElement.height = element.height;
      }
    }
    if (isSubProcess(oldBusinessObject) && !isSubProcess(newBusinessObject)) {
      hints.moveChildren = false;
    }
    if (is$1(oldBusinessObject, "bpmn:Participant")) {
      if (targetElement.isExpanded === true) {
        newBusinessObject.processRef = bpmnFactory.create("bpmn:Process");
      } else {
        hints.moveChildren = false;
      }
      newElement.width = element.width;
      newElement.height = elementFactory.getDefaultSize(newElement).height;
    }
    if (!rules.allowed("shape.resize", { shape: newBusinessObject })) {
      newElement.height = elementFactory.getDefaultSize(newElement).height;
      newElement.width = elementFactory.getDefaultSize(newElement).width;
    }
    newBusinessObject.name = oldBusinessObject.name;
    if (isAny(oldBusinessObject, [
      "bpmn:ExclusiveGateway",
      "bpmn:InclusiveGateway",
      "bpmn:Activity"
    ]) && isAny(newBusinessObject, [
      "bpmn:ExclusiveGateway",
      "bpmn:InclusiveGateway",
      "bpmn:Activity"
    ])) {
      newBusinessObject.default = oldBusinessObject.default;
    }
    if (targetElement.host && !is$1(oldBusinessObject, "bpmn:BoundaryEvent") && is$1(newBusinessObject, "bpmn:BoundaryEvent")) {
      newElement.host = targetElement.host;
    }
    if (newElement.type === "bpmn:DataStoreReference" || newElement.type === "bpmn:DataObjectReference") {
      newElement.x = element.x + (element.width - newElement.width) / 2;
    }
    return replace.replaceElement(element, newElement, { ...hints, targetElement });
  }
  this.replaceElement = replaceElement;
}
BpmnReplace.$inject = [
  "bpmnFactory",
  "elementFactory",
  "moddleCopy",
  "modeling",
  "replace",
  "rules"
];
function isSubProcess(businessObject) {
  return is$1(businessObject, "bpmn:SubProcess");
}
function hasEventDefinition(element, type) {
  var businessObject = getBusinessObject(element);
  return type && businessObject.get("eventDefinitions").some(function(definition) {
    return is$1(definition, type);
  });
}
function intersection(a2, b2) {
  return a2.filter(function(item) {
    return b2.includes(item);
  });
}
const ReplaceModule = {
  __depends__: [
    CopyPasteModule,
    ReplaceModule$1,
    SelectionModule
  ],
  bpmnReplace: ["type", BpmnReplace]
};
var LOW_PRIORITY$9 = 250;
function ToolManager(eventBus, dragging) {
  this._eventBus = eventBus;
  this._dragging = dragging;
  this._tools = [];
  this._active = null;
}
ToolManager.$inject = ["eventBus", "dragging"];
ToolManager.prototype.registerTool = function(name2, events) {
  var tools = this._tools;
  if (!events) {
    throw new Error(`A tool has to be registered with it's "events"`);
  }
  tools.push(name2);
  this.bindEvents(name2, events);
};
ToolManager.prototype.isActive = function(tool) {
  return tool && this._active === tool;
};
ToolManager.prototype.length = function(tool) {
  return this._tools.length;
};
ToolManager.prototype.setActive = function(tool) {
  var eventBus = this._eventBus;
  if (this._active !== tool) {
    this._active = tool;
    eventBus.fire("tool-manager.update", { tool });
  }
};
ToolManager.prototype.bindEvents = function(name2, events) {
  var eventBus = this._eventBus, dragging = this._dragging;
  var eventsToRegister = [];
  eventBus.on(events.tool + ".init", function(event2) {
    var context = event2.context;
    if (!context.reactivate && this.isActive(name2)) {
      this.setActive(null);
      dragging.cancel();
      return;
    }
    this.setActive(name2);
  }, this);
  forEach$1(events, function(event2) {
    eventsToRegister.push(event2 + ".ended");
    eventsToRegister.push(event2 + ".canceled");
  });
  eventBus.on(eventsToRegister, LOW_PRIORITY$9, function(event2) {
    if (!this._active) {
      return;
    }
    if (isPaletteClick(event2)) {
      return;
    }
    this.setActive(null);
  }, this);
};
function isPaletteClick(event2) {
  var target = event2.originalEvent && event2.originalEvent.target;
  return target && closest(target, '.group[data-group="tools"]');
}
const ToolManagerModule = {
  __depends__: [
    DraggingModule
  ],
  __init__: ["toolManager"],
  toolManager: ["type", ToolManager]
};
function getDirection(axis, delta2) {
  if (axis === "x") {
    if (delta2 > 0) {
      return "e";
    }
    if (delta2 < 0) {
      return "w";
    }
  }
  if (axis === "y") {
    if (delta2 > 0) {
      return "s";
    }
    if (delta2 < 0) {
      return "n";
    }
  }
  return null;
}
function getWaypointsUpdatingConnections(movingShapes, resizingShapes) {
  var waypointsUpdatingConnections = [];
  forEach$1(movingShapes.concat(resizingShapes), function(shape) {
    var incoming = shape.incoming, outgoing = shape.outgoing;
    forEach$1(incoming.concat(outgoing), function(connection) {
      var source = connection.source, target = connection.target;
      if (includes$5(movingShapes, source) || includes$5(movingShapes, target) || includes$5(resizingShapes, source) || includes$5(resizingShapes, target)) {
        if (!includes$5(waypointsUpdatingConnections, connection)) {
          waypointsUpdatingConnections.push(connection);
        }
      }
    });
  });
  return waypointsUpdatingConnections;
}
function includes$5(array, item) {
  return array.indexOf(item) !== -1;
}
function resizeBounds(bounds, direction, delta2) {
  var x2 = bounds.x, y2 = bounds.y, width = bounds.width, height = bounds.height, dx = delta2.x, dy = delta2.y;
  switch (direction) {
    case "n":
      return {
        x: x2,
        y: y2 + dy,
        width,
        height: height - dy
      };
    case "s":
      return {
        x: x2,
        y: y2,
        width,
        height: height + dy
      };
    case "w":
      return {
        x: x2 + dx,
        y: y2,
        width: width - dx,
        height
      };
    case "e":
      return {
        x: x2,
        y: y2,
        width: width + dx,
        height
      };
    default:
      throw new Error("unknown direction: " + direction);
  }
}
var abs$1 = Math.abs, round$5 = Math.round;
var AXIS_TO_DIMENSION = {
  x: "width",
  y: "height"
};
var CURSOR_CROSSHAIR = "crosshair";
var DIRECTION_TO_TRBL = {
  n: "top",
  w: "left",
  s: "bottom",
  e: "right"
};
var HIGH_PRIORITY$9 = 1500;
var DIRECTION_TO_OPPOSITE = {
  n: "s",
  w: "e",
  s: "n",
  e: "w"
};
var PADDING = 20;
function SpaceTool(canvas, dragging, eventBus, modeling, rules, toolManager, mouse) {
  this._canvas = canvas;
  this._dragging = dragging;
  this._eventBus = eventBus;
  this._modeling = modeling;
  this._rules = rules;
  this._toolManager = toolManager;
  this._mouse = mouse;
  var self2 = this;
  toolManager.registerTool("space", {
    tool: "spaceTool.selection",
    dragging: "spaceTool"
  });
  eventBus.on("spaceTool.selection.end", function(event2) {
    eventBus.once("spaceTool.selection.ended", function() {
      self2.activateMakeSpace(event2.originalEvent);
    });
  });
  eventBus.on("spaceTool.move", HIGH_PRIORITY$9, function(event2) {
    var context = event2.context, initialized = context.initialized;
    if (!initialized) {
      initialized = context.initialized = self2.init(event2, context);
    }
    if (initialized) {
      ensureConstraints(event2);
    }
  });
  eventBus.on("spaceTool.end", function(event2) {
    var context = event2.context, axis = context.axis, direction = context.direction, movingShapes = context.movingShapes, resizingShapes = context.resizingShapes, start = context.start;
    if (!context.initialized) {
      return;
    }
    ensureConstraints(event2);
    var delta2 = {
      x: 0,
      y: 0
    };
    delta2[axis] = round$5(event2["d" + axis]);
    self2.makeSpace(movingShapes, resizingShapes, delta2, direction, start);
    eventBus.once("spaceTool.ended", function(event3) {
      self2.activateSelection(event3.originalEvent, true, true);
    });
  });
}
SpaceTool.$inject = [
  "canvas",
  "dragging",
  "eventBus",
  "modeling",
  "rules",
  "toolManager",
  "mouse"
];
SpaceTool.prototype.activateSelection = function(event2, autoActivate, reactivate) {
  this._dragging.init(event2, "spaceTool.selection", {
    autoActivate,
    cursor: CURSOR_CROSSHAIR,
    data: {
      context: {
        reactivate
      }
    },
    trapClick: false
  });
};
SpaceTool.prototype.activateMakeSpace = function(event2) {
  this._dragging.init(event2, "spaceTool", {
    autoActivate: true,
    cursor: CURSOR_CROSSHAIR,
    data: {
      context: {}
    }
  });
};
SpaceTool.prototype.makeSpace = function(movingShapes, resizingShapes, delta2, direction, start) {
  return this._modeling.createSpace(movingShapes, resizingShapes, delta2, direction, start);
};
SpaceTool.prototype.init = function(event2, context) {
  var axis = abs$1(event2.dx) > abs$1(event2.dy) ? "x" : "y", delta2 = event2["d" + axis], start = event2[axis] - delta2;
  if (abs$1(delta2) < 5) {
    return false;
  }
  if (delta2 < 0) {
    delta2 *= -1;
  }
  if (hasPrimaryModifier(event2)) {
    delta2 *= -1;
  }
  var direction = getDirection(axis, delta2);
  var root = this._canvas.getRootElement();
  if (!hasSecondaryModifier(event2) && event2.hover) {
    root = event2.hover;
  }
  var children = [
    ...selfAndAllChildren(root, true),
    ...root.attachers || []
  ];
  var elements = this.calculateAdjustments(children, axis, delta2, start);
  var minDimensions = this._eventBus.fire("spaceTool.getMinDimensions", {
    axis,
    direction,
    shapes: elements.resizingShapes,
    start
  });
  var spaceToolConstraints = getSpaceToolConstraints(elements, axis, direction, start, minDimensions);
  assign$1(
    context,
    elements,
    {
      axis,
      direction,
      spaceToolConstraints,
      start
    }
  );
  set("resize-" + (axis === "x" ? "ew" : "ns"));
  return true;
};
SpaceTool.prototype.calculateAdjustments = function(elements, axis, delta2, start) {
  var rules = this._rules;
  var movingShapes = [], resizingShapes = [];
  var attachers = [], connections = [];
  function moveShape(shape) {
    if (!movingShapes.includes(shape)) {
      movingShapes.push(shape);
    }
    var label = shape.label;
    if (label && !movingShapes.includes(label)) {
      movingShapes.push(label);
    }
  }
  function resizeShape(shape) {
    if (!resizingShapes.includes(shape)) {
      resizingShapes.push(shape);
    }
  }
  forEach$1(elements, function(element) {
    if (!element.parent || isLabel(element)) {
      return;
    }
    if (isConnection(element)) {
      connections.push(element);
      return;
    }
    var shapeStart = element[axis], shapeEnd = shapeStart + element[AXIS_TO_DIMENSION[axis]];
    if (isAttacher$1(element) && (delta2 > 0 && getMid(element)[axis] > start || delta2 < 0 && getMid(element)[axis] < start)) {
      attachers.push(element);
      return;
    }
    if (delta2 > 0 && shapeStart > start || delta2 < 0 && shapeEnd < start) {
      moveShape(element);
      return;
    }
    if (shapeStart < start && shapeEnd > start && rules.allowed("shape.resize", { shape: element })) {
      resizeShape(element);
      return;
    }
  });
  forEach$1(movingShapes, function(shape) {
    var attachers2 = shape.attachers;
    if (attachers2) {
      forEach$1(attachers2, function(attacher) {
        moveShape(attacher);
      });
    }
  });
  var allShapes = movingShapes.concat(resizingShapes);
  forEach$1(attachers, function(attacher) {
    var host = attacher.host;
    if (includes$4(allShapes, host)) {
      moveShape(attacher);
    }
  });
  allShapes = movingShapes.concat(resizingShapes);
  forEach$1(connections, function(connection) {
    var source = connection.source, target = connection.target, label = connection.label;
    if (includes$4(allShapes, source) && includes$4(allShapes, target) && label) {
      moveShape(label);
    }
  });
  return {
    movingShapes,
    resizingShapes
  };
};
SpaceTool.prototype.toggle = function() {
  if (this.isActive()) {
    return this._dragging.cancel();
  }
  var mouseEvent = this._mouse.getLastMoveEvent();
  this.activateSelection(mouseEvent, !!mouseEvent);
};
SpaceTool.prototype.isActive = function() {
  var context = this._dragging.context();
  if (context) {
    return /^spaceTool/.test(context.prefix);
  }
  return false;
};
function addPadding(trbl) {
  return {
    top: trbl.top - PADDING,
    right: trbl.right + PADDING,
    bottom: trbl.bottom + PADDING,
    left: trbl.left - PADDING
  };
}
function ensureConstraints(event2) {
  var context = event2.context, spaceToolConstraints = context.spaceToolConstraints;
  if (!spaceToolConstraints) {
    return;
  }
  var x2, y2;
  if (isNumber(spaceToolConstraints.left)) {
    x2 = Math.max(event2.x, spaceToolConstraints.left);
    event2.dx = event2.dx + x2 - event2.x;
    event2.x = x2;
  }
  if (isNumber(spaceToolConstraints.right)) {
    x2 = Math.min(event2.x, spaceToolConstraints.right);
    event2.dx = event2.dx + x2 - event2.x;
    event2.x = x2;
  }
  if (isNumber(spaceToolConstraints.top)) {
    y2 = Math.max(event2.y, spaceToolConstraints.top);
    event2.dy = event2.dy + y2 - event2.y;
    event2.y = y2;
  }
  if (isNumber(spaceToolConstraints.bottom)) {
    y2 = Math.min(event2.y, spaceToolConstraints.bottom);
    event2.dy = event2.dy + y2 - event2.y;
    event2.y = y2;
  }
}
function getSpaceToolConstraints(elements, axis, direction, start, minDimensions) {
  var movingShapes = elements.movingShapes, resizingShapes = elements.resizingShapes;
  if (!resizingShapes.length) {
    return;
  }
  var spaceToolConstraints = {}, min2, max2;
  forEach$1(resizingShapes, function(resizingShape) {
    var attachers = resizingShape.attachers, children = resizingShape.children;
    var resizingShapeBBox = asTRBL(resizingShape);
    var nonMovingResizingChildren = filter(children, function(child) {
      return !isConnection(child) && !isLabel(child) && !includes$4(movingShapes, child) && !includes$4(resizingShapes, child);
    });
    var movingChildren = filter(children, function(child) {
      return !isConnection(child) && !isLabel(child) && includes$4(movingShapes, child);
    });
    var minOrMax, nonMovingResizingChildrenBBox, movingChildrenBBox, movingAttachers = [], nonMovingAttachers = [], movingAttachersBBox, movingAttachersConstraint, nonMovingAttachersBBox, nonMovingAttachersConstraint;
    if (nonMovingResizingChildren.length) {
      nonMovingResizingChildrenBBox = addPadding(asTRBL(getBBox(nonMovingResizingChildren)));
      minOrMax = start - resizingShapeBBox[DIRECTION_TO_TRBL[direction]] + nonMovingResizingChildrenBBox[DIRECTION_TO_TRBL[direction]];
      if (direction === "n") {
        spaceToolConstraints.bottom = max2 = isNumber(max2) ? Math.min(max2, minOrMax) : minOrMax;
      } else if (direction === "w") {
        spaceToolConstraints.right = max2 = isNumber(max2) ? Math.min(max2, minOrMax) : minOrMax;
      } else if (direction === "s") {
        spaceToolConstraints.top = min2 = isNumber(min2) ? Math.max(min2, minOrMax) : minOrMax;
      } else if (direction === "e") {
        spaceToolConstraints.left = min2 = isNumber(min2) ? Math.max(min2, minOrMax) : minOrMax;
      }
    }
    if (movingChildren.length) {
      movingChildrenBBox = addPadding(asTRBL(getBBox(movingChildren)));
      minOrMax = start - movingChildrenBBox[DIRECTION_TO_TRBL[DIRECTION_TO_OPPOSITE[direction]]] + resizingShapeBBox[DIRECTION_TO_TRBL[DIRECTION_TO_OPPOSITE[direction]]];
      if (direction === "n") {
        spaceToolConstraints.bottom = max2 = isNumber(max2) ? Math.min(max2, minOrMax) : minOrMax;
      } else if (direction === "w") {
        spaceToolConstraints.right = max2 = isNumber(max2) ? Math.min(max2, minOrMax) : minOrMax;
      } else if (direction === "s") {
        spaceToolConstraints.top = min2 = isNumber(min2) ? Math.max(min2, minOrMax) : minOrMax;
      } else if (direction === "e") {
        spaceToolConstraints.left = min2 = isNumber(min2) ? Math.max(min2, minOrMax) : minOrMax;
      }
    }
    if (attachers && attachers.length) {
      attachers.forEach(function(attacher) {
        if (includes$4(movingShapes, attacher)) {
          movingAttachers.push(attacher);
        } else {
          nonMovingAttachers.push(attacher);
        }
      });
      if (movingAttachers.length) {
        movingAttachersBBox = asTRBL(getBBox(movingAttachers.map(getMid)));
        movingAttachersConstraint = resizingShapeBBox[DIRECTION_TO_TRBL[DIRECTION_TO_OPPOSITE[direction]]] - (movingAttachersBBox[DIRECTION_TO_TRBL[DIRECTION_TO_OPPOSITE[direction]]] - start);
      }
      if (nonMovingAttachers.length) {
        nonMovingAttachersBBox = asTRBL(getBBox(nonMovingAttachers.map(getMid)));
        nonMovingAttachersConstraint = nonMovingAttachersBBox[DIRECTION_TO_TRBL[direction]] - (resizingShapeBBox[DIRECTION_TO_TRBL[direction]] - start);
      }
      if (direction === "n") {
        minOrMax = Math.min(movingAttachersConstraint || Infinity, nonMovingAttachersConstraint || Infinity);
        spaceToolConstraints.bottom = max2 = isNumber(max2) ? Math.min(max2, minOrMax) : minOrMax;
      } else if (direction === "w") {
        minOrMax = Math.min(movingAttachersConstraint || Infinity, nonMovingAttachersConstraint || Infinity);
        spaceToolConstraints.right = max2 = isNumber(max2) ? Math.min(max2, minOrMax) : minOrMax;
      } else if (direction === "s") {
        minOrMax = Math.max(movingAttachersConstraint || -Infinity, nonMovingAttachersConstraint || -Infinity);
        spaceToolConstraints.top = min2 = isNumber(min2) ? Math.max(min2, minOrMax) : minOrMax;
      } else if (direction === "e") {
        minOrMax = Math.max(movingAttachersConstraint || -Infinity, nonMovingAttachersConstraint || -Infinity);
        spaceToolConstraints.left = min2 = isNumber(min2) ? Math.max(min2, minOrMax) : minOrMax;
      }
    }
    var resizingShapeMinDimensions = minDimensions && minDimensions[resizingShape.id];
    if (resizingShapeMinDimensions) {
      if (direction === "n") {
        minOrMax = start + resizingShape[AXIS_TO_DIMENSION[axis]] - resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];
        spaceToolConstraints.bottom = max2 = isNumber(max2) ? Math.min(max2, minOrMax) : minOrMax;
      } else if (direction === "w") {
        minOrMax = start + resizingShape[AXIS_TO_DIMENSION[axis]] - resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];
        spaceToolConstraints.right = max2 = isNumber(max2) ? Math.min(max2, minOrMax) : minOrMax;
      } else if (direction === "s") {
        minOrMax = start - resizingShape[AXIS_TO_DIMENSION[axis]] + resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];
        spaceToolConstraints.top = min2 = isNumber(min2) ? Math.max(min2, minOrMax) : minOrMax;
      } else if (direction === "e") {
        minOrMax = start - resizingShape[AXIS_TO_DIMENSION[axis]] + resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];
        spaceToolConstraints.left = min2 = isNumber(min2) ? Math.max(min2, minOrMax) : minOrMax;
      }
    }
  });
  return spaceToolConstraints;
}
function includes$4(array, item) {
  return array.indexOf(item) !== -1;
}
function isAttacher$1(element) {
  return !!element.host;
}
var MARKER_DRAGGING$1 = "djs-dragging", MARKER_RESIZING$1 = "djs-resizing";
var LOW_PRIORITY$8 = 250;
var max$1 = Math.max;
function SpaceToolPreview(eventBus, elementRegistry, canvas, styles, previewSupport) {
  function addPreviewGfx(collection, dragGroup) {
    forEach$1(collection, function(element) {
      previewSupport.addDragger(element, dragGroup);
      canvas.addMarker(element, MARKER_DRAGGING$1);
    });
  }
  eventBus.on("spaceTool.selection.start", function(event2) {
    var space = canvas.getLayer("space"), context = event2.context;
    var orientation = {
      x: "M 0,-10000 L 0,10000",
      y: "M -10000,0 L 10000,0"
    };
    var crosshairGroup = create$1("g");
    attr(crosshairGroup, styles.cls("djs-crosshair-group", ["no-events"]));
    append(space, crosshairGroup);
    var pathX = create$1("path");
    attr(pathX, "d", orientation.x);
    classes(pathX).add("djs-crosshair");
    append(crosshairGroup, pathX);
    var pathY = create$1("path");
    attr(pathY, "d", orientation.y);
    classes(pathY).add("djs-crosshair");
    append(crosshairGroup, pathY);
    context.crosshairGroup = crosshairGroup;
  });
  eventBus.on("spaceTool.selection.move", function(event2) {
    var crosshairGroup = event2.context.crosshairGroup;
    translate$2(crosshairGroup, event2.x, event2.y);
  });
  eventBus.on("spaceTool.selection.cleanup", function(event2) {
    var context = event2.context, crosshairGroup = context.crosshairGroup;
    if (crosshairGroup) {
      remove$1(crosshairGroup);
    }
  });
  eventBus.on("spaceTool.move", LOW_PRIORITY$8, function(event2) {
    var context = event2.context, line = context.line, axis = context.axis, movingShapes = context.movingShapes, resizingShapes = context.resizingShapes;
    if (!context.initialized) {
      return;
    }
    if (!context.dragGroup) {
      var spaceLayer = canvas.getLayer("space");
      line = create$1("path");
      attr(line, "d", "M0,0 L0,0");
      classes(line).add("djs-crosshair");
      append(spaceLayer, line);
      context.line = line;
      var dragGroup = create$1("g");
      attr(dragGroup, styles.cls("djs-drag-group", ["no-events"]));
      append(canvas.getActiveLayer(), dragGroup);
      addPreviewGfx(movingShapes, dragGroup);
      var movingConnections = context.movingConnections = elementRegistry.filter(function(element) {
        var sourceIsMoving = false;
        forEach$1(movingShapes, function(shape) {
          forEach$1(shape.outgoing, function(connection) {
            if (element === connection) {
              sourceIsMoving = true;
            }
          });
        });
        var targetIsMoving = false;
        forEach$1(movingShapes, function(shape) {
          forEach$1(shape.incoming, function(connection) {
            if (element === connection) {
              targetIsMoving = true;
            }
          });
        });
        var sourceIsResizing = false;
        forEach$1(resizingShapes, function(shape) {
          forEach$1(shape.outgoing, function(connection) {
            if (element === connection) {
              sourceIsResizing = true;
            }
          });
        });
        var targetIsResizing = false;
        forEach$1(resizingShapes, function(shape) {
          forEach$1(shape.incoming, function(connection) {
            if (element === connection) {
              targetIsResizing = true;
            }
          });
        });
        return isConnection(element) && (sourceIsMoving || sourceIsResizing) && (targetIsMoving || targetIsResizing);
      });
      addPreviewGfx(movingConnections, dragGroup);
      context.dragGroup = dragGroup;
    }
    if (!context.frameGroup) {
      var frameGroup = create$1("g");
      attr(frameGroup, styles.cls("djs-frame-group", ["no-events"]));
      append(canvas.getActiveLayer(), frameGroup);
      var frames = [];
      forEach$1(resizingShapes, function(shape) {
        var frame = previewSupport.addFrame(shape, frameGroup);
        var initialBounds = frame.getBBox();
        frames.push({
          element: frame,
          initialBounds
        });
        canvas.addMarker(shape, MARKER_RESIZING$1);
      });
      context.frameGroup = frameGroup;
      context.frames = frames;
    }
    var orientation = {
      x: "M" + event2.x + ", -10000 L" + event2.x + ", 10000",
      y: "M -10000, " + event2.y + " L 10000, " + event2.y
    };
    attr(line, { d: orientation[axis] });
    var opposite = { x: "y", y: "x" };
    var delta2 = { x: event2.dx, y: event2.dy };
    delta2[opposite[context.axis]] = 0;
    translate$2(context.dragGroup, delta2.x, delta2.y);
    forEach$1(context.frames, function(frame) {
      var element = frame.element, initialBounds = frame.initialBounds, width, height;
      if (context.direction === "e") {
        attr(element, {
          width: max$1(initialBounds.width + delta2.x, 5)
        });
      } else {
        width = max$1(initialBounds.width - delta2.x, 5);
        attr(element, {
          width,
          x: initialBounds.x + initialBounds.width - width
        });
      }
      if (context.direction === "s") {
        attr(element, {
          height: max$1(initialBounds.height + delta2.y, 5)
        });
      } else {
        height = max$1(initialBounds.height - delta2.y, 5);
        attr(element, {
          height,
          y: initialBounds.y + initialBounds.height - height
        });
      }
    });
  });
  eventBus.on("spaceTool.cleanup", function(event2) {
    var context = event2.context, movingShapes = context.movingShapes, movingConnections = context.movingConnections, resizingShapes = context.resizingShapes, line = context.line, dragGroup = context.dragGroup, frameGroup = context.frameGroup;
    forEach$1(movingShapes, function(shape) {
      canvas.removeMarker(shape, MARKER_DRAGGING$1);
    });
    forEach$1(movingConnections, function(connection) {
      canvas.removeMarker(connection, MARKER_DRAGGING$1);
    });
    if (dragGroup) {
      remove$1(line);
      remove$1(dragGroup);
    }
    forEach$1(resizingShapes, function(shape) {
      canvas.removeMarker(shape, MARKER_RESIZING$1);
    });
    if (frameGroup) {
      remove$1(frameGroup);
    }
  });
}
SpaceToolPreview.$inject = [
  "eventBus",
  "elementRegistry",
  "canvas",
  "styles",
  "previewSupport"
];
const SpaceToolModule$1 = {
  __init__: ["spaceToolPreview"],
  __depends__: [
    DraggingModule,
    RulesModule$1,
    ToolManagerModule,
    PreviewSupportModule,
    MouseModule
  ],
  spaceTool: ["type", SpaceTool],
  spaceToolPreview: ["type", SpaceToolPreview]
};
function BpmnSpaceTool(injector) {
  injector.invoke(SpaceTool, this);
}
BpmnSpaceTool.$inject = [
  "injector"
];
e$3(BpmnSpaceTool, SpaceTool);
BpmnSpaceTool.prototype.calculateAdjustments = function(elements, axis, delta2, start) {
  var adjustments = SpaceTool.prototype.calculateAdjustments.call(this, elements, axis, delta2, start);
  adjustments.resizingShapes = adjustments.resizingShapes.filter(function(shape) {
    if (is$1(shape, "bpmn:TextAnnotation")) {
      return false;
    }
    if (isCollapsedPool$1(shape)) {
      if (axis === "y" && isHorizontal$3(shape) || axis === "x" && !isHorizontal$3(shape)) {
        return false;
      }
    }
    return true;
  });
  return adjustments;
};
function isCollapsedPool$1(shape) {
  return is$1(shape, "bpmn:Participant") && !getBusinessObject(shape).processRef;
}
const SpaceToolModule = {
  __depends__: [SpaceToolModule$1],
  spaceTool: ["type", BpmnSpaceTool]
};
function CommandStack(eventBus, injector) {
  this._handlerMap = {};
  this._stack = [];
  this._stackIdx = -1;
  this._currentExecution = {
    actions: [],
    dirty: [],
    trigger: null
  };
  this._injector = injector;
  this._eventBus = eventBus;
  this._uid = 1;
  eventBus.on([
    "diagram.destroy",
    "diagram.clear"
  ], function() {
    this.clear(false);
  }, this);
}
CommandStack.$inject = ["eventBus", "injector"];
CommandStack.prototype.execute = function(command, context) {
  if (!command) {
    throw new Error("command required");
  }
  this._currentExecution.trigger = "execute";
  const action = { command, context };
  this._pushAction(action);
  this._internalExecute(action);
  this._popAction();
};
CommandStack.prototype.canExecute = function(command, context) {
  const action = { command, context };
  const handler = this._getHandler(command);
  let result = this._fire(command, "canExecute", action);
  if (result === void 0) {
    if (!handler) {
      return false;
    }
    if (handler.canExecute) {
      result = handler.canExecute(context);
    }
  }
  return result;
};
CommandStack.prototype.clear = function(emit) {
  this._stack.length = 0;
  this._stackIdx = -1;
  if (emit !== false) {
    this._fire("changed", { trigger: "clear" });
  }
};
CommandStack.prototype.undo = function() {
  let action = this._getUndoAction(), next;
  if (action) {
    this._currentExecution.trigger = "undo";
    this._pushAction(action);
    while (action) {
      this._internalUndo(action);
      next = this._getUndoAction();
      if (!next || next.id !== action.id) {
        break;
      }
      action = next;
    }
    this._popAction();
  }
};
CommandStack.prototype.redo = function() {
  let action = this._getRedoAction(), next;
  if (action) {
    this._currentExecution.trigger = "redo";
    this._pushAction(action);
    while (action) {
      this._internalExecute(action, true);
      next = this._getRedoAction();
      if (!next || next.id !== action.id) {
        break;
      }
      action = next;
    }
    this._popAction();
  }
};
CommandStack.prototype.register = function(command, handler) {
  this._setHandler(command, handler);
};
CommandStack.prototype.registerHandler = function(command, handlerCls) {
  if (!command || !handlerCls) {
    throw new Error("command and handlerCls must be defined");
  }
  const handler = this._injector.instantiate(handlerCls);
  this.register(command, handler);
};
CommandStack.prototype.canUndo = function() {
  return !!this._getUndoAction();
};
CommandStack.prototype.canRedo = function() {
  return !!this._getRedoAction();
};
CommandStack.prototype._getRedoAction = function() {
  return this._stack[this._stackIdx + 1];
};
CommandStack.prototype._getUndoAction = function() {
  return this._stack[this._stackIdx];
};
CommandStack.prototype._internalUndo = function(action) {
  const command = action.command, context = action.context;
  const handler = this._getHandler(command);
  this._atomicDo(() => {
    this._fire(command, "revert", action);
    if (handler.revert) {
      this._markDirty(handler.revert(context));
    }
    this._revertedAction(action);
    this._fire(command, "reverted", action);
  });
};
CommandStack.prototype._fire = function(command, qualifier, event2) {
  if (arguments.length < 3) {
    event2 = qualifier;
    qualifier = null;
  }
  const names = qualifier ? [command + "." + qualifier, qualifier] : [command];
  let result;
  event2 = this._eventBus.createEvent(event2);
  for (const name2 of names) {
    result = this._eventBus.fire("commandStack." + name2, event2);
    if (event2.cancelBubble) {
      break;
    }
  }
  return result;
};
CommandStack.prototype._createId = function() {
  return this._uid++;
};
CommandStack.prototype._atomicDo = function(fn) {
  const execution = this._currentExecution;
  execution.atomic = true;
  try {
    fn();
  } finally {
    execution.atomic = false;
  }
};
CommandStack.prototype._internalExecute = function(action, redo) {
  const command = action.command, context = action.context;
  const handler = this._getHandler(command);
  if (!handler) {
    throw new Error("no command handler registered for <" + command + ">");
  }
  this._pushAction(action);
  if (!redo) {
    this._fire(command, "preExecute", action);
    if (handler.preExecute) {
      handler.preExecute(context);
    }
    this._fire(command, "preExecuted", action);
  }
  this._atomicDo(() => {
    this._fire(command, "execute", action);
    if (handler.execute) {
      this._markDirty(handler.execute(context));
    }
    this._executedAction(action, redo);
    this._fire(command, "executed", action);
  });
  if (!redo) {
    this._fire(command, "postExecute", action);
    if (handler.postExecute) {
      handler.postExecute(context);
    }
    this._fire(command, "postExecuted", action);
  }
  this._popAction();
};
CommandStack.prototype._pushAction = function(action) {
  const execution = this._currentExecution, actions = execution.actions;
  const baseAction = actions[0];
  if (execution.atomic) {
    throw new Error("illegal invocation in <execute> or <revert> phase (action: " + action.command + ")");
  }
  if (!action.id) {
    action.id = baseAction && baseAction.id || this._createId();
  }
  actions.push(action);
};
CommandStack.prototype._popAction = function() {
  const execution = this._currentExecution, trigger = execution.trigger, actions = execution.actions, dirty = execution.dirty;
  actions.pop();
  if (!actions.length) {
    this._eventBus.fire("elements.changed", { elements: uniqueBy("id", dirty.reverse()) });
    dirty.length = 0;
    this._fire("changed", { trigger });
    execution.trigger = null;
  }
};
CommandStack.prototype._markDirty = function(elements) {
  const execution = this._currentExecution;
  if (!elements) {
    return;
  }
  elements = isArray$3(elements) ? elements : [elements];
  execution.dirty = execution.dirty.concat(elements);
};
CommandStack.prototype._executedAction = function(action, redo) {
  const stackIdx = ++this._stackIdx;
  if (!redo) {
    this._stack.splice(stackIdx, this._stack.length, action);
  }
};
CommandStack.prototype._revertedAction = function(action) {
  this._stackIdx--;
};
CommandStack.prototype._getHandler = function(command) {
  return this._handlerMap[command];
};
CommandStack.prototype._setHandler = function(command, handler) {
  if (!command || !handler) {
    throw new Error("command and handler required");
  }
  if (this._handlerMap[command]) {
    throw new Error("overriding handler for command <" + command + ">");
  }
  this._handlerMap[command] = handler;
};
const CommandModule = {
  commandStack: ["type", CommandStack]
};
function saveClear(collection, removeFn) {
  if (typeof removeFn !== "function") {
    throw new Error("removeFn iterator must be a function");
  }
  if (!collection) {
    return;
  }
  var e2;
  while (e2 = collection[0]) {
    removeFn(e2);
  }
  return collection;
}
var LOW_PRIORITY$7 = 250, HIGH_PRIORITY$8 = 1400;
function LabelSupport(injector, eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  var movePreview = injector.get("movePreview", false);
  eventBus.on("shape.move.start", HIGH_PRIORITY$8, function(e2) {
    var context = e2.context, shapes = context.shapes, validatedShapes = context.validatedShapes;
    context.shapes = removeLabels(shapes);
    context.validatedShapes = removeLabels(validatedShapes);
  });
  movePreview && eventBus.on("shape.move.start", LOW_PRIORITY$7, function(e2) {
    var context = e2.context, shapes = context.shapes;
    var labels = [];
    forEach$1(shapes, function(element) {
      forEach$1(element.labels, function(label) {
        if (!label.hidden && context.shapes.indexOf(label) === -1) {
          labels.push(label);
        }
        if (element.labelTarget) {
          labels.push(element);
        }
      });
    });
    forEach$1(labels, function(label) {
      movePreview.makeDraggable(context, label, true);
    });
  });
  this.preExecuted("elements.move", HIGH_PRIORITY$8, function(e2) {
    var context = e2.context, closure = context.closure, enclosedElements = closure.enclosedElements;
    var enclosedLabels = [];
    forEach$1(enclosedElements, function(element) {
      forEach$1(element.labels, function(label) {
        if (!enclosedElements[label.id]) {
          enclosedLabels.push(label);
        }
      });
    });
    closure.addAll(enclosedLabels);
  });
  this.preExecute([
    "connection.delete",
    "shape.delete"
  ], function(e2) {
    var context = e2.context, element = context.connection || context.shape;
    saveClear(element.labels, function(label) {
      modeling.removeShape(label, { nested: true });
    });
  });
  this.execute("shape.delete", function(e2) {
    var context = e2.context, shape = context.shape, labelTarget = shape.labelTarget;
    if (labelTarget) {
      context.labelTargetIndex = indexOf(labelTarget.labels, shape);
      context.labelTarget = labelTarget;
      shape.labelTarget = null;
    }
  });
  this.revert("shape.delete", function(e2) {
    var context = e2.context, shape = context.shape, labelTarget = context.labelTarget, labelTargetIndex = context.labelTargetIndex;
    if (labelTarget) {
      add(labelTarget.labels, shape, labelTargetIndex);
      shape.labelTarget = labelTarget;
    }
  });
}
e$3(LabelSupport, CommandInterceptor);
LabelSupport.$inject = [
  "injector",
  "eventBus",
  "modeling"
];
function removeLabels(elements) {
  return filter(elements, function(element) {
    return elements.indexOf(element.labelTarget) === -1;
  });
}
const LabelSupportModule = {
  __init__: ["labelSupport"],
  labelSupport: ["type", LabelSupport]
};
var LOW_PRIORITY$6 = 251, HIGH_PRIORITY$7 = 1401;
var MARKER_ATTACH$1 = "attach-ok";
function AttachSupport(injector, eventBus, canvas, rules, modeling) {
  CommandInterceptor.call(this, eventBus);
  var movePreview = injector.get("movePreview", false);
  eventBus.on("shape.move.start", HIGH_PRIORITY$7, function(e2) {
    var context = e2.context, shapes = context.shapes, validatedShapes = context.validatedShapes;
    context.shapes = addAttached(shapes);
    context.validatedShapes = removeAttached(validatedShapes);
  });
  movePreview && eventBus.on("shape.move.start", LOW_PRIORITY$6, function(e2) {
    var context = e2.context, shapes = context.shapes, attachers = getAttachers(shapes);
    forEach$1(attachers, function(attacher) {
      movePreview.makeDraggable(context, attacher, true);
      forEach$1(attacher.labels, function(label) {
        movePreview.makeDraggable(context, label, true);
      });
    });
  });
  movePreview && eventBus.on("shape.move.start", function(event2) {
    var context = event2.context, shapes = context.shapes;
    if (shapes.length !== 1) {
      return;
    }
    var shape = shapes[0];
    var host = shape.host;
    if (host) {
      canvas.addMarker(host, MARKER_ATTACH$1);
      eventBus.once([
        "shape.move.out",
        "shape.move.cleanup"
      ], function() {
        canvas.removeMarker(host, MARKER_ATTACH$1);
      });
    }
  });
  this.preExecuted("elements.move", HIGH_PRIORITY$7, function(e2) {
    var context = e2.context, closure = context.closure, shapes = context.shapes, attachers = getAttachers(shapes);
    forEach$1(attachers, function(attacher) {
      closure.add(attacher, closure.topLevel[attacher.host.id]);
    });
  });
  this.postExecuted("elements.move", function(e2) {
    var context = e2.context, shapes = context.shapes, newHost = context.newHost, attachers;
    if (newHost && shapes.length !== 1) {
      return;
    }
    if (newHost) {
      attachers = shapes;
    } else {
      attachers = filter(shapes, function(shape) {
        var host = shape.host;
        return isAttacher(shape) && !includes$3(shapes, host);
      });
    }
    forEach$1(attachers, function(attacher) {
      modeling.updateAttachment(attacher, newHost);
    });
  });
  this.postExecuted("elements.move", function(e2) {
    var shapes = e2.context.shapes;
    forEach$1(shapes, function(shape) {
      forEach$1(shape.attachers, function(attacher) {
        forEach$1(attacher.outgoing.slice(), function(connection) {
          var allowed = rules.allowed("connection.reconnect", {
            connection,
            source: connection.source,
            target: connection.target
          });
          if (!allowed) {
            modeling.removeConnection(connection);
          }
        });
        forEach$1(attacher.incoming.slice(), function(connection) {
          var allowed = rules.allowed("connection.reconnect", {
            connection,
            source: connection.source,
            target: connection.target
          });
          if (!allowed) {
            modeling.removeConnection(connection);
          }
        });
      });
    });
  });
  this.postExecute("shape.create", function(e2) {
    var context = e2.context, shape = context.shape, host = context.host;
    if (host) {
      modeling.updateAttachment(shape, host);
    }
  });
  this.postExecute("shape.replace", function(e2) {
    var context = e2.context, oldShape = context.oldShape, newShape = context.newShape;
    saveClear(oldShape.attachers, function(attacher) {
      var allowed = rules.allowed("elements.move", {
        target: newShape,
        shapes: [attacher]
      });
      if (allowed === "attach") {
        modeling.updateAttachment(attacher, newShape);
      } else {
        modeling.removeShape(attacher);
      }
    });
    if (newShape.attachers.length) {
      forEach$1(newShape.attachers, function(attacher) {
        var delta2 = getNewAttachShapeDelta(attacher, oldShape, newShape);
        modeling.moveShape(attacher, delta2, attacher.parent);
      });
    }
  });
  this.postExecute("shape.resize", function(event2) {
    var context = event2.context, shape = context.shape, oldBounds = context.oldBounds, newBounds = context.newBounds, attachers = shape.attachers, hints = context.hints || {};
    if (hints.attachSupport === false) {
      return;
    }
    forEach$1(attachers, function(attacher) {
      var delta2 = getNewAttachShapeDelta(attacher, oldBounds, newBounds);
      modeling.moveShape(attacher, delta2, attacher.parent);
      forEach$1(attacher.labels, function(label) {
        modeling.moveShape(label, delta2, label.parent);
      });
    });
  });
  this.preExecute("shape.delete", function(event2) {
    var shape = event2.context.shape;
    saveClear(shape.attachers, function(attacher) {
      modeling.removeShape(attacher);
    });
    if (shape.host) {
      modeling.updateAttachment(shape, null);
    }
  });
}
e$3(AttachSupport, CommandInterceptor);
AttachSupport.$inject = [
  "injector",
  "eventBus",
  "canvas",
  "rules",
  "modeling"
];
function getAttachers(shapes) {
  return flatten(map$1(shapes, function(s2) {
    return s2.attachers || [];
  }));
}
function addAttached(elements) {
  var attachers = getAttachers(elements);
  return unionBy("id", elements, attachers);
}
function removeAttached(elements) {
  var ids2 = groupBy(elements, "id");
  return filter(elements, function(element) {
    while (element) {
      if (element.host && ids2[element.host.id]) {
        return false;
      }
      element = element.parent;
    }
    return true;
  });
}
function isAttacher(shape) {
  return !!shape.host;
}
function includes$3(array, item) {
  return array.indexOf(item) !== -1;
}
const AttachSupportModule = {
  __depends__: [
    RulesModule$1
  ],
  __init__: ["attachSupport"],
  attachSupport: ["type", AttachSupport]
};
function BpmnFactory(moddle) {
  this._model = moddle;
}
BpmnFactory.$inject = ["moddle"];
BpmnFactory.prototype._needsId = function(element) {
  return isAny(element, [
    "bpmn:RootElement",
    "bpmn:FlowElement",
    "bpmn:MessageFlow",
    "bpmn:DataAssociation",
    "bpmn:Artifact",
    "bpmn:Participant",
    "bpmn:Lane",
    "bpmn:LaneSet",
    "bpmn:Process",
    "bpmn:Collaboration",
    "bpmndi:BPMNShape",
    "bpmndi:BPMNEdge",
    "bpmndi:BPMNDiagram",
    "bpmndi:BPMNPlane",
    "bpmn:Property",
    "bpmn:CategoryValue"
  ]);
};
BpmnFactory.prototype._ensureId = function(element) {
  if (element.id) {
    this._model.ids.claim(element.id, element);
    return;
  }
  var prefix2;
  if (is$1(element, "bpmn:Activity")) {
    prefix2 = "Activity";
  } else if (is$1(element, "bpmn:Event")) {
    prefix2 = "Event";
  } else if (is$1(element, "bpmn:Gateway")) {
    prefix2 = "Gateway";
  } else if (isAny(element, ["bpmn:SequenceFlow", "bpmn:MessageFlow"])) {
    prefix2 = "Flow";
  } else {
    prefix2 = (element.$type || "").replace(/^[^:]*:/g, "");
  }
  prefix2 += "_";
  if (!element.id && this._needsId(element)) {
    element.id = this._model.ids.nextPrefixed(prefix2, element);
  }
};
BpmnFactory.prototype.create = function(type, attrs) {
  var element = this._model.create(type, attrs || {});
  this._ensureId(element);
  return element;
};
BpmnFactory.prototype.createDiLabel = function() {
  return this.create("bpmndi:BPMNLabel", {
    bounds: this.createDiBounds()
  });
};
BpmnFactory.prototype.createDiShape = function(semantic, attrs) {
  return this.create("bpmndi:BPMNShape", assign$1({
    bpmnElement: semantic,
    bounds: this.createDiBounds()
  }, attrs));
};
BpmnFactory.prototype.createDiBounds = function(bounds) {
  return this.create("dc:Bounds", bounds);
};
BpmnFactory.prototype.createDiWaypoints = function(waypoints) {
  var self2 = this;
  return map$1(waypoints, function(pos) {
    return self2.createDiWaypoint(pos);
  });
};
BpmnFactory.prototype.createDiWaypoint = function(point) {
  return this.create("dc:Point", pick(point, ["x", "y"]));
};
BpmnFactory.prototype.createDiEdge = function(semantic, attrs) {
  return this.create("bpmndi:BPMNEdge", assign$1({
    bpmnElement: semantic,
    waypoint: this.createDiWaypoints([])
  }, attrs));
};
BpmnFactory.prototype.createDiPlane = function(semantic, attrs) {
  return this.create("bpmndi:BPMNPlane", assign$1({
    bpmnElement: semantic
  }, attrs));
};
function BpmnUpdater(eventBus, bpmnFactory, connectionDocking, translate2) {
  CommandInterceptor.call(this, eventBus);
  this._bpmnFactory = bpmnFactory;
  this._translate = translate2;
  var self2 = this;
  function cropConnection(e2) {
    var context = e2.context, hints = context.hints || {}, connection;
    if (!context.cropped && hints.createElementsBehavior !== false) {
      connection = context.connection;
      connection.waypoints = connectionDocking.getCroppedWaypoints(connection);
      context.cropped = true;
    }
  }
  this.executed([
    "connection.layout",
    "connection.create"
  ], cropConnection);
  this.reverted(["connection.layout"], function(e2) {
    delete e2.context.cropped;
  });
  function updateParent(e2) {
    var context = e2.context;
    self2.updateParent(context.shape || context.connection, context.oldParent);
  }
  function reverseUpdateParent(e2) {
    var context = e2.context;
    var element = context.shape || context.connection, oldParent = context.parent || context.newParent;
    self2.updateParent(element, oldParent);
  }
  this.executed([
    "shape.move",
    "shape.create",
    "shape.delete",
    "connection.create",
    "connection.move",
    "connection.delete"
  ], ifBpmn(updateParent));
  this.reverted([
    "shape.move",
    "shape.create",
    "shape.delete",
    "connection.create",
    "connection.move",
    "connection.delete"
  ], ifBpmn(reverseUpdateParent));
  function updateRoot(event2) {
    var context = event2.context, oldRoot = context.oldRoot, children = oldRoot.children;
    forEach$1(children, function(child) {
      if (is$1(child, "bpmn:BaseElement")) {
        self2.updateParent(child);
      }
    });
  }
  this.executed(["canvas.updateRoot"], updateRoot);
  this.reverted(["canvas.updateRoot"], updateRoot);
  function updateBounds(e2) {
    var shape = e2.context.shape;
    if (!is$1(shape, "bpmn:BaseElement")) {
      return;
    }
    self2.updateBounds(shape);
  }
  this.executed(["shape.move", "shape.create", "shape.resize"], ifBpmn(function(event2) {
    if (event2.context.shape.type === "label") {
      return;
    }
    updateBounds(event2);
  }));
  this.reverted(["shape.move", "shape.create", "shape.resize"], ifBpmn(function(event2) {
    if (event2.context.shape.type === "label") {
      return;
    }
    updateBounds(event2);
  }));
  eventBus.on("shape.changed", function(event2) {
    if (event2.element.type === "label") {
      updateBounds({ context: { shape: event2.element } });
    }
  });
  function updateConnection(e2) {
    self2.updateConnection(e2.context);
  }
  this.executed([
    "connection.create",
    "connection.move",
    "connection.delete",
    "connection.reconnect"
  ], ifBpmn(updateConnection));
  this.reverted([
    "connection.create",
    "connection.move",
    "connection.delete",
    "connection.reconnect"
  ], ifBpmn(updateConnection));
  function updateConnectionWaypoints(e2) {
    self2.updateConnectionWaypoints(e2.context.connection);
  }
  this.executed([
    "connection.layout",
    "connection.move",
    "connection.updateWaypoints"
  ], ifBpmn(updateConnectionWaypoints));
  this.reverted([
    "connection.layout",
    "connection.move",
    "connection.updateWaypoints"
  ], ifBpmn(updateConnectionWaypoints));
  this.executed("connection.reconnect", ifBpmn(function(event2) {
    var context = event2.context, connection = context.connection, oldSource = context.oldSource, newSource = context.newSource, connectionBo = getBusinessObject(connection), oldSourceBo = getBusinessObject(oldSource), newSourceBo = getBusinessObject(newSource);
    if (connectionBo.conditionExpression && !isAny(newSourceBo, [
      "bpmn:Activity",
      "bpmn:ExclusiveGateway",
      "bpmn:InclusiveGateway"
    ])) {
      context.oldConditionExpression = connectionBo.conditionExpression;
      delete connectionBo.conditionExpression;
    }
    if (oldSource !== newSource && oldSourceBo.default === connectionBo) {
      context.oldDefault = oldSourceBo.default;
      delete oldSourceBo.default;
    }
  }));
  this.reverted("connection.reconnect", ifBpmn(function(event2) {
    var context = event2.context, connection = context.connection, oldSource = context.oldSource, newSource = context.newSource, connectionBo = getBusinessObject(connection), oldSourceBo = getBusinessObject(oldSource), newSourceBo = getBusinessObject(newSource);
    if (context.oldConditionExpression) {
      connectionBo.conditionExpression = context.oldConditionExpression;
    }
    if (context.oldDefault) {
      oldSourceBo.default = context.oldDefault;
      delete newSourceBo.default;
    }
  }));
  function updateAttachment(e2) {
    self2.updateAttachment(e2.context);
  }
  this.executed(["element.updateAttachment"], ifBpmn(updateAttachment));
  this.reverted(["element.updateAttachment"], ifBpmn(updateAttachment));
  this.executed("element.updateLabel", ifBpmn(updateBPMNLabel));
  this.reverted("element.updateLabel", ifBpmn(updateBPMNLabel));
  function updateBPMNLabel(event2) {
    const { element } = event2.context, label = getLabel(element);
    const di = getDi(element), diLabel = di && di.get("label");
    if (isLabelExternal(element) || isPlane(element)) {
      return;
    }
    if (label && !diLabel) {
      di.set("label", bpmnFactory.create("bpmndi:BPMNLabel"));
    } else if (!label && diLabel) {
      di.set("label", void 0);
    }
  }
}
e$3(BpmnUpdater, CommandInterceptor);
BpmnUpdater.$inject = [
  "eventBus",
  "bpmnFactory",
  "connectionDocking",
  "translate"
];
BpmnUpdater.prototype.updateAttachment = function(context) {
  var shape = context.shape, businessObject = shape.businessObject, host = shape.host;
  businessObject.attachedToRef = host && host.businessObject;
};
BpmnUpdater.prototype.updateParent = function(element, oldParent) {
  if (isLabel(element)) {
    return;
  }
  if (is$1(element, "bpmn:DataStoreReference") && element.parent && is$1(element.parent, "bpmn:Collaboration")) {
    return;
  }
  var parentShape = element.parent;
  var businessObject = element.businessObject, di = getDi(element), parentBusinessObject = parentShape && parentShape.businessObject, parentDi = getDi(parentShape);
  if (is$1(element, "bpmn:FlowNode")) {
    this.updateFlowNodeRefs(businessObject, parentBusinessObject, oldParent && oldParent.businessObject);
  }
  if (is$1(element, "bpmn:DataOutputAssociation")) {
    if (element.source) {
      parentBusinessObject = element.source.businessObject;
    } else {
      parentBusinessObject = null;
    }
  }
  if (is$1(element, "bpmn:DataInputAssociation")) {
    if (element.target) {
      parentBusinessObject = element.target.businessObject;
    } else {
      parentBusinessObject = null;
    }
  }
  this.updateSemanticParent(businessObject, parentBusinessObject);
  if (is$1(element, "bpmn:DataObjectReference") && businessObject.dataObjectRef) {
    this.updateSemanticParent(businessObject.dataObjectRef, parentBusinessObject);
  }
  this.updateDiParent(di, parentDi);
};
BpmnUpdater.prototype.updateBounds = function(shape) {
  var di = getDi(shape), embeddedLabelBounds = getEmbeddedLabelBounds(shape);
  if (embeddedLabelBounds) {
    var embeddedLabelBoundsDelta = delta(embeddedLabelBounds, di.get("bounds"));
    assign$1(embeddedLabelBounds, {
      x: shape.x + embeddedLabelBoundsDelta.x,
      y: shape.y + embeddedLabelBoundsDelta.y
    });
  }
  var target = isLabel(shape) ? this._getLabel(di) : di;
  var bounds = target.bounds;
  if (!bounds) {
    bounds = this._bpmnFactory.createDiBounds();
    target.set("bounds", bounds);
  }
  assign$1(bounds, {
    x: shape.x,
    y: shape.y,
    width: shape.width,
    height: shape.height
  });
};
BpmnUpdater.prototype.updateFlowNodeRefs = function(businessObject, newContainment, oldContainment) {
  if (oldContainment === newContainment) {
    return;
  }
  var oldRefs, newRefs;
  if (is$1(oldContainment, "bpmn:Lane")) {
    oldRefs = oldContainment.get("flowNodeRef");
    remove(oldRefs, businessObject);
  }
  if (is$1(newContainment, "bpmn:Lane")) {
    newRefs = newContainment.get("flowNodeRef");
    add(newRefs, businessObject);
  }
};
BpmnUpdater.prototype.updateDiConnection = function(connection, newSource, newTarget) {
  var connectionDi = getDi(connection), newSourceDi = getDi(newSource), newTargetDi = getDi(newTarget);
  if (connectionDi.sourceElement && connectionDi.sourceElement.bpmnElement !== getBusinessObject(newSource)) {
    connectionDi.sourceElement = newSource && newSourceDi;
  }
  if (connectionDi.targetElement && connectionDi.targetElement.bpmnElement !== getBusinessObject(newTarget)) {
    connectionDi.targetElement = newTarget && newTargetDi;
  }
};
BpmnUpdater.prototype.updateDiParent = function(di, parentDi) {
  if (parentDi && !is$1(parentDi, "bpmndi:BPMNPlane")) {
    parentDi = parentDi.$parent;
  }
  if (di.$parent === parentDi) {
    return;
  }
  var planeElements = (parentDi || di.$parent).get("planeElement");
  if (parentDi) {
    planeElements.push(di);
    di.$parent = parentDi;
  } else {
    remove(planeElements, di);
    di.$parent = null;
  }
};
function getDefinitions(element) {
  while (element && !is$1(element, "bpmn:Definitions")) {
    element = element.$parent;
  }
  return element;
}
BpmnUpdater.prototype.getLaneSet = function(container) {
  var laneSet, laneSets;
  if (is$1(container, "bpmn:Lane")) {
    laneSet = container.childLaneSet;
    if (!laneSet) {
      laneSet = this._bpmnFactory.create("bpmn:LaneSet");
      container.childLaneSet = laneSet;
      laneSet.$parent = container;
    }
    return laneSet;
  }
  if (is$1(container, "bpmn:Participant")) {
    container = container.processRef;
  }
  laneSets = container.get("laneSets");
  laneSet = laneSets[0];
  if (!laneSet) {
    laneSet = this._bpmnFactory.create("bpmn:LaneSet");
    laneSet.$parent = container;
    laneSets.push(laneSet);
  }
  return laneSet;
};
BpmnUpdater.prototype.updateSemanticParent = function(businessObject, newParent, visualParent) {
  var containment, translate2 = this._translate;
  if (businessObject.$parent === newParent) {
    return;
  }
  if (is$1(businessObject, "bpmn:DataInput") || is$1(businessObject, "bpmn:DataOutput")) {
    if (is$1(newParent, "bpmn:Participant") && "processRef" in newParent) {
      newParent = newParent.processRef;
    }
    if ("ioSpecification" in newParent && newParent.ioSpecification === businessObject.$parent) {
      return;
    }
  }
  if (is$1(businessObject, "bpmn:Lane")) {
    if (newParent) {
      newParent = this.getLaneSet(newParent);
    }
    containment = "lanes";
  } else if (is$1(businessObject, "bpmn:FlowElement")) {
    if (newParent) {
      if (is$1(newParent, "bpmn:Participant")) {
        newParent = newParent.processRef;
      } else if (is$1(newParent, "bpmn:Lane")) {
        do {
          newParent = newParent.$parent.$parent;
        } while (is$1(newParent, "bpmn:Lane"));
      }
    }
    containment = "flowElements";
  } else if (is$1(businessObject, "bpmn:Artifact")) {
    while (newParent && !is$1(newParent, "bpmn:Process") && !is$1(newParent, "bpmn:SubProcess") && !is$1(newParent, "bpmn:Collaboration")) {
      if (is$1(newParent, "bpmn:Participant")) {
        newParent = newParent.processRef;
        break;
      } else {
        newParent = newParent.$parent;
      }
    }
    containment = "artifacts";
  } else if (is$1(businessObject, "bpmn:MessageFlow")) {
    containment = "messageFlows";
  } else if (is$1(businessObject, "bpmn:Participant")) {
    containment = "participants";
    var process = businessObject.processRef, definitions;
    if (process) {
      definitions = getDefinitions(businessObject.$parent || newParent);
      if (businessObject.$parent) {
        remove(definitions.get("rootElements"), process);
        process.$parent = null;
      }
      if (newParent) {
        add(definitions.get("rootElements"), process);
        process.$parent = definitions;
      }
    }
  } else if (is$1(businessObject, "bpmn:DataOutputAssociation")) {
    containment = "dataOutputAssociations";
  } else if (is$1(businessObject, "bpmn:DataInputAssociation")) {
    containment = "dataInputAssociations";
  }
  if (!containment) {
    throw new Error(translate2(
      "no parent for {element} in {parent}",
      {
        element: businessObject.id,
        parent: newParent.id
      }
    ));
  }
  var children;
  if (businessObject.$parent) {
    children = businessObject.$parent.get(containment);
    remove(children, businessObject);
  }
  if (!newParent) {
    businessObject.$parent = null;
  } else {
    children = newParent.get(containment);
    children.push(businessObject);
    businessObject.$parent = newParent;
  }
  if (visualParent) {
    var diChildren = visualParent.get(containment);
    remove(children, businessObject);
    if (newParent) {
      if (!diChildren) {
        diChildren = [];
        newParent.set(containment, diChildren);
      }
      diChildren.push(businessObject);
    }
  }
};
BpmnUpdater.prototype.updateConnectionWaypoints = function(connection) {
  var di = getDi(connection);
  di.set("waypoint", this._bpmnFactory.createDiWaypoints(connection.waypoints));
};
BpmnUpdater.prototype.updateConnection = function(context) {
  var connection = context.connection, businessObject = getBusinessObject(connection), newSource = connection.source, newSourceBo = getBusinessObject(newSource), newTarget = connection.target, newTargetBo = getBusinessObject(connection.target), visualParent;
  if (!is$1(businessObject, "bpmn:DataAssociation")) {
    var inverseSet = is$1(businessObject, "bpmn:SequenceFlow");
    if (businessObject.sourceRef !== newSourceBo) {
      if (inverseSet) {
        remove(businessObject.sourceRef && businessObject.sourceRef.get("outgoing"), businessObject);
        if (newSourceBo && newSourceBo.get("outgoing")) {
          newSourceBo.get("outgoing").push(businessObject);
        }
      }
      businessObject.sourceRef = newSourceBo;
    }
    if (businessObject.targetRef !== newTargetBo) {
      if (inverseSet) {
        remove(businessObject.targetRef && businessObject.targetRef.get("incoming"), businessObject);
        if (newTargetBo && newTargetBo.get("incoming")) {
          newTargetBo.get("incoming").push(businessObject);
        }
      }
      businessObject.targetRef = newTargetBo;
    }
  } else if (is$1(businessObject, "bpmn:DataInputAssociation")) {
    businessObject.get("sourceRef")[0] = newSourceBo;
    visualParent = context.parent || context.newParent || newTargetBo;
    this.updateSemanticParent(businessObject, newTargetBo, visualParent);
  } else if (is$1(businessObject, "bpmn:DataOutputAssociation")) {
    visualParent = context.parent || context.newParent || newSourceBo;
    this.updateSemanticParent(businessObject, newSourceBo, visualParent);
    businessObject.targetRef = newTargetBo;
  }
  this.updateConnectionWaypoints(connection);
  this.updateDiConnection(connection, newSource, newTarget);
};
BpmnUpdater.prototype._getLabel = function(di) {
  if (!di.label) {
    di.label = this._bpmnFactory.createDiLabel();
  }
  return di.label;
};
function ifBpmn(fn) {
  return function(event2) {
    var context = event2.context, element = context.shape || context.connection || context.element;
    if (is$1(element, "bpmn:BaseElement")) {
      fn(event2);
    }
  };
}
function getEmbeddedLabelBounds(shape) {
  if (!is$1(shape, "bpmn:Activity")) {
    return;
  }
  var di = getDi(shape);
  if (!di) {
    return;
  }
  var label = di.get("label");
  if (!label) {
    return;
  }
  return label.get("bounds");
}
function ElementFactory(bpmnFactory, moddle, translate2) {
  ElementFactory$1.call(this);
  this._bpmnFactory = bpmnFactory;
  this._moddle = moddle;
  this._translate = translate2;
}
e$3(ElementFactory, ElementFactory$1);
ElementFactory.$inject = [
  "bpmnFactory",
  "moddle",
  "translate"
];
ElementFactory.prototype._baseCreate = ElementFactory$1.prototype.create;
ElementFactory.prototype.create = function(elementType, attrs) {
  if (elementType === "label") {
    var di = attrs.di || this._bpmnFactory.createDiLabel();
    return this._baseCreate(elementType, assign$1({ type: "label", di }, DEFAULT_LABEL_SIZE$1, attrs));
  }
  return this.createElement(elementType, attrs);
};
ElementFactory.prototype.createElement = function(elementType, attrs) {
  var size2, translate2 = this._translate;
  attrs = assign$1({}, attrs || {});
  var businessObject = attrs.businessObject, di = attrs.di;
  if (!businessObject) {
    if (!attrs.type) {
      throw new Error(translate2("no shape type specified"));
    }
    businessObject = this._bpmnFactory.create(attrs.type);
    ensureCompatDiRef(businessObject);
  }
  if (!isModdleDi(di)) {
    var diAttrs = assign$1(
      {},
      di || {},
      { id: businessObject.id + "_di" }
    );
    if (elementType === "root") {
      di = this._bpmnFactory.createDiPlane(businessObject, diAttrs);
    } else if (elementType === "connection") {
      di = this._bpmnFactory.createDiEdge(businessObject, diAttrs);
    } else {
      di = this._bpmnFactory.createDiShape(businessObject, diAttrs);
    }
  }
  if (is$1(businessObject, "bpmn:Group")) {
    attrs = assign$1({
      isFrame: true
    }, attrs);
  }
  attrs = applyAttributes(businessObject, attrs, [
    "processRef",
    "isInterrupting",
    "associationDirection",
    "isForCompensation"
  ]);
  if (attrs.isExpanded) {
    attrs = applyAttribute(di, attrs, "isExpanded");
  }
  if (isAny(businessObject, ["bpmn:Lane", "bpmn:Participant"])) {
    attrs = applyAttribute(di, attrs, "isHorizontal");
  }
  if (is$1(businessObject, "bpmn:SubProcess")) {
    attrs.collapsed = !isExpanded(businessObject, di);
  }
  if (is$1(businessObject, "bpmn:ExclusiveGateway")) {
    if (has$1(di, "isMarkerVisible")) {
      if (di.isMarkerVisible === void 0) {
        di.isMarkerVisible = false;
      }
    } else {
      di.isMarkerVisible = true;
    }
  }
  if (isDefined(attrs.triggeredByEvent)) {
    businessObject.triggeredByEvent = attrs.triggeredByEvent;
    delete attrs.triggeredByEvent;
  }
  if (isDefined(attrs.cancelActivity)) {
    businessObject.cancelActivity = attrs.cancelActivity;
    delete attrs.cancelActivity;
  }
  var eventDefinitions, newEventDefinition;
  if (attrs.eventDefinitionType) {
    eventDefinitions = businessObject.get("eventDefinitions") || [];
    newEventDefinition = this._bpmnFactory.create(attrs.eventDefinitionType, attrs.eventDefinitionAttrs);
    if (attrs.eventDefinitionType === "bpmn:ConditionalEventDefinition") {
      newEventDefinition.condition = this._bpmnFactory.create("bpmn:FormalExpression");
    }
    eventDefinitions.push(newEventDefinition);
    newEventDefinition.$parent = businessObject;
    businessObject.eventDefinitions = eventDefinitions;
    delete attrs.eventDefinitionType;
  }
  size2 = this.getDefaultSize(businessObject, di);
  attrs = assign$1({
    id: businessObject.id
  }, size2, attrs, {
    businessObject,
    di
  });
  return this._baseCreate(elementType, attrs);
};
ElementFactory.prototype.getDefaultSize = function(element, di) {
  var bo = getBusinessObject(element);
  di = di || getDi(element);
  if (is$1(bo, "bpmn:SubProcess")) {
    if (isExpanded(bo, di)) {
      return { width: 350, height: 200 };
    } else {
      return { width: 100, height: 80 };
    }
  }
  if (is$1(bo, "bpmn:Task")) {
    return { width: 100, height: 80 };
  }
  if (is$1(bo, "bpmn:Gateway")) {
    return { width: 50, height: 50 };
  }
  if (is$1(bo, "bpmn:Event")) {
    return { width: 36, height: 36 };
  }
  if (is$1(bo, "bpmn:Participant")) {
    if (isExpanded(bo, di)) {
      return { width: 600, height: 250 };
    } else {
      return { width: 400, height: 60 };
    }
  }
  if (is$1(bo, "bpmn:Lane")) {
    return { width: 400, height: 100 };
  }
  if (is$1(bo, "bpmn:DataObjectReference")) {
    return { width: 36, height: 50 };
  }
  if (is$1(bo, "bpmn:DataStoreReference")) {
    return { width: 50, height: 50 };
  }
  if (is$1(bo, "bpmn:TextAnnotation")) {
    return { width: 100, height: 30 };
  }
  if (is$1(bo, "bpmn:Group")) {
    return { width: 300, height: 300 };
  }
  return { width: 100, height: 80 };
};
ElementFactory.prototype.createParticipantShape = function(attrs) {
  if (!isObject(attrs)) {
    attrs = { isExpanded: attrs };
  }
  attrs = assign$1({ type: "bpmn:Participant" }, attrs || {});
  if (attrs.isExpanded !== false) {
    attrs.processRef = this._bpmnFactory.create("bpmn:Process");
  }
  return this.createShape(attrs);
};
function applyAttributes(element, attrs, attributeNames) {
  forEach$1(attributeNames, function(property) {
    attrs = applyAttribute(element, attrs, property);
  });
  return attrs;
}
function applyAttribute(element, attrs, attributeName) {
  if (attrs[attributeName] === void 0) {
    return attrs;
  }
  element[attributeName] = attrs[attributeName];
  return omit(attrs, [attributeName]);
}
function isModdleDi(element) {
  return isAny(element, [
    "bpmndi:BPMNShape",
    "bpmndi:BPMNEdge",
    "bpmndi:BPMNDiagram",
    "bpmndi:BPMNPlane"
  ]);
}
function AlignElements(modeling, canvas) {
  this._modeling = modeling;
  this._canvas = canvas;
}
AlignElements.$inject = ["modeling", "canvas"];
AlignElements.prototype.preExecute = function(context) {
  var modeling = this._modeling;
  var elements = context.elements, alignment = context.alignment;
  forEach$1(elements, function(element) {
    var delta2 = {
      x: 0,
      y: 0
    };
    if (isDefined(alignment.left)) {
      delta2.x = alignment.left - element.x;
    } else if (isDefined(alignment.right)) {
      delta2.x = alignment.right - element.width - element.x;
    } else if (isDefined(alignment.center)) {
      delta2.x = alignment.center - Math.round(element.width / 2) - element.x;
    } else if (isDefined(alignment.top)) {
      delta2.y = alignment.top - element.y;
    } else if (isDefined(alignment.bottom)) {
      delta2.y = alignment.bottom - element.height - element.y;
    } else if (isDefined(alignment.middle)) {
      delta2.y = alignment.middle - Math.round(element.height / 2) - element.y;
    }
    modeling.moveElements([element], delta2, element.parent);
  });
};
AlignElements.prototype.postExecute = function(context) {
};
function AppendShapeHandler(modeling) {
  this._modeling = modeling;
}
AppendShapeHandler.$inject = ["modeling"];
AppendShapeHandler.prototype.preExecute = function(context) {
  var source = context.source;
  if (!source) {
    throw new Error("source required");
  }
  var target = context.target || source.parent, shape = context.shape, hints = context.hints || {};
  shape = context.shape = this._modeling.createShape(
    shape,
    context.position,
    target,
    { attach: hints.attach }
  );
  context.shape = shape;
};
AppendShapeHandler.prototype.postExecute = function(context) {
  var hints = context.hints || {};
  if (!existsConnection(context.source, context.shape)) {
    if (hints.connectionTarget === context.source) {
      this._modeling.connect(context.shape, context.source, context.connection);
    } else {
      this._modeling.connect(context.source, context.shape, context.connection);
    }
  }
};
function existsConnection(source, target) {
  return some(source.outgoing, function(c2) {
    return c2.target === target;
  });
}
function CreateConnectionHandler(canvas, layouter) {
  this._canvas = canvas;
  this._layouter = layouter;
}
CreateConnectionHandler.$inject = ["canvas", "layouter"];
CreateConnectionHandler.prototype.execute = function(context) {
  var connection = context.connection, source = context.source, target = context.target, parent = context.parent, parentIndex = context.parentIndex, hints = context.hints;
  if (!source || !target) {
    throw new Error("source and target required");
  }
  if (!parent) {
    throw new Error("parent required");
  }
  connection.source = source;
  connection.target = target;
  if (!connection.waypoints) {
    connection.waypoints = this._layouter.layoutConnection(connection, hints);
  }
  this._canvas.addConnection(connection, parent, parentIndex);
  return connection;
};
CreateConnectionHandler.prototype.revert = function(context) {
  var connection = context.connection;
  this._canvas.removeConnection(connection);
  connection.source = null;
  connection.target = null;
  return connection;
};
var round$4 = Math.round;
function CreateElementsHandler(modeling) {
  this._modeling = modeling;
}
CreateElementsHandler.$inject = [
  "modeling"
];
CreateElementsHandler.prototype.preExecute = function(context) {
  var elements = context.elements, parent = context.parent, parentIndex = context.parentIndex, position = context.position, hints = context.hints;
  var modeling = this._modeling;
  forEach$1(elements, function(element) {
    if (!isNumber(element.x)) {
      element.x = 0;
    }
    if (!isNumber(element.y)) {
      element.y = 0;
    }
  });
  var visibleElements = filter(elements, function(element) {
    return !element.hidden;
  });
  var bbox = getBBox(visibleElements);
  forEach$1(elements, function(element) {
    if (isConnection(element)) {
      element.waypoints = map$1(element.waypoints, function(waypoint) {
        return {
          x: round$4(waypoint.x - bbox.x - bbox.width / 2 + position.x),
          y: round$4(waypoint.y - bbox.y - bbox.height / 2 + position.y)
        };
      });
    }
    assign$1(element, {
      x: round$4(element.x - bbox.x - bbox.width / 2 + position.x),
      y: round$4(element.y - bbox.y - bbox.height / 2 + position.y)
    });
  });
  var parents = getParents$1(elements);
  var cache = {};
  forEach$1(elements, function(element) {
    if (isConnection(element)) {
      cache[element.id] = isNumber(parentIndex) ? modeling.createConnection(
        cache[element.source.id],
        cache[element.target.id],
        parentIndex,
        element,
        element.parent || parent,
        hints
      ) : modeling.createConnection(
        cache[element.source.id],
        cache[element.target.id],
        element,
        element.parent || parent,
        hints
      );
      return;
    }
    var createShapeHints = assign$1({}, hints);
    if (parents.indexOf(element) === -1) {
      createShapeHints.autoResize = false;
    }
    if (isLabel(element)) {
      createShapeHints = omit(createShapeHints, ["attach"]);
    }
    cache[element.id] = isNumber(parentIndex) ? modeling.createShape(
      element,
      pick(element, ["x", "y", "width", "height"]),
      element.parent || parent,
      parentIndex,
      createShapeHints
    ) : modeling.createShape(
      element,
      pick(element, ["x", "y", "width", "height"]),
      element.parent || parent,
      createShapeHints
    );
  });
  context.elements = values(cache);
};
var round$3 = Math.round;
function CreateShapeHandler(canvas) {
  this._canvas = canvas;
}
CreateShapeHandler.$inject = ["canvas"];
CreateShapeHandler.prototype.execute = function(context) {
  var shape = context.shape, positionOrBounds = context.position, parent = context.parent, parentIndex = context.parentIndex;
  if (!parent) {
    throw new Error("parent required");
  }
  if (!positionOrBounds) {
    throw new Error("position required");
  }
  if (positionOrBounds.width !== void 0) {
    assign$1(shape, positionOrBounds);
  } else {
    assign$1(shape, {
      x: positionOrBounds.x - round$3(shape.width / 2),
      y: positionOrBounds.y - round$3(shape.height / 2)
    });
  }
  this._canvas.addShape(shape, parent, parentIndex);
  return shape;
};
CreateShapeHandler.prototype.revert = function(context) {
  var shape = context.shape;
  this._canvas.removeShape(shape);
  return shape;
};
function CreateLabelHandler(canvas) {
  CreateShapeHandler.call(this, canvas);
}
e$3(CreateLabelHandler, CreateShapeHandler);
CreateLabelHandler.$inject = ["canvas"];
var originalExecute = CreateShapeHandler.prototype.execute;
CreateLabelHandler.prototype.execute = function(context) {
  var label = context.shape;
  ensureValidDimensions(label);
  label.labelTarget = context.labelTarget;
  return originalExecute.call(this, context);
};
var originalRevert = CreateShapeHandler.prototype.revert;
CreateLabelHandler.prototype.revert = function(context) {
  context.shape.labelTarget = null;
  return originalRevert.call(this, context);
};
function ensureValidDimensions(label) {
  ["width", "height"].forEach(function(prop) {
    if (typeof label[prop] === "undefined") {
      label[prop] = 0;
    }
  });
}
function DeleteConnectionHandler(canvas, modeling) {
  this._canvas = canvas;
  this._modeling = modeling;
}
DeleteConnectionHandler.$inject = [
  "canvas",
  "modeling"
];
DeleteConnectionHandler.prototype.preExecute = function(context) {
  var modeling = this._modeling;
  var connection = context.connection;
  saveClear(connection.incoming, function(connection2) {
    modeling.removeConnection(connection2, { nested: true });
  });
  saveClear(connection.outgoing, function(connection2) {
    modeling.removeConnection(connection2, { nested: true });
  });
};
DeleteConnectionHandler.prototype.execute = function(context) {
  var connection = context.connection, parent = connection.parent;
  context.parent = parent;
  context.parentIndex = indexOf(parent.children, connection);
  context.source = connection.source;
  context.target = connection.target;
  this._canvas.removeConnection(connection);
  connection.source = null;
  connection.target = null;
  return connection;
};
DeleteConnectionHandler.prototype.revert = function(context) {
  var connection = context.connection, parent = context.parent, parentIndex = context.parentIndex;
  connection.source = context.source;
  connection.target = context.target;
  add(parent.children, connection, parentIndex);
  this._canvas.addConnection(connection, parent);
  return connection;
};
function DeleteElementsHandler(modeling, elementRegistry) {
  this._modeling = modeling;
  this._elementRegistry = elementRegistry;
}
DeleteElementsHandler.$inject = [
  "modeling",
  "elementRegistry"
];
DeleteElementsHandler.prototype.postExecute = function(context) {
  var modeling = this._modeling, elementRegistry = this._elementRegistry, elements = context.elements;
  forEach$1(elements, function(element) {
    if (!elementRegistry.get(element.id)) {
      return;
    }
    if (element.waypoints) {
      modeling.removeConnection(element);
    } else {
      modeling.removeShape(element);
    }
  });
};
function DeleteShapeHandler(canvas, modeling) {
  this._canvas = canvas;
  this._modeling = modeling;
}
DeleteShapeHandler.$inject = ["canvas", "modeling"];
DeleteShapeHandler.prototype.preExecute = function(context) {
  var modeling = this._modeling;
  var shape = context.shape;
  saveClear(shape.incoming, function(connection) {
    modeling.removeConnection(connection, { nested: true });
  });
  saveClear(shape.outgoing, function(connection) {
    modeling.removeConnection(connection, { nested: true });
  });
  saveClear(shape.children, function(child) {
    if (isConnection(child)) {
      modeling.removeConnection(child, { nested: true });
    } else {
      modeling.removeShape(child, { nested: true });
    }
  });
};
DeleteShapeHandler.prototype.execute = function(context) {
  var canvas = this._canvas;
  var shape = context.shape, oldParent = shape.parent;
  context.oldParent = oldParent;
  context.oldParentIndex = indexOf(oldParent.children, shape);
  canvas.removeShape(shape);
  return shape;
};
DeleteShapeHandler.prototype.revert = function(context) {
  var canvas = this._canvas;
  var shape = context.shape, oldParent = context.oldParent, oldParentIndex = context.oldParentIndex;
  add(oldParent.children, shape, oldParentIndex);
  canvas.addShape(shape, oldParent);
  return shape;
};
function DistributeElements$1(modeling) {
  this._modeling = modeling;
}
DistributeElements$1.$inject = ["modeling"];
var OFF_AXIS = {
  x: "y",
  y: "x"
};
DistributeElements$1.prototype.preExecute = function(context) {
  var modeling = this._modeling;
  var groups = context.groups, axis = context.axis, dimension = context.dimension;
  function updateRange(group, element) {
    group.range.min = Math.min(element[axis], group.range.min);
    group.range.max = Math.max(element[axis] + element[dimension], group.range.max);
  }
  function center2(element) {
    return element[axis] + element[dimension] / 2;
  }
  function lastIdx(arr) {
    return arr.length - 1;
  }
  function rangeDiff(range) {
    return range.max - range.min;
  }
  function centerElement(refCenter, element) {
    var delta2 = { y: 0 };
    delta2[axis] = refCenter - center2(element);
    if (delta2[axis]) {
      delta2[OFF_AXIS[axis]] = 0;
      modeling.moveElements([element], delta2, element.parent);
    }
  }
  var firstGroup = groups[0], lastGroupIdx = lastIdx(groups), lastGroup = groups[lastGroupIdx];
  var margin, spaceInBetween, groupsSize = 0;
  forEach$1(groups, function(group, idx) {
    var sortedElements, refElem, refCenter;
    if (group.elements.length < 2) {
      if (idx && idx !== groups.length - 1) {
        updateRange(group, group.elements[0]);
        groupsSize += rangeDiff(group.range);
      }
      return;
    }
    sortedElements = sortBy(group.elements, axis);
    refElem = sortedElements[0];
    if (idx === lastGroupIdx) {
      refElem = sortedElements[lastIdx(sortedElements)];
    }
    refCenter = center2(refElem);
    group.range = null;
    forEach$1(sortedElements, function(element) {
      centerElement(refCenter, element);
      if (group.range === null) {
        group.range = {
          min: element[axis],
          max: element[axis] + element[dimension]
        };
        return;
      }
      updateRange(group, element);
    });
    if (idx && idx !== groups.length - 1) {
      groupsSize += rangeDiff(group.range);
    }
  });
  spaceInBetween = Math.abs(lastGroup.range.min - firstGroup.range.max);
  margin = Math.round((spaceInBetween - groupsSize) / (groups.length - 1));
  if (margin < groups.length - 1) {
    return;
  }
  forEach$1(groups, function(group, groupIdx) {
    var delta2 = {}, prevGroup;
    if (group === firstGroup || group === lastGroup) {
      return;
    }
    prevGroup = groups[groupIdx - 1];
    group.range.max = 0;
    forEach$1(group.elements, function(element, idx) {
      delta2[OFF_AXIS[axis]] = 0;
      delta2[axis] = prevGroup.range.max - element[axis] + margin;
      if (group.range.min !== element[axis]) {
        delta2[axis] += element[axis] - group.range.min;
      }
      if (delta2[axis]) {
        modeling.moveElements([element], delta2, element.parent);
      }
      group.range.max = Math.max(element[axis] + element[dimension], idx ? group.range.max : 0);
    });
  });
};
DistributeElements$1.prototype.postExecute = function(context) {
};
function LayoutConnectionHandler(layouter, canvas) {
  this._layouter = layouter;
  this._canvas = canvas;
}
LayoutConnectionHandler.$inject = ["layouter", "canvas"];
LayoutConnectionHandler.prototype.execute = function(context) {
  var connection = context.connection;
  var oldWaypoints = connection.waypoints;
  assign$1(context, {
    oldWaypoints
  });
  connection.waypoints = this._layouter.layoutConnection(connection, context.hints);
  return connection;
};
LayoutConnectionHandler.prototype.revert = function(context) {
  var connection = context.connection;
  connection.waypoints = context.oldWaypoints;
  return connection;
};
function MoveConnectionHandler() {
}
MoveConnectionHandler.prototype.execute = function(context) {
  var connection = context.connection, delta2 = context.delta;
  var newParent = context.newParent || connection.parent, newParentIndex = context.newParentIndex, oldParent = connection.parent;
  context.oldParent = oldParent;
  context.oldParentIndex = remove(oldParent.children, connection);
  add(newParent.children, connection, newParentIndex);
  connection.parent = newParent;
  forEach$1(connection.waypoints, function(p2) {
    p2.x += delta2.x;
    p2.y += delta2.y;
    if (p2.original) {
      p2.original.x += delta2.x;
      p2.original.y += delta2.y;
    }
  });
  return connection;
};
MoveConnectionHandler.prototype.revert = function(context) {
  var connection = context.connection, newParent = connection.parent, oldParent = context.oldParent, oldParentIndex = context.oldParentIndex, delta2 = context.delta;
  remove(newParent.children, connection);
  add(oldParent.children, connection, oldParentIndex);
  connection.parent = oldParent;
  forEach$1(connection.waypoints, function(p2) {
    p2.x -= delta2.x;
    p2.y -= delta2.y;
    if (p2.original) {
      p2.original.x -= delta2.x;
      p2.original.y -= delta2.y;
    }
  });
  return connection;
};
function MoveClosure() {
  this.allShapes = {};
  this.allConnections = {};
  this.enclosedElements = {};
  this.enclosedConnections = {};
  this.topLevel = {};
}
MoveClosure.prototype.add = function(element, isTopLevel) {
  return this.addAll([element], isTopLevel);
};
MoveClosure.prototype.addAll = function(elements, isTopLevel) {
  var newClosure = getClosure(elements, !!isTopLevel, this);
  assign$1(this, newClosure);
  return this;
};
function MoveHelper(modeling) {
  this._modeling = modeling;
}
MoveHelper.prototype.moveRecursive = function(elements, delta2, newParent) {
  if (!elements) {
    return [];
  } else {
    return this.moveClosure(this.getClosure(elements), delta2, newParent);
  }
};
MoveHelper.prototype.moveClosure = function(closure, delta2, newParent, newHost, primaryShape) {
  var modeling = this._modeling;
  var allShapes = closure.allShapes, allConnections = closure.allConnections, enclosedConnections = closure.enclosedConnections, topLevel = closure.topLevel, keepParent = false;
  if (primaryShape && primaryShape.parent === newParent) {
    keepParent = true;
  }
  forEach$1(allShapes, function(shape) {
    modeling.moveShape(shape, delta2, topLevel[shape.id] && !keepParent && newParent, {
      recurse: false,
      layout: false
    });
  });
  forEach$1(allConnections, function(c2) {
    var sourceMoved = !!allShapes[c2.source.id], targetMoved = !!allShapes[c2.target.id];
    if (enclosedConnections[c2.id] && sourceMoved && targetMoved) {
      modeling.moveConnection(c2, delta2, topLevel[c2.id] && !keepParent && newParent);
    } else {
      modeling.layoutConnection(c2, {
        connectionStart: sourceMoved && getMovedSourceAnchor(c2, c2.source, delta2),
        connectionEnd: targetMoved && getMovedTargetAnchor(c2, c2.target, delta2)
      });
    }
  });
};
MoveHelper.prototype.getClosure = function(elements) {
  return new MoveClosure().addAll(elements, true);
};
function MoveElementsHandler(modeling) {
  this._helper = new MoveHelper(modeling);
}
MoveElementsHandler.$inject = ["modeling"];
MoveElementsHandler.prototype.preExecute = function(context) {
  context.closure = this._helper.getClosure(context.shapes);
};
MoveElementsHandler.prototype.postExecute = function(context) {
  var hints = context.hints, primaryShape;
  if (hints && hints.primaryShape) {
    primaryShape = hints.primaryShape;
    hints.oldParent = primaryShape.parent;
  }
  this._helper.moveClosure(
    context.closure,
    context.delta,
    context.newParent,
    context.newHost,
    primaryShape
  );
};
function MoveShapeHandler(modeling) {
  this._modeling = modeling;
  this._helper = new MoveHelper(modeling);
}
MoveShapeHandler.$inject = ["modeling"];
MoveShapeHandler.prototype.execute = function(context) {
  var shape = context.shape, delta2 = context.delta, newParent = context.newParent || shape.parent, newParentIndex = context.newParentIndex, oldParent = shape.parent;
  context.oldBounds = pick(shape, ["x", "y", "width", "height"]);
  context.oldParent = oldParent;
  context.oldParentIndex = remove(oldParent.children, shape);
  add(newParent.children, shape, newParentIndex);
  assign$1(shape, {
    parent: newParent,
    x: shape.x + delta2.x,
    y: shape.y + delta2.y
  });
  return shape;
};
MoveShapeHandler.prototype.postExecute = function(context) {
  var shape = context.shape, delta2 = context.delta, hints = context.hints;
  var modeling = this._modeling;
  if (hints.layout !== false) {
    forEach$1(shape.incoming, function(c2) {
      modeling.layoutConnection(c2, {
        connectionEnd: getMovedTargetAnchor(c2, shape, delta2)
      });
    });
    forEach$1(shape.outgoing, function(c2) {
      modeling.layoutConnection(c2, {
        connectionStart: getMovedSourceAnchor(c2, shape, delta2)
      });
    });
  }
  if (hints.recurse !== false) {
    this.moveChildren(context);
  }
};
MoveShapeHandler.prototype.revert = function(context) {
  var shape = context.shape, oldParent = context.oldParent, oldParentIndex = context.oldParentIndex, delta2 = context.delta;
  add(oldParent.children, shape, oldParentIndex);
  assign$1(shape, {
    parent: oldParent,
    x: shape.x - delta2.x,
    y: shape.y - delta2.y
  });
  return shape;
};
MoveShapeHandler.prototype.moveChildren = function(context) {
  var delta2 = context.delta, shape = context.shape;
  this._helper.moveRecursive(shape.children, delta2, null);
};
MoveShapeHandler.prototype.getNewParent = function(context) {
  return context.newParent || context.shape.parent;
};
function ReconnectConnectionHandler(modeling) {
  this._modeling = modeling;
}
ReconnectConnectionHandler.$inject = ["modeling"];
ReconnectConnectionHandler.prototype.execute = function(context) {
  var newSource = context.newSource, newTarget = context.newTarget, connection = context.connection, dockingOrPoints = context.dockingOrPoints;
  if (!newSource && !newTarget) {
    throw new Error("newSource or newTarget required");
  }
  if (isArray$3(dockingOrPoints)) {
    context.oldWaypoints = connection.waypoints;
    connection.waypoints = dockingOrPoints;
  }
  if (newSource) {
    context.oldSource = connection.source;
    connection.source = newSource;
  }
  if (newTarget) {
    context.oldTarget = connection.target;
    connection.target = newTarget;
  }
  return connection;
};
ReconnectConnectionHandler.prototype.postExecute = function(context) {
  var connection = context.connection, newSource = context.newSource, newTarget = context.newTarget, dockingOrPoints = context.dockingOrPoints, hints = context.hints || {};
  var layoutConnectionHints = {};
  if (hints.connectionStart) {
    layoutConnectionHints.connectionStart = hints.connectionStart;
  }
  if (hints.connectionEnd) {
    layoutConnectionHints.connectionEnd = hints.connectionEnd;
  }
  if (hints.layoutConnection === false) {
    return;
  }
  if (newSource && (!newTarget || hints.docking === "source")) {
    layoutConnectionHints.connectionStart = layoutConnectionHints.connectionStart || getDocking(isArray$3(dockingOrPoints) ? dockingOrPoints[0] : dockingOrPoints);
  }
  if (newTarget && (!newSource || hints.docking === "target")) {
    layoutConnectionHints.connectionEnd = layoutConnectionHints.connectionEnd || getDocking(isArray$3(dockingOrPoints) ? dockingOrPoints[dockingOrPoints.length - 1] : dockingOrPoints);
  }
  if (hints.newWaypoints) {
    layoutConnectionHints.waypoints = hints.newWaypoints;
  }
  this._modeling.layoutConnection(connection, layoutConnectionHints);
};
ReconnectConnectionHandler.prototype.revert = function(context) {
  var oldSource = context.oldSource, oldTarget = context.oldTarget, oldWaypoints = context.oldWaypoints, connection = context.connection;
  if (oldSource) {
    connection.source = oldSource;
  }
  if (oldTarget) {
    connection.target = oldTarget;
  }
  if (oldWaypoints) {
    connection.waypoints = oldWaypoints;
  }
  return connection;
};
function getDocking(point) {
  return point.original || point;
}
function ReplaceShapeHandler(modeling, rules) {
  this._modeling = modeling;
  this._rules = rules;
}
ReplaceShapeHandler.$inject = ["modeling", "rules"];
ReplaceShapeHandler.prototype.preExecute = function(context) {
  var self2 = this, modeling = this._modeling, rules = this._rules;
  var oldShape = context.oldShape, newData = context.newData, hints = context.hints || {}, newShape;
  function canReconnect(source, target, connection) {
    return rules.allowed("connection.reconnect", {
      connection,
      source,
      target
    });
  }
  var position = {
    x: newData.x,
    y: newData.y
  };
  var oldBounds = {
    x: oldShape.x,
    y: oldShape.y,
    width: oldShape.width,
    height: oldShape.height
  };
  newShape = context.newShape = context.newShape || self2.createShape(newData, position, oldShape.parent, hints);
  if (oldShape.host) {
    modeling.updateAttachment(newShape, oldShape.host);
  }
  var children;
  if (hints.moveChildren !== false) {
    children = oldShape.children.slice();
    modeling.moveElements(children, { x: 0, y: 0 }, newShape, hints);
  }
  var incoming = oldShape.incoming.slice(), outgoing = oldShape.outgoing.slice();
  forEach$1(incoming, function(connection) {
    var source = connection.source, allowed = canReconnect(source, newShape, connection);
    if (allowed) {
      self2.reconnectEnd(
        connection,
        newShape,
        getResizedTargetAnchor(connection, newShape, oldBounds),
        hints
      );
    }
  });
  forEach$1(outgoing, function(connection) {
    var target = connection.target, allowed = canReconnect(newShape, target, connection);
    if (allowed) {
      self2.reconnectStart(
        connection,
        newShape,
        getResizedSourceAnchor(connection, newShape, oldBounds),
        hints
      );
    }
  });
};
ReplaceShapeHandler.prototype.postExecute = function(context) {
  var oldShape = context.oldShape;
  this._modeling.removeShape(oldShape);
};
ReplaceShapeHandler.prototype.execute = function(context) {
};
ReplaceShapeHandler.prototype.revert = function(context) {
};
ReplaceShapeHandler.prototype.createShape = function(shape, position, target, hints) {
  return this._modeling.createShape(shape, position, target, hints);
};
ReplaceShapeHandler.prototype.reconnectStart = function(connection, newSource, dockingPoint, hints) {
  this._modeling.reconnectStart(connection, newSource, dockingPoint, hints);
};
ReplaceShapeHandler.prototype.reconnectEnd = function(connection, newTarget, dockingPoint, hints) {
  this._modeling.reconnectEnd(connection, newTarget, dockingPoint, hints);
};
function ResizeShapeHandler(modeling) {
  this._modeling = modeling;
}
ResizeShapeHandler.$inject = ["modeling"];
ResizeShapeHandler.prototype.execute = function(context) {
  var shape = context.shape, newBounds = context.newBounds, minBounds = context.minBounds;
  if (newBounds.x === void 0 || newBounds.y === void 0 || newBounds.width === void 0 || newBounds.height === void 0) {
    throw new Error("newBounds must have {x, y, width, height} properties");
  }
  if (minBounds && (newBounds.width < minBounds.width || newBounds.height < minBounds.height)) {
    throw new Error("width and height cannot be less than minimum height and width");
  } else if (!minBounds && newBounds.width < 10 || newBounds.height < 10) {
    throw new Error("width and height cannot be less than 10px");
  }
  context.oldBounds = {
    width: shape.width,
    height: shape.height,
    x: shape.x,
    y: shape.y
  };
  assign$1(shape, {
    width: newBounds.width,
    height: newBounds.height,
    x: newBounds.x,
    y: newBounds.y
  });
  return shape;
};
ResizeShapeHandler.prototype.postExecute = function(context) {
  var modeling = this._modeling;
  var shape = context.shape, oldBounds = context.oldBounds, hints = context.hints || {};
  if (hints.layout === false) {
    return;
  }
  forEach$1(shape.incoming, function(c2) {
    modeling.layoutConnection(c2, {
      connectionEnd: getResizedTargetAnchor(c2, shape, oldBounds)
    });
  });
  forEach$1(shape.outgoing, function(c2) {
    modeling.layoutConnection(c2, {
      connectionStart: getResizedSourceAnchor(c2, shape, oldBounds)
    });
  });
};
ResizeShapeHandler.prototype.revert = function(context) {
  var shape = context.shape, oldBounds = context.oldBounds;
  assign$1(shape, {
    width: oldBounds.width,
    height: oldBounds.height,
    x: oldBounds.x,
    y: oldBounds.y
  });
  return shape;
};
function SpaceToolHandler(modeling) {
  this._modeling = modeling;
}
SpaceToolHandler.$inject = ["modeling"];
SpaceToolHandler.prototype.preExecute = function(context) {
  var delta2 = context.delta, direction = context.direction, movingShapes = context.movingShapes, resizingShapes = context.resizingShapes, start = context.start, oldBounds = {};
  this.moveShapes(movingShapes, delta2);
  forEach$1(resizingShapes, function(shape) {
    oldBounds[shape.id] = getBounds(shape);
  });
  this.resizeShapes(resizingShapes, delta2, direction);
  this.updateConnectionWaypoints(
    getWaypointsUpdatingConnections(movingShapes, resizingShapes),
    delta2,
    direction,
    start,
    movingShapes,
    resizingShapes,
    oldBounds
  );
};
SpaceToolHandler.prototype.execute = function() {
};
SpaceToolHandler.prototype.revert = function() {
};
SpaceToolHandler.prototype.moveShapes = function(shapes, delta2) {
  var self2 = this;
  forEach$1(shapes, function(element) {
    self2._modeling.moveShape(element, delta2, null, {
      autoResize: false,
      layout: false,
      recurse: false
    });
  });
};
SpaceToolHandler.prototype.resizeShapes = function(shapes, delta2, direction) {
  var self2 = this;
  forEach$1(shapes, function(shape) {
    var newBounds = resizeBounds(shape, direction, delta2);
    self2._modeling.resizeShape(shape, newBounds, null, {
      attachSupport: false,
      autoResize: false,
      layout: false
    });
  });
};
SpaceToolHandler.prototype.updateConnectionWaypoints = function(connections, delta2, direction, start, movingShapes, resizingShapes, oldBounds) {
  var self2 = this, affectedShapes = movingShapes.concat(resizingShapes);
  forEach$1(connections, function(connection) {
    var source = connection.source, target = connection.target, waypoints = copyWaypoints(connection), axis = getAxisFromDirection(direction), layoutHints = {};
    if (includes$2(affectedShapes, source) && includes$2(affectedShapes, target)) {
      waypoints = map$1(waypoints, function(waypoint) {
        if (shouldMoveWaypoint(waypoint, start, direction)) {
          waypoint[axis] = waypoint[axis] + delta2[axis];
        }
        if (waypoint.original && shouldMoveWaypoint(waypoint.original, start, direction)) {
          waypoint.original[axis] = waypoint.original[axis] + delta2[axis];
        }
        return waypoint;
      });
      self2._modeling.updateWaypoints(connection, waypoints, {
        labelBehavior: false
      });
    } else if (includes$2(affectedShapes, source) || includes$2(affectedShapes, target)) {
      if (includes$2(movingShapes, source)) {
        layoutHints.connectionStart = getMovedSourceAnchor(connection, source, delta2);
      } else if (includes$2(movingShapes, target)) {
        layoutHints.connectionEnd = getMovedTargetAnchor(connection, target, delta2);
      } else if (includes$2(resizingShapes, source)) {
        layoutHints.connectionStart = getResizedSourceAnchor(
          connection,
          source,
          oldBounds[source.id]
        );
      } else if (includes$2(resizingShapes, target)) {
        layoutHints.connectionEnd = getResizedTargetAnchor(
          connection,
          target,
          oldBounds[target.id]
        );
      }
      self2._modeling.layoutConnection(connection, layoutHints);
    }
  });
};
function copyWaypoint(waypoint) {
  return assign$1({}, waypoint);
}
function copyWaypoints(connection) {
  return map$1(connection.waypoints, function(waypoint) {
    waypoint = copyWaypoint(waypoint);
    if (waypoint.original) {
      waypoint.original = copyWaypoint(waypoint.original);
    }
    return waypoint;
  });
}
function getAxisFromDirection(direction) {
  switch (direction) {
    case "n":
      return "y";
    case "w":
      return "x";
    case "s":
      return "y";
    case "e":
      return "x";
  }
}
function shouldMoveWaypoint(waypoint, start, direction) {
  var relevantAxis = getAxisFromDirection(direction);
  if (/e|s/.test(direction)) {
    return waypoint[relevantAxis] > start;
  } else if (/n|w/.test(direction)) {
    return waypoint[relevantAxis] < start;
  }
}
function includes$2(array, item) {
  return array.indexOf(item) !== -1;
}
function getBounds(shape) {
  return {
    x: shape.x,
    y: shape.y,
    height: shape.height,
    width: shape.width
  };
}
function ToggleShapeCollapseHandler(modeling) {
  this._modeling = modeling;
}
ToggleShapeCollapseHandler.$inject = ["modeling"];
ToggleShapeCollapseHandler.prototype.execute = function(context) {
  var shape = context.shape, children = shape.children;
  context.oldChildrenVisibility = getElementsVisibilityRecursive(children);
  shape.collapsed = !shape.collapsed;
  var result = setHiddenRecursive(children, shape.collapsed);
  return [shape].concat(result);
};
ToggleShapeCollapseHandler.prototype.revert = function(context) {
  var shape = context.shape, oldChildrenVisibility = context.oldChildrenVisibility;
  var children = shape.children;
  var result = restoreVisibilityRecursive(children, oldChildrenVisibility);
  shape.collapsed = !shape.collapsed;
  return [shape].concat(result);
};
function getElementsVisibilityRecursive(elements) {
  var result = {};
  forEach$1(elements, function(element) {
    result[element.id] = element.hidden;
    if (element.children) {
      result = assign$1({}, result, getElementsVisibilityRecursive(element.children));
    }
  });
  return result;
}
function setHiddenRecursive(elements, newHidden) {
  var result = [];
  forEach$1(elements, function(element) {
    element.hidden = newHidden;
    result = result.concat(element);
    if (element.children) {
      result = result.concat(setHiddenRecursive(element.children, element.collapsed || newHidden));
    }
  });
  return result;
}
function restoreVisibilityRecursive(elements, lastState) {
  var result = [];
  forEach$1(elements, function(element) {
    element.hidden = lastState[element.id];
    result = result.concat(element);
    if (element.children) {
      result = result.concat(restoreVisibilityRecursive(element.children, lastState));
    }
  });
  return result;
}
function UpdateAttachmentHandler(modeling) {
  this._modeling = modeling;
}
UpdateAttachmentHandler.$inject = ["modeling"];
UpdateAttachmentHandler.prototype.execute = function(context) {
  var shape = context.shape, newHost = context.newHost, oldHost = shape.host;
  context.oldHost = oldHost;
  context.attacherIdx = removeAttacher(oldHost, shape);
  addAttacher(newHost, shape);
  shape.host = newHost;
  return shape;
};
UpdateAttachmentHandler.prototype.revert = function(context) {
  var shape = context.shape, newHost = context.newHost, oldHost = context.oldHost, attacherIdx = context.attacherIdx;
  shape.host = oldHost;
  removeAttacher(newHost, shape);
  addAttacher(oldHost, shape, attacherIdx);
  return shape;
};
function removeAttacher(host, attacher) {
  return remove(host && host.attachers, attacher);
}
function addAttacher(host, attacher, idx) {
  if (!host) {
    return;
  }
  var attachers = host.attachers;
  if (!attachers) {
    host.attachers = attachers = [];
  }
  add(attachers, attacher, idx);
}
function UpdateWaypointsHandler() {
}
UpdateWaypointsHandler.prototype.execute = function(context) {
  var connection = context.connection, newWaypoints = context.newWaypoints;
  context.oldWaypoints = connection.waypoints;
  connection.waypoints = newWaypoints;
  return connection;
};
UpdateWaypointsHandler.prototype.revert = function(context) {
  var connection = context.connection, oldWaypoints = context.oldWaypoints;
  connection.waypoints = oldWaypoints;
  return connection;
};
function Modeling$1(eventBus, elementFactory, commandStack) {
  this._eventBus = eventBus;
  this._elementFactory = elementFactory;
  this._commandStack = commandStack;
  var self2 = this;
  eventBus.on("diagram.init", function() {
    self2.registerHandlers(commandStack);
  });
}
Modeling$1.$inject = ["eventBus", "elementFactory", "commandStack"];
Modeling$1.prototype.getHandlers = function() {
  return {
    "shape.append": AppendShapeHandler,
    "shape.create": CreateShapeHandler,
    "shape.delete": DeleteShapeHandler,
    "shape.move": MoveShapeHandler,
    "shape.resize": ResizeShapeHandler,
    "shape.replace": ReplaceShapeHandler,
    "shape.toggleCollapse": ToggleShapeCollapseHandler,
    "spaceTool": SpaceToolHandler,
    "label.create": CreateLabelHandler,
    "connection.create": CreateConnectionHandler,
    "connection.delete": DeleteConnectionHandler,
    "connection.move": MoveConnectionHandler,
    "connection.layout": LayoutConnectionHandler,
    "connection.updateWaypoints": UpdateWaypointsHandler,
    "connection.reconnect": ReconnectConnectionHandler,
    "elements.create": CreateElementsHandler,
    "elements.move": MoveElementsHandler,
    "elements.delete": DeleteElementsHandler,
    "elements.distribute": DistributeElements$1,
    "elements.align": AlignElements,
    "element.updateAttachment": UpdateAttachmentHandler
  };
};
Modeling$1.prototype.registerHandlers = function(commandStack) {
  forEach$1(this.getHandlers(), function(handler, id) {
    commandStack.registerHandler(id, handler);
  });
};
Modeling$1.prototype.moveShape = function(shape, delta2, newParent, newParentIndex, hints) {
  if (typeof newParentIndex === "object") {
    hints = newParentIndex;
    newParentIndex = null;
  }
  var context = {
    shape,
    delta: delta2,
    newParent,
    newParentIndex,
    hints: hints || {}
  };
  this._commandStack.execute("shape.move", context);
};
Modeling$1.prototype.updateAttachment = function(shape, newHost) {
  var context = {
    shape,
    newHost
  };
  this._commandStack.execute("element.updateAttachment", context);
};
Modeling$1.prototype.moveElements = function(shapes, delta2, target, hints) {
  hints = hints || {};
  var attach = hints.attach;
  var newParent = target, newHost;
  if (attach === true) {
    newHost = target;
    newParent = target.parent;
  } else if (attach === false) {
    newHost = null;
  }
  var context = {
    shapes,
    delta: delta2,
    newParent,
    newHost,
    hints
  };
  this._commandStack.execute("elements.move", context);
};
Modeling$1.prototype.moveConnection = function(connection, delta2, newParent, newParentIndex, hints) {
  if (typeof newParentIndex === "object") {
    hints = newParentIndex;
    newParentIndex = void 0;
  }
  var context = {
    connection,
    delta: delta2,
    newParent,
    newParentIndex,
    hints: hints || {}
  };
  this._commandStack.execute("connection.move", context);
};
Modeling$1.prototype.layoutConnection = function(connection, hints) {
  var context = {
    connection,
    hints: hints || {}
  };
  this._commandStack.execute("connection.layout", context);
};
Modeling$1.prototype.createConnection = function(source, target, parentIndex, connection, parent, hints) {
  if (typeof parentIndex === "object") {
    hints = parent;
    parent = connection;
    connection = parentIndex;
    parentIndex = void 0;
  }
  connection = this._create("connection", connection);
  var context = {
    source,
    target,
    parent,
    parentIndex,
    connection,
    hints
  };
  this._commandStack.execute("connection.create", context);
  return context.connection;
};
Modeling$1.prototype.createShape = function(shape, position, target, parentIndex, hints) {
  if (typeof parentIndex !== "number") {
    hints = parentIndex;
    parentIndex = void 0;
  }
  hints = hints || {};
  var attach = hints.attach, parent, host;
  shape = this._create("shape", shape);
  if (attach) {
    parent = target.parent;
    host = target;
  } else {
    parent = target;
  }
  var context = {
    position,
    shape,
    parent,
    parentIndex,
    host,
    hints
  };
  this._commandStack.execute("shape.create", context);
  return context.shape;
};
Modeling$1.prototype.createElements = function(elements, position, parent, parentIndex, hints) {
  if (!isArray$3(elements)) {
    elements = [elements];
  }
  if (typeof parentIndex !== "number") {
    hints = parentIndex;
    parentIndex = void 0;
  }
  hints = hints || {};
  var context = {
    position,
    elements,
    parent,
    parentIndex,
    hints
  };
  this._commandStack.execute("elements.create", context);
  return context.elements;
};
Modeling$1.prototype.createLabel = function(labelTarget, position, label, parent) {
  label = this._create("label", label);
  var context = {
    labelTarget,
    position,
    parent: parent || labelTarget.parent,
    shape: label
  };
  this._commandStack.execute("label.create", context);
  return context.shape;
};
Modeling$1.prototype.appendShape = function(source, shape, position, target, hints) {
  hints = hints || {};
  shape = this._create("shape", shape);
  var context = {
    source,
    position,
    target,
    shape,
    connection: hints.connection,
    connectionParent: hints.connectionParent,
    hints
  };
  this._commandStack.execute("shape.append", context);
  return context.shape;
};
Modeling$1.prototype.removeElements = function(elements) {
  var context = {
    elements
  };
  this._commandStack.execute("elements.delete", context);
};
Modeling$1.prototype.distributeElements = function(groups, axis, dimension) {
  var context = {
    groups,
    axis,
    dimension
  };
  this._commandStack.execute("elements.distribute", context);
};
Modeling$1.prototype.removeShape = function(shape, hints) {
  var context = {
    shape,
    hints: hints || {}
  };
  this._commandStack.execute("shape.delete", context);
};
Modeling$1.prototype.removeConnection = function(connection, hints) {
  var context = {
    connection,
    hints: hints || {}
  };
  this._commandStack.execute("connection.delete", context);
};
Modeling$1.prototype.replaceShape = function(oldShape, newShape, hints) {
  var context = {
    oldShape,
    newData: newShape,
    hints: hints || {}
  };
  this._commandStack.execute("shape.replace", context);
  return context.newShape;
};
Modeling$1.prototype.alignElements = function(elements, alignment) {
  var context = {
    elements,
    alignment
  };
  this._commandStack.execute("elements.align", context);
};
Modeling$1.prototype.resizeShape = function(shape, newBounds, minBounds, hints) {
  var context = {
    shape,
    newBounds,
    minBounds,
    hints
  };
  this._commandStack.execute("shape.resize", context);
};
Modeling$1.prototype.createSpace = function(movingShapes, resizingShapes, delta2, direction, start) {
  var context = {
    delta: delta2,
    direction,
    movingShapes,
    resizingShapes,
    start
  };
  this._commandStack.execute("spaceTool", context);
};
Modeling$1.prototype.updateWaypoints = function(connection, newWaypoints, hints) {
  var context = {
    connection,
    newWaypoints,
    hints: hints || {}
  };
  this._commandStack.execute("connection.updateWaypoints", context);
};
Modeling$1.prototype.reconnect = function(connection, source, target, dockingOrPoints, hints) {
  var context = {
    connection,
    newSource: source,
    newTarget: target,
    dockingOrPoints,
    hints: hints || {}
  };
  this._commandStack.execute("connection.reconnect", context);
};
Modeling$1.prototype.reconnectStart = function(connection, newSource, dockingOrPoints, hints) {
  if (!hints) {
    hints = {};
  }
  this.reconnect(connection, newSource, connection.target, dockingOrPoints, assign$1(hints, {
    docking: "source"
  }));
};
Modeling$1.prototype.reconnectEnd = function(connection, newTarget, dockingOrPoints, hints) {
  if (!hints) {
    hints = {};
  }
  this.reconnect(connection, connection.source, newTarget, dockingOrPoints, assign$1(hints, {
    docking: "target"
  }));
};
Modeling$1.prototype.connect = function(source, target, attrs, hints) {
  return this.createConnection(source, target, attrs || {}, source.parent, hints);
};
Modeling$1.prototype._create = function(type, attrs) {
  if (isModelElement(attrs)) {
    return attrs;
  } else {
    return this._elementFactory.create(type, attrs);
  }
};
Modeling$1.prototype.toggleCollapse = function(shape, hints) {
  var context = {
    shape,
    hints: hints || {}
  };
  this._commandStack.execute("shape.toggleCollapse", context);
};
function UpdateModdlePropertiesHandler(elementRegistry) {
  this._elementRegistry = elementRegistry;
}
UpdateModdlePropertiesHandler.$inject = ["elementRegistry"];
UpdateModdlePropertiesHandler.prototype.execute = function(context) {
  var element = context.element, moddleElement = context.moddleElement, properties = context.properties;
  if (!moddleElement) {
    throw new Error("<moddleElement> required");
  }
  var changed = context.changed || this._getVisualReferences(moddleElement).concat(element);
  var oldProperties = context.oldProperties || getModdleProperties(moddleElement, keys(properties));
  setModdleProperties(moddleElement, properties);
  context.oldProperties = oldProperties;
  context.changed = changed;
  return changed;
};
UpdateModdlePropertiesHandler.prototype.revert = function(context) {
  var oldProperties = context.oldProperties, moddleElement = context.moddleElement, changed = context.changed;
  setModdleProperties(moddleElement, oldProperties);
  return changed;
};
UpdateModdlePropertiesHandler.prototype._getVisualReferences = function(moddleElement) {
  var elementRegistry = this._elementRegistry;
  if (is$1(moddleElement, "bpmn:DataObject")) {
    return getAllDataObjectReferences(moddleElement, elementRegistry);
  }
  return [];
};
function getModdleProperties(moddleElement, propertyNames) {
  return reduce(propertyNames, function(result, key) {
    result[key] = moddleElement.get(key);
    return result;
  }, {});
}
function setModdleProperties(moddleElement, properties) {
  forEach$1(properties, function(value, key) {
    moddleElement.set(key, value);
  });
}
function getAllDataObjectReferences(dataObject, elementRegistry) {
  return elementRegistry.filter(function(element) {
    return is$1(element, "bpmn:DataObjectReference") && getBusinessObject(element).dataObjectRef === dataObject;
  });
}
var DEFAULT_FLOW = "default", ID = "id", DI = "di";
var NULL_DIMENSIONS$1 = {
  width: 0,
  height: 0
};
function UpdatePropertiesHandler(elementRegistry, moddle, translate2, modeling, textRenderer) {
  this._elementRegistry = elementRegistry;
  this._moddle = moddle;
  this._translate = translate2;
  this._modeling = modeling;
  this._textRenderer = textRenderer;
}
UpdatePropertiesHandler.$inject = [
  "elementRegistry",
  "moddle",
  "translate",
  "modeling",
  "textRenderer"
];
UpdatePropertiesHandler.prototype.execute = function(context) {
  var element = context.element, changed = [element], translate2 = this._translate;
  if (!element) {
    throw new Error(translate2("element required"));
  }
  var elementRegistry = this._elementRegistry, ids2 = this._moddle.ids;
  var businessObject = element.businessObject, properties = unwrapBusinessObjects(context.properties), oldProperties = context.oldProperties || getProperties(element, properties);
  if (isIdChange(properties, businessObject)) {
    ids2.unclaim(businessObject[ID]);
    elementRegistry.updateId(element, properties[ID]);
    ids2.claim(properties[ID], businessObject);
  }
  if (DEFAULT_FLOW in properties) {
    if (properties[DEFAULT_FLOW]) {
      changed.push(elementRegistry.get(properties[DEFAULT_FLOW].id));
    }
    if (businessObject[DEFAULT_FLOW]) {
      changed.push(elementRegistry.get(businessObject[DEFAULT_FLOW].id));
    }
  }
  setProperties(element, properties);
  context.oldProperties = oldProperties;
  context.changed = changed;
  return changed;
};
UpdatePropertiesHandler.prototype.postExecute = function(context) {
  var element = context.element, label = element.label;
  var text = label && getBusinessObject(label).name;
  if (!text) {
    return;
  }
  var newLabelBounds = this._textRenderer.getExternalLabelBounds(label, text);
  this._modeling.resizeShape(label, newLabelBounds, NULL_DIMENSIONS$1);
};
UpdatePropertiesHandler.prototype.revert = function(context) {
  var element = context.element, properties = context.properties, oldProperties = context.oldProperties, businessObject = element.businessObject, elementRegistry = this._elementRegistry, ids2 = this._moddle.ids;
  setProperties(element, oldProperties);
  if (isIdChange(properties, businessObject)) {
    ids2.unclaim(properties[ID]);
    elementRegistry.updateId(element, oldProperties[ID]);
    ids2.claim(oldProperties[ID], businessObject);
  }
  return context.changed;
};
function isIdChange(properties, businessObject) {
  return ID in properties && properties[ID] !== businessObject[ID];
}
function getProperties(element, properties) {
  var propertyNames = keys(properties), businessObject = element.businessObject, di = getDi(element);
  return reduce(propertyNames, function(result, key) {
    if (key !== DI) {
      result[key] = businessObject.get(key);
    } else {
      result[key] = getDiProperties(di, keys(properties.di));
    }
    return result;
  }, {});
}
function getDiProperties(di, propertyNames) {
  return reduce(propertyNames, function(result, key) {
    result[key] = di && di.get(key);
    return result;
  }, {});
}
function setProperties(element, properties) {
  var businessObject = element.businessObject, di = getDi(element);
  forEach$1(properties, function(value, key) {
    if (key !== DI) {
      businessObject.set(key, value);
    } else {
      if (di) {
        setDiProperties(di, value);
      }
    }
  });
}
function setDiProperties(di, properties) {
  forEach$1(properties, function(value, key) {
    di.set(key, value);
  });
}
var referencePropertyNames = ["default"];
function unwrapBusinessObjects(properties) {
  var unwrappedProps = assign$1({}, properties);
  referencePropertyNames.forEach(function(name2) {
    if (name2 in properties) {
      unwrappedProps[name2] = getBusinessObject(unwrappedProps[name2]);
    }
  });
  return unwrappedProps;
}
function UpdateCanvasRootHandler(canvas, modeling) {
  this._canvas = canvas;
  this._modeling = modeling;
}
UpdateCanvasRootHandler.$inject = [
  "canvas",
  "modeling"
];
UpdateCanvasRootHandler.prototype.execute = function(context) {
  var canvas = this._canvas;
  var newRoot = context.newRoot, newRootBusinessObject = newRoot.businessObject, oldRoot = canvas.getRootElement(), oldRootBusinessObject = oldRoot.businessObject, bpmnDefinitions = oldRootBusinessObject.$parent, diPlane = getDi(oldRoot);
  canvas.setRootElement(newRoot);
  canvas.removeRootElement(oldRoot);
  add(bpmnDefinitions.rootElements, newRootBusinessObject);
  newRootBusinessObject.$parent = bpmnDefinitions;
  remove(bpmnDefinitions.rootElements, oldRootBusinessObject);
  oldRootBusinessObject.$parent = null;
  oldRoot.di = null;
  diPlane.bpmnElement = newRootBusinessObject;
  newRoot.di = diPlane;
  context.oldRoot = oldRoot;
  return [];
};
UpdateCanvasRootHandler.prototype.revert = function(context) {
  var canvas = this._canvas;
  var newRoot = context.newRoot, newRootBusinessObject = newRoot.businessObject, oldRoot = context.oldRoot, oldRootBusinessObject = oldRoot.businessObject, bpmnDefinitions = newRootBusinessObject.$parent, diPlane = getDi(newRoot);
  canvas.setRootElement(oldRoot);
  canvas.removeRootElement(newRoot);
  remove(bpmnDefinitions.rootElements, newRootBusinessObject);
  newRootBusinessObject.$parent = null;
  add(bpmnDefinitions.rootElements, oldRootBusinessObject);
  oldRootBusinessObject.$parent = bpmnDefinitions;
  newRoot.di = null;
  diPlane.bpmnElement = oldRootBusinessObject;
  oldRoot.di = diPlane;
  return [];
};
function AddLaneHandler(modeling, spaceTool) {
  this._modeling = modeling;
  this._spaceTool = spaceTool;
}
AddLaneHandler.$inject = [
  "modeling",
  "spaceTool"
];
AddLaneHandler.prototype.preExecute = function(context) {
  var spaceTool = this._spaceTool, modeling = this._modeling;
  var shape = context.shape, location = context.location;
  var lanesRoot = getLanesRoot(shape);
  var isRoot = lanesRoot === shape, laneParent = isRoot ? shape : shape.parent;
  var existingChildLanes = getChildLanes(laneParent);
  var isHorizontalLane = isHorizontal$3(shape);
  if (isHorizontalLane) {
    if (location === "left") {
      location = "top";
    } else if (location === "right") {
      location = "bottom";
    }
  } else {
    if (location === "top") {
      location = "left";
    } else if (location === "bottom") {
      location = "right";
    }
  }
  if (!existingChildLanes.length) {
    var siblingPosition = isHorizontalLane ? {
      x: shape.x + LANE_INDENTATION,
      y: shape.y,
      width: shape.width - LANE_INDENTATION,
      height: shape.height
    } : {
      x: shape.x,
      y: shape.y + LANE_INDENTATION,
      width: shape.width,
      height: shape.height - LANE_INDENTATION
    };
    modeling.createShape(
      {
        type: "bpmn:Lane",
        isHorizontal: isHorizontalLane
      },
      siblingPosition,
      laneParent
    );
  }
  var allAffected = [];
  eachElement(lanesRoot, function(element) {
    allAffected.push(element);
    if (element.label) {
      allAffected.push(element.label);
    }
    if (element === shape) {
      return [];
    }
    return filter(element.children, function(c2) {
      return c2 !== shape;
    });
  });
  var offset, lanePosition, spacePos, direction, axis;
  if (location === "top") {
    offset = -120;
    lanePosition = shape.y;
    spacePos = lanePosition + 10;
    direction = "n";
    axis = "y";
  } else if (location === "left") {
    offset = -120;
    lanePosition = shape.x;
    spacePos = lanePosition + 10;
    direction = "w";
    axis = "x";
  } else if (location === "bottom") {
    offset = 120;
    lanePosition = shape.y + shape.height;
    spacePos = lanePosition - 10;
    direction = "s";
    axis = "y";
  } else if (location === "right") {
    offset = 120;
    lanePosition = shape.x + shape.width;
    spacePos = lanePosition - 10;
    direction = "e";
    axis = "x";
  }
  var adjustments = spaceTool.calculateAdjustments(allAffected, axis, offset, spacePos);
  var delta2 = isHorizontalLane ? { x: 0, y: offset } : { x: offset, y: 0 };
  spaceTool.makeSpace(
    adjustments.movingShapes,
    adjustments.resizingShapes,
    delta2,
    direction,
    spacePos
  );
  var newLanePosition = isHorizontalLane ? {
    x: shape.x + (isRoot ? LANE_INDENTATION : 0),
    y: lanePosition - (location === "top" ? 120 : 0),
    width: shape.width - (isRoot ? LANE_INDENTATION : 0),
    height: 120
  } : {
    x: lanePosition - (location === "left" ? 120 : 0),
    y: shape.y + (isRoot ? LANE_INDENTATION : 0),
    width: 120,
    height: shape.height - (isRoot ? LANE_INDENTATION : 0)
  };
  context.newLane = modeling.createShape(
    {
      type: "bpmn:Lane",
      isHorizontal: isHorizontalLane
    },
    newLanePosition,
    laneParent
  );
};
function SplitLaneHandler(modeling, translate2) {
  this._modeling = modeling;
  this._translate = translate2;
}
SplitLaneHandler.$inject = [
  "modeling",
  "translate"
];
SplitLaneHandler.prototype.preExecute = function(context) {
  var modeling = this._modeling, translate2 = this._translate;
  var shape = context.shape, newLanesCount = context.count;
  var childLanes = getChildLanes(shape), existingLanesCount = childLanes.length;
  if (existingLanesCount > newLanesCount) {
    throw new Error(translate2("more than {count} child lanes", { count: newLanesCount }));
  }
  var isHorizontalLane = isHorizontal$3(shape);
  var laneBaseSize = isHorizontalLane ? shape.height : shape.width;
  var newLanesSize = Math.round(laneBaseSize / newLanesCount);
  var laneSize, laneBounds, newLaneAttrs, idx;
  for (idx = 0; idx < newLanesCount; idx++) {
    if (idx === newLanesCount - 1) {
      laneSize = laneBaseSize - newLanesSize * idx;
    } else {
      laneSize = newLanesSize;
    }
    laneBounds = isHorizontalLane ? {
      x: shape.x + LANE_INDENTATION,
      y: shape.y + idx * newLanesSize,
      width: shape.width - LANE_INDENTATION,
      height: laneSize
    } : {
      x: shape.x + idx * newLanesSize,
      y: shape.y + LANE_INDENTATION,
      width: laneSize,
      height: shape.height - LANE_INDENTATION
    };
    if (idx < existingLanesCount) {
      modeling.resizeShape(childLanes[idx], laneBounds);
    } else {
      newLaneAttrs = {
        type: "bpmn:Lane",
        isHorizontal: isHorizontalLane
      };
      modeling.createShape(newLaneAttrs, laneBounds, shape);
    }
  }
};
function ResizeLaneHandler(modeling, spaceTool) {
  this._modeling = modeling;
  this._spaceTool = spaceTool;
}
ResizeLaneHandler.$inject = [
  "modeling",
  "spaceTool"
];
ResizeLaneHandler.prototype.preExecute = function(context) {
  var shape = context.shape, newBounds = context.newBounds, balanced = context.balanced;
  if (balanced !== false) {
    this.resizeBalanced(shape, newBounds);
  } else {
    this.resizeSpace(shape, newBounds);
  }
};
ResizeLaneHandler.prototype.resizeBalanced = function(shape, newBounds) {
  var modeling = this._modeling;
  var resizeNeeded = computeLanesResize(shape, newBounds);
  modeling.resizeShape(shape, newBounds);
  resizeNeeded.forEach(function(r2) {
    modeling.resizeShape(r2.shape, r2.newBounds);
  });
};
ResizeLaneHandler.prototype.resizeSpace = function(shape, newBounds) {
  var spaceTool = this._spaceTool;
  var shapeTrbl = asTRBL(shape), newTrbl = asTRBL(newBounds);
  var trblDiff = substractTRBL(newTrbl, shapeTrbl);
  var lanesRoot = getLanesRoot(shape);
  var allAffected = [], allLanes = [];
  eachElement(lanesRoot, function(element) {
    allAffected.push(element);
    if (is$1(element, "bpmn:Lane") || is$1(element, "bpmn:Participant")) {
      allLanes.push(element);
    }
    return element.children;
  });
  var change, spacePos, direction, offset, adjustments;
  if (trblDiff.bottom || trblDiff.top) {
    change = trblDiff.bottom || trblDiff.top;
    spacePos = shape.y + (trblDiff.bottom ? shape.height : 0) + (trblDiff.bottom ? -10 : 10);
    direction = trblDiff.bottom ? "s" : "n";
    offset = trblDiff.top > 0 || trblDiff.bottom < 0 ? -change : change;
    adjustments = spaceTool.calculateAdjustments(allAffected, "y", offset, spacePos);
    spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: 0, y: change }, direction);
  }
  if (trblDiff.left || trblDiff.right) {
    change = trblDiff.right || trblDiff.left;
    spacePos = shape.x + (trblDiff.right ? shape.width : 0) + (trblDiff.right ? -10 : 100);
    direction = trblDiff.right ? "e" : "w";
    offset = trblDiff.left > 0 || trblDiff.right < 0 ? -change : change;
    adjustments = spaceTool.calculateAdjustments(allLanes, "x", offset, spacePos);
    spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: change, y: 0 }, direction);
  }
};
var FLOW_NODE_REFS_ATTR = "flowNodeRef", LANES_ATTR = "lanes";
function UpdateFlowNodeRefsHandler(elementRegistry) {
  this._elementRegistry = elementRegistry;
}
UpdateFlowNodeRefsHandler.$inject = [
  "elementRegistry"
];
UpdateFlowNodeRefsHandler.prototype._computeUpdates = function(flowNodeShapes, laneShapes) {
  var handledNodes = [];
  var updates = [];
  var participantCache = {};
  var allFlowNodeShapes = [];
  function isInLaneShape(element, laneShape) {
    var laneTrbl = asTRBL(laneShape);
    var elementMid = {
      x: element.x + element.width / 2,
      y: element.y + element.height / 2
    };
    return elementMid.x > laneTrbl.left && elementMid.x < laneTrbl.right && elementMid.y > laneTrbl.top && elementMid.y < laneTrbl.bottom;
  }
  function addFlowNodeShape(flowNodeShape) {
    if (handledNodes.indexOf(flowNodeShape) === -1) {
      allFlowNodeShapes.push(flowNodeShape);
      handledNodes.push(flowNodeShape);
    }
  }
  function getAllLaneShapes(flowNodeShape) {
    var root = getLanesRoot(flowNodeShape);
    if (!participantCache[root.id]) {
      participantCache[root.id] = collectLanes(root);
    }
    return participantCache[root.id];
  }
  function getNewLanes(flowNodeShape) {
    if (!flowNodeShape.parent) {
      return [];
    }
    var allLaneShapes = getAllLaneShapes(flowNodeShape);
    return allLaneShapes.filter(function(l2) {
      return isInLaneShape(flowNodeShape, l2);
    }).map(function(shape) {
      return shape.businessObject;
    });
  }
  laneShapes.forEach(function(laneShape) {
    var root = getLanesRoot(laneShape);
    if (!root || handledNodes.indexOf(root) !== -1) {
      return;
    }
    var children = root.children.filter(function(c2) {
      return is$1(c2, "bpmn:FlowNode");
    });
    children.forEach(addFlowNodeShape);
    handledNodes.push(root);
  });
  flowNodeShapes.forEach(addFlowNodeShape);
  allFlowNodeShapes.forEach(function(flowNodeShape) {
    var flowNode = flowNodeShape.businessObject;
    var lanes = flowNode.get(LANES_ATTR), remove2 = lanes.slice(), add2 = getNewLanes(flowNodeShape);
    updates.push({ flowNode, remove: remove2, add: add2 });
  });
  laneShapes.forEach(function(laneShape) {
    var lane = laneShape.businessObject;
    if (!laneShape.parent) {
      lane.get(FLOW_NODE_REFS_ATTR).forEach(function(flowNode) {
        updates.push({ flowNode, remove: [lane], add: [] });
      });
    }
  });
  return updates;
};
UpdateFlowNodeRefsHandler.prototype.execute = function(context) {
  var updates = context.updates;
  if (!updates) {
    updates = context.updates = this._computeUpdates(context.flowNodeShapes, context.laneShapes);
  }
  updates.forEach(function(update) {
    var flowNode = update.flowNode, lanes = flowNode.get(LANES_ATTR);
    update.remove.forEach(function(oldLane) {
      remove(lanes, oldLane);
      remove(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);
    });
    update.add.forEach(function(newLane) {
      add(lanes, newLane);
      add(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);
    });
  });
  return [];
};
UpdateFlowNodeRefsHandler.prototype.revert = function(context) {
  var updates = context.updates;
  updates.forEach(function(update) {
    var flowNode = update.flowNode, lanes = flowNode.get(LANES_ATTR);
    update.add.forEach(function(newLane) {
      remove(lanes, newLane);
      remove(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);
    });
    update.remove.forEach(function(oldLane) {
      add(lanes, oldLane);
      add(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);
    });
  });
  return [];
};
function IdClaimHandler(moddle) {
  this._moddle = moddle;
}
IdClaimHandler.$inject = ["moddle"];
IdClaimHandler.prototype.execute = function(context) {
  var ids2 = this._moddle.ids, id = context.id, element = context.element, claiming = context.claiming;
  if (claiming) {
    ids2.claim(id, element);
  } else {
    ids2.unclaim(id);
  }
  return [];
};
IdClaimHandler.prototype.revert = function(context) {
  var ids2 = this._moddle.ids, id = context.id, element = context.element, claiming = context.claiming;
  if (claiming) {
    ids2.unclaim(id);
  } else {
    ids2.claim(id, element);
  }
  return [];
};
var DEFAULT_COLORS = {
  fill: void 0,
  stroke: void 0
};
function SetColorHandler(commandStack) {
  this._commandStack = commandStack;
  this._normalizeColor = function(color) {
    if (!color) {
      return void 0;
    }
    if (isString(color)) {
      var hexColor = colorToHex(color);
      if (hexColor) {
        return hexColor;
      }
    }
    throw new Error("invalid color value: " + color);
  };
}
SetColorHandler.$inject = [
  "commandStack"
];
SetColorHandler.prototype.postExecute = function(context) {
  var elements = context.elements, colors = context.colors || DEFAULT_COLORS;
  var self2 = this;
  var di = {};
  if ("fill" in colors) {
    assign$1(di, {
      "background-color": this._normalizeColor(colors.fill)
    });
  }
  if ("stroke" in colors) {
    assign$1(di, {
      "border-color": this._normalizeColor(colors.stroke)
    });
  }
  forEach$1(elements, function(element) {
    var assignedDi = isConnection(element) ? pick(di, ["border-color"]) : di, elementDi = getDi(element);
    ensureLegacySupport(assignedDi);
    if (isLabel(element)) {
      self2._commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: elementDi.label,
        properties: {
          color: di["border-color"]
        }
      });
    } else {
      if (!isAny(elementDi, ["bpmndi:BPMNEdge", "bpmndi:BPMNShape"])) {
        return;
      }
      self2._commandStack.execute("element.updateProperties", {
        element,
        properties: {
          di: assignedDi
        }
      });
    }
  });
};
function colorToHex(color) {
  var context = document.createElement("canvas").getContext("2d");
  context.fillStyle = "transparent";
  context.fillStyle = color;
  return /^#[0-9a-fA-F]{6}$/.test(context.fillStyle) ? context.fillStyle : null;
}
function ensureLegacySupport(di) {
  if ("border-color" in di) {
    di.stroke = di["border-color"];
  }
  if ("background-color" in di) {
    di.fill = di["background-color"];
  }
}
var NULL_DIMENSIONS = {
  width: 0,
  height: 0
};
function UpdateLabelHandler(modeling, textRenderer, bpmnFactory) {
  function setText(element, text) {
    var label = element.label || element;
    var labelTarget = element.labelTarget || element;
    setLabel(label, text);
    return [label, labelTarget];
  }
  function preExecute(ctx) {
    var element = ctx.element, businessObject = element.businessObject, newLabel = ctx.newLabel;
    if (!isLabel(element) && isLabelExternal(element) && !hasExternalLabel(element) && !isEmptyText$1(newLabel)) {
      var paddingTop = 7;
      var labelCenter = getExternalLabelMid(element);
      labelCenter = {
        x: labelCenter.x,
        y: labelCenter.y + paddingTop
      };
      modeling.createLabel(element, labelCenter, {
        id: businessObject.id + "_label",
        businessObject,
        di: element.di
      });
    }
  }
  function execute(ctx) {
    ctx.oldLabel = getLabel(ctx.element);
    return setText(ctx.element, ctx.newLabel);
  }
  function revert(ctx) {
    return setText(ctx.element, ctx.oldLabel);
  }
  function postExecute(ctx) {
    var element = ctx.element, label = element.label || element, newLabel = ctx.newLabel, newBounds = ctx.newBounds, hints = ctx.hints || {};
    if (!isLabel(label) && !is$1(label, "bpmn:TextAnnotation")) {
      return;
    }
    if (isLabel(label) && isEmptyText$1(newLabel)) {
      if (hints.removeShape !== false) {
        modeling.removeShape(label, { unsetLabel: false });
      }
      return;
    }
    var text = getLabel(element);
    if (typeof newBounds === "undefined") {
      newBounds = textRenderer.getExternalLabelBounds(label, text);
    }
    if (newBounds) {
      modeling.resizeShape(label, newBounds, NULL_DIMENSIONS);
    }
  }
  this.preExecute = preExecute;
  this.execute = execute;
  this.revert = revert;
  this.postExecute = postExecute;
}
UpdateLabelHandler.$inject = [
  "modeling",
  "textRenderer",
  "bpmnFactory"
];
function isEmptyText$1(label) {
  return !label || !label.trim();
}
function Modeling(eventBus, elementFactory, commandStack, bpmnRules) {
  Modeling$1.call(this, eventBus, elementFactory, commandStack);
  this._bpmnRules = bpmnRules;
}
e$3(Modeling, Modeling$1);
Modeling.$inject = [
  "eventBus",
  "elementFactory",
  "commandStack",
  "bpmnRules"
];
Modeling.prototype.getHandlers = function() {
  var handlers = Modeling$1.prototype.getHandlers.call(this);
  handlers["element.updateModdleProperties"] = UpdateModdlePropertiesHandler;
  handlers["element.updateProperties"] = UpdatePropertiesHandler;
  handlers["canvas.updateRoot"] = UpdateCanvasRootHandler;
  handlers["lane.add"] = AddLaneHandler;
  handlers["lane.resize"] = ResizeLaneHandler;
  handlers["lane.split"] = SplitLaneHandler;
  handlers["lane.updateRefs"] = UpdateFlowNodeRefsHandler;
  handlers["id.updateClaim"] = IdClaimHandler;
  handlers["element.setColor"] = SetColorHandler;
  handlers["element.updateLabel"] = UpdateLabelHandler;
  return handlers;
};
Modeling.prototype.updateLabel = function(element, newLabel, newBounds, hints) {
  this._commandStack.execute("element.updateLabel", {
    element,
    newLabel,
    newBounds,
    hints: hints || {}
  });
};
Modeling.prototype.connect = function(source, target, attrs, hints) {
  var bpmnRules = this._bpmnRules;
  if (!attrs) {
    attrs = bpmnRules.canConnect(source, target);
  }
  if (!attrs) {
    return;
  }
  return this.createConnection(source, target, attrs, source.parent, hints);
};
Modeling.prototype.updateModdleProperties = function(element, moddleElement, properties) {
  this._commandStack.execute("element.updateModdleProperties", {
    element,
    moddleElement,
    properties
  });
};
Modeling.prototype.updateProperties = function(element, properties) {
  this._commandStack.execute("element.updateProperties", {
    element,
    properties
  });
};
Modeling.prototype.resizeLane = function(laneShape, newBounds, balanced) {
  this._commandStack.execute("lane.resize", {
    shape: laneShape,
    newBounds,
    balanced
  });
};
Modeling.prototype.addLane = function(targetLaneShape, location) {
  var context = {
    shape: targetLaneShape,
    location
  };
  this._commandStack.execute("lane.add", context);
  return context.newLane;
};
Modeling.prototype.splitLane = function(targetLane, count) {
  this._commandStack.execute("lane.split", {
    shape: targetLane,
    count
  });
};
Modeling.prototype.makeCollaboration = function() {
  var collaborationElement = this._create("root", {
    type: "bpmn:Collaboration"
  });
  var context = {
    newRoot: collaborationElement
  };
  this._commandStack.execute("canvas.updateRoot", context);
  return collaborationElement;
};
Modeling.prototype.makeProcess = function() {
  var processElement = this._create("root", {
    type: "bpmn:Process"
  });
  var context = {
    newRoot: processElement
  };
  this._commandStack.execute("canvas.updateRoot", context);
};
Modeling.prototype.updateLaneRefs = function(flowNodeShapes, laneShapes) {
  this._commandStack.execute("lane.updateRefs", {
    flowNodeShapes,
    laneShapes
  });
};
Modeling.prototype.claimId = function(id, moddleElement) {
  this._commandStack.execute("id.updateClaim", {
    id,
    element: moddleElement,
    claiming: true
  });
};
Modeling.prototype.unclaimId = function(id, moddleElement) {
  this._commandStack.execute("id.updateClaim", {
    id,
    element: moddleElement
  });
};
Modeling.prototype.setColor = function(elements, colors) {
  if (!elements.length) {
    elements = [elements];
  }
  this._commandStack.execute("element.setColor", {
    elements,
    colors
  });
};
function BaseLayouter() {
}
BaseLayouter.prototype.layoutConnection = function(connection, hints) {
  hints = hints || {};
  return [
    hints.connectionStart || getMid(hints.source || connection.source),
    hints.connectionEnd || getMid(hints.target || connection.target)
  ];
};
var MIN_SEGMENT_LENGTH = 20, POINT_ORIENTATION_PADDING = 5;
var round$2 = Math.round;
var INTERSECTION_THRESHOLD = 20, ORIENTATION_THRESHOLD = {
  "h:h": 20,
  "v:v": 20,
  "h:v": -10,
  "v:h": -10
};
function needsTurn(orientation, startDirection) {
  return !{
    t: /top/,
    r: /right/,
    b: /bottom/,
    l: /left/,
    h: /./,
    v: /./
  }[startDirection].test(orientation);
}
function canLayoutStraight(direction, targetOrientation) {
  return {
    t: /top/,
    r: /right/,
    b: /bottom/,
    l: /left/,
    h: /left|right/,
    v: /top|bottom/
  }[direction].test(targetOrientation);
}
function getSegmentBendpoints(a2, b2, directions2) {
  var orientation = getOrientation(b2, a2, POINT_ORIENTATION_PADDING);
  var startDirection = directions2.split(":")[0];
  var xmid = round$2((b2.x - a2.x) / 2 + a2.x), ymid = round$2((b2.y - a2.y) / 2 + a2.y);
  var segmentEnd, segmentDirections;
  var layoutStraight = canLayoutStraight(startDirection, orientation), layoutHorizontal = /h|r|l/.test(startDirection), layoutTurn = false;
  var turnNextDirections = false;
  if (layoutStraight) {
    segmentEnd = layoutHorizontal ? { x: xmid, y: a2.y } : { x: a2.x, y: ymid };
    segmentDirections = layoutHorizontal ? "h:h" : "v:v";
  } else {
    layoutTurn = needsTurn(orientation, startDirection);
    segmentDirections = layoutHorizontal ? "h:v" : "v:h";
    if (layoutTurn) {
      if (layoutHorizontal) {
        turnNextDirections = ymid === a2.y;
        segmentEnd = {
          x: a2.x + MIN_SEGMENT_LENGTH * (/l/.test(startDirection) ? -1 : 1),
          y: turnNextDirections ? ymid + MIN_SEGMENT_LENGTH : ymid
        };
      } else {
        turnNextDirections = xmid === a2.x;
        segmentEnd = {
          x: turnNextDirections ? xmid + MIN_SEGMENT_LENGTH : xmid,
          y: a2.y + MIN_SEGMENT_LENGTH * (/t/.test(startDirection) ? -1 : 1)
        };
      }
    } else {
      segmentEnd = {
        x: xmid,
        y: ymid
      };
    }
  }
  return {
    waypoints: getBendpoints(a2, segmentEnd, segmentDirections).concat(segmentEnd),
    directions: segmentDirections,
    turnNextDirections
  };
}
function getStartSegment(a2, b2, directions2) {
  return getSegmentBendpoints(a2, b2, directions2);
}
function getEndSegment(a2, b2, directions2) {
  var invertedSegment = getSegmentBendpoints(b2, a2, invertDirections(directions2));
  return {
    waypoints: invertedSegment.waypoints.slice().reverse(),
    directions: invertDirections(invertedSegment.directions),
    turnNextDirections: invertedSegment.turnNextDirections
  };
}
function getMidSegment(startSegment, endSegment) {
  var startDirection = startSegment.directions.split(":")[1], endDirection = endSegment.directions.split(":")[0];
  if (startSegment.turnNextDirections) {
    startDirection = startDirection == "h" ? "v" : "h";
  }
  if (endSegment.turnNextDirections) {
    endDirection = endDirection == "h" ? "v" : "h";
  }
  var directions2 = startDirection + ":" + endDirection;
  var bendpoints = getBendpoints(
    startSegment.waypoints[startSegment.waypoints.length - 1],
    endSegment.waypoints[0],
    directions2
  );
  return {
    waypoints: bendpoints,
    directions: directions2
  };
}
function invertDirections(directions2) {
  return directions2.split(":").reverse().join(":");
}
function getSimpleBendpoints(a2, b2, directions2) {
  var xmid = round$2((b2.x - a2.x) / 2 + a2.x), ymid = round$2((b2.y - a2.y) / 2 + a2.y);
  if (directions2 === "h:v") {
    return [{ x: b2.x, y: a2.y }];
  }
  if (directions2 === "v:h") {
    return [{ x: a2.x, y: b2.y }];
  }
  if (directions2 === "h:h") {
    return [
      { x: xmid, y: a2.y },
      { x: xmid, y: b2.y }
    ];
  }
  if (directions2 === "v:v") {
    return [
      { x: a2.x, y: ymid },
      { x: b2.x, y: ymid }
    ];
  }
  throw new Error("invalid directions: can only handle varians of [hv]:[hv]");
}
function getBendpoints(a2, b2, directions2) {
  directions2 = directions2 || "h:h";
  if (!isValidDirections(directions2)) {
    throw new Error(
      "unknown directions: <" + directions2 + ">: must be specified as <start>:<end> with start/end in { h,v,t,r,b,l }"
    );
  }
  if (isExplicitDirections(directions2)) {
    var startSegment = getStartSegment(a2, b2, directions2), endSegment = getEndSegment(a2, b2, directions2), midSegment = getMidSegment(startSegment, endSegment);
    return [].concat(
      startSegment.waypoints,
      midSegment.waypoints,
      endSegment.waypoints
    );
  }
  return getSimpleBendpoints(a2, b2, directions2);
}
function connectPoints(a2, b2, directions2) {
  var points = getBendpoints(a2, b2, directions2);
  points.unshift(a2);
  points.push(b2);
  return withoutRedundantPoints(points);
}
function connectRectangles(source, target, start, end, hints) {
  var preferredLayouts = hints && hints.preferredLayouts || [];
  var preferredLayout = without(preferredLayouts, "straight")[0] || "h:h";
  var threshold = ORIENTATION_THRESHOLD[preferredLayout] || 0;
  var orientation = getOrientation(source, target, threshold);
  var directions2 = getDirections(orientation, preferredLayout);
  start = start || getMid(source);
  end = end || getMid(target);
  var directionSplit = directions2.split(":");
  var startDocking = getDockingPoint(start, source, directionSplit[0], invertOrientation(orientation)), endDocking = getDockingPoint(end, target, directionSplit[1], orientation);
  return connectPoints(startDocking, endDocking, directions2);
}
function repairConnection(source, target, start, end, waypoints, hints) {
  if (isArray$3(start)) {
    waypoints = start;
    hints = end;
    start = getMid(source);
    end = getMid(target);
  }
  hints = assign$1({ preferredLayouts: [] }, hints);
  waypoints = waypoints || [];
  var preferredLayouts = hints.preferredLayouts, preferStraight = preferredLayouts.indexOf("straight") !== -1, repairedWaypoints;
  repairedWaypoints = preferStraight && tryLayoutStraight(source, target, start, end, hints);
  if (repairedWaypoints) {
    return repairedWaypoints;
  }
  repairedWaypoints = hints.connectionEnd && tryRepairConnectionEnd(target, source, end, waypoints);
  if (repairedWaypoints) {
    return repairedWaypoints;
  }
  repairedWaypoints = hints.connectionStart && tryRepairConnectionStart(source, target, start, waypoints);
  if (repairedWaypoints) {
    return repairedWaypoints;
  }
  if (!hints.connectionStart && !hints.connectionEnd && waypoints && waypoints.length) {
    return waypoints;
  }
  return connectRectangles(source, target, start, end, hints);
}
function inRange(a2, start, end) {
  return a2 >= start && a2 <= end;
}
function isInRange(axis, a2, b2) {
  var size2 = {
    x: "width",
    y: "height"
  };
  return inRange(a2[axis], b2[axis], b2[axis] + b2[size2[axis]]);
}
function tryLayoutStraight(source, target, start, end, hints) {
  var axis = {}, primaryAxis, orientation;
  orientation = getOrientation(source, target);
  if (!/^(top|bottom|left|right)$/.test(orientation)) {
    return null;
  }
  if (/top|bottom/.test(orientation)) {
    primaryAxis = "x";
  }
  if (/left|right/.test(orientation)) {
    primaryAxis = "y";
  }
  if (hints.preserveDocking === "target") {
    if (!isInRange(primaryAxis, end, source)) {
      return null;
    }
    axis[primaryAxis] = end[primaryAxis];
    return [
      {
        x: axis.x !== void 0 ? axis.x : start.x,
        y: axis.y !== void 0 ? axis.y : start.y,
        original: {
          x: axis.x !== void 0 ? axis.x : start.x,
          y: axis.y !== void 0 ? axis.y : start.y
        }
      },
      {
        x: end.x,
        y: end.y
      }
    ];
  } else {
    if (!isInRange(primaryAxis, start, target)) {
      return null;
    }
    axis[primaryAxis] = start[primaryAxis];
    return [
      {
        x: start.x,
        y: start.y
      },
      {
        x: axis.x !== void 0 ? axis.x : end.x,
        y: axis.y !== void 0 ? axis.y : end.y,
        original: {
          x: axis.x !== void 0 ? axis.x : end.x,
          y: axis.y !== void 0 ? axis.y : end.y
        }
      }
    ];
  }
}
function tryRepairConnectionStart(moved, other, newDocking, points) {
  return _tryRepairConnectionSide(moved, other, newDocking, points);
}
function tryRepairConnectionEnd(moved, other, newDocking, points) {
  var waypoints = points.slice().reverse();
  waypoints = _tryRepairConnectionSide(moved, other, newDocking, waypoints);
  return waypoints ? waypoints.reverse() : null;
}
function _tryRepairConnectionSide(moved, other, newDocking, points) {
  function needsRelayout(points2) {
    if (points2.length < 3) {
      return true;
    }
    if (points2.length > 4) {
      return false;
    }
    return !!find(points2, function(p2, idx) {
      var q2 = points2[idx - 1];
      return q2 && pointDistance(p2, q2) < 3;
    });
  }
  function repairBendpoint(candidate, oldPeer, newPeer) {
    var alignment = pointsAligned(oldPeer, candidate);
    switch (alignment) {
      case "v":
        return { x: newPeer.x, y: candidate.y };
      case "h":
        return { x: candidate.x, y: newPeer.y };
    }
    return { x: candidate.x, y: candidate.y };
  }
  function removeOverlapping(points2, a2, b2) {
    var i2;
    for (i2 = points2.length - 2; i2 !== 0; i2--) {
      if (pointInRect(points2[i2], a2, INTERSECTION_THRESHOLD) || pointInRect(points2[i2], b2, INTERSECTION_THRESHOLD)) {
        return points2.slice(i2);
      }
    }
    return points2;
  }
  if (needsRelayout(points)) {
    return null;
  }
  var oldDocking = points[0], newPoints = points.slice(), slicedPoints;
  newPoints[0] = newDocking;
  newPoints[1] = repairBendpoint(newPoints[1], oldDocking, newDocking);
  slicedPoints = removeOverlapping(newPoints, moved, other);
  if (slicedPoints !== newPoints) {
    newPoints = _tryRepairConnectionSide(moved, other, newDocking, slicedPoints);
  }
  if (newPoints && pointsAligned(newPoints)) {
    return null;
  }
  return newPoints;
}
function getDirections(orientation, defaultLayout) {
  if (isExplicitDirections(defaultLayout)) {
    return defaultLayout;
  }
  switch (orientation) {
    case "intersect":
      return "t:t";
    case "top":
    case "bottom":
      return "v:v";
    case "left":
    case "right":
      return "h:h";
    default:
      return defaultLayout;
  }
}
function isValidDirections(directions2) {
  return directions2 && /^h|v|t|r|b|l:h|v|t|r|b|l$/.test(directions2);
}
function isExplicitDirections(directions2) {
  return directions2 && /t|r|b|l/.test(directions2);
}
function invertOrientation(orientation) {
  return {
    "top": "bottom",
    "bottom": "top",
    "left": "right",
    "right": "left",
    "top-left": "bottom-right",
    "bottom-right": "top-left",
    "top-right": "bottom-left",
    "bottom-left": "top-right"
  }[orientation];
}
function getDockingPoint(point, rectangle, dockingDirection, targetOrientation) {
  if (dockingDirection === "h") {
    dockingDirection = /left/.test(targetOrientation) ? "l" : "r";
  }
  if (dockingDirection === "v") {
    dockingDirection = /top/.test(targetOrientation) ? "t" : "b";
  }
  if (dockingDirection === "t") {
    return { original: point, x: point.x, y: rectangle.y };
  }
  if (dockingDirection === "r") {
    return { original: point, x: rectangle.x + rectangle.width, y: point.y };
  }
  if (dockingDirection === "b") {
    return { original: point, x: point.x, y: rectangle.y + rectangle.height };
  }
  if (dockingDirection === "l") {
    return { original: point, x: rectangle.x, y: point.y };
  }
  throw new Error("unexpected dockingDirection: <" + dockingDirection + ">");
}
function withoutRedundantPoints(waypoints) {
  return waypoints.reduce(function(points, p2, idx) {
    var previous = points[points.length - 1], next = waypoints[idx + 1];
    if (!pointsOnLine(previous, next, p2, 0)) {
      points.push(p2);
    }
    return points;
  }, []);
}
var ATTACH_ORIENTATION_PADDING = -10, BOUNDARY_TO_HOST_THRESHOLD$1 = 40;
var oppositeOrientationMapping = {
  "top": "bottom",
  "top-right": "bottom-left",
  "top-left": "bottom-right",
  "right": "left",
  "bottom": "top",
  "bottom-right": "top-left",
  "bottom-left": "top-right",
  "left": "right"
};
var orientationDirectionMapping = {
  top: "t",
  right: "r",
  bottom: "b",
  left: "l"
};
function BpmnLayouter() {
}
e$3(BpmnLayouter, BaseLayouter);
BpmnLayouter.prototype.layoutConnection = function(connection, hints) {
  if (!hints) {
    hints = {};
  }
  var source = hints.source || connection.source, target = hints.target || connection.target, waypoints = hints.waypoints || connection.waypoints, connectionStart = hints.connectionStart, connectionEnd = hints.connectionEnd;
  var manhattanOptions, updatedWaypoints;
  if (!connectionStart) {
    connectionStart = getConnectionDocking(waypoints && waypoints[0], source);
  }
  if (!connectionEnd) {
    connectionEnd = getConnectionDocking(waypoints && waypoints[waypoints.length - 1], target);
  }
  if (is$1(connection, "bpmn:Association") || is$1(connection, "bpmn:DataAssociation")) {
    if (waypoints && !isCompensationAssociation(source, target)) {
      return [].concat([connectionStart], waypoints.slice(1, -1), [connectionEnd]);
    }
  }
  if (is$1(connection, "bpmn:MessageFlow")) {
    manhattanOptions = getMessageFlowManhattanOptions(source, target);
  } else if (is$1(connection, "bpmn:SequenceFlow") || isCompensationAssociation(source, target)) {
    if (source === target) {
      manhattanOptions = {
        preferredLayouts: getLoopPreferredLayout(source, connection)
      };
    } else if (is$1(source, "bpmn:BoundaryEvent")) {
      manhattanOptions = {
        preferredLayouts: getBoundaryEventPreferredLayouts(source, target, connectionEnd)
      };
    } else if (isExpandedSubProcess$1(source) || isExpandedSubProcess$1(target)) {
      manhattanOptions = getSubProcessManhattanOptions(source);
    } else if (is$1(source, "bpmn:Gateway")) {
      manhattanOptions = {
        preferredLayouts: ["v:h"]
      };
    } else if (is$1(target, "bpmn:Gateway")) {
      manhattanOptions = {
        preferredLayouts: ["h:v"]
      };
    } else {
      manhattanOptions = {
        preferredLayouts: ["h:h"]
      };
    }
  }
  if (manhattanOptions) {
    manhattanOptions = assign$1(manhattanOptions, hints);
    updatedWaypoints = withoutRedundantPoints(repairConnection(
      source,
      target,
      connectionStart,
      connectionEnd,
      waypoints,
      manhattanOptions
    ));
  }
  return updatedWaypoints || [connectionStart, connectionEnd];
};
function getAttachOrientation(attachedElement) {
  var hostElement = attachedElement.host;
  return getOrientation(getMid(attachedElement), hostElement, ATTACH_ORIENTATION_PADDING);
}
function getMessageFlowManhattanOptions(source, target) {
  return {
    preferredLayouts: ["straight", "v:v"],
    preserveDocking: getMessageFlowPreserveDocking(source, target)
  };
}
function getMessageFlowPreserveDocking(source, target) {
  if (is$1(target, "bpmn:Participant")) {
    return "source";
  }
  if (is$1(source, "bpmn:Participant")) {
    return "target";
  }
  if (isExpandedSubProcess$1(target)) {
    return "source";
  }
  if (isExpandedSubProcess$1(source)) {
    return "target";
  }
  if (is$1(target, "bpmn:Event")) {
    return "target";
  }
  if (is$1(source, "bpmn:Event")) {
    return "source";
  }
  return null;
}
function getSubProcessManhattanOptions(source) {
  return {
    preferredLayouts: ["straight", "h:h"],
    preserveDocking: getSubProcessPreserveDocking(source)
  };
}
function getSubProcessPreserveDocking(source) {
  return isExpandedSubProcess$1(source) ? "target" : "source";
}
function getConnectionDocking(point, shape) {
  return point ? point.original || point : getMid(shape);
}
function isCompensationAssociation(source, target) {
  return is$1(target, "bpmn:Activity") && is$1(source, "bpmn:BoundaryEvent") && target.businessObject.isForCompensation;
}
function isExpandedSubProcess$1(element) {
  return is$1(element, "bpmn:SubProcess") && isExpanded(element);
}
function isSame(a2, b2) {
  return a2 === b2;
}
function isAnyOrientation(orientation, orientations) {
  return orientations.indexOf(orientation) !== -1;
}
function getHorizontalOrientation(orientation) {
  var matches2 = /right|left/.exec(orientation);
  return matches2 && matches2[0];
}
function getVerticalOrientation(orientation) {
  var matches2 = /top|bottom/.exec(orientation);
  return matches2 && matches2[0];
}
function isOppositeOrientation(a2, b2) {
  return oppositeOrientationMapping[a2] === b2;
}
function isOppositeHorizontalOrientation(a2, b2) {
  var horizontalOrientation = getHorizontalOrientation(a2);
  var oppositeHorizontalOrientation = oppositeOrientationMapping[horizontalOrientation];
  return b2.indexOf(oppositeHorizontalOrientation) !== -1;
}
function isOppositeVerticalOrientation(a2, b2) {
  var verticalOrientation = getVerticalOrientation(a2);
  var oppositeVerticalOrientation = oppositeOrientationMapping[verticalOrientation];
  return b2.indexOf(oppositeVerticalOrientation) !== -1;
}
function isHorizontalOrientation(orientation) {
  return orientation === "right" || orientation === "left";
}
function getLoopPreferredLayout(source, connection) {
  var waypoints = connection.waypoints;
  var orientation = waypoints && waypoints.length && getOrientation(waypoints[0], source);
  if (orientation === "top") {
    return ["t:r"];
  } else if (orientation === "right") {
    return ["r:b"];
  } else if (orientation === "left") {
    return ["l:t"];
  }
  return ["b:l"];
}
function getBoundaryEventPreferredLayouts(source, target, end) {
  var sourceMid = getMid(source), targetMid = getMid(target), attachOrientation = getAttachOrientation(source), sourceLayout, targetLayout;
  var isLoop = isSame(source.host, target);
  var attachedToSide = isAnyOrientation(attachOrientation, ["top", "right", "bottom", "left"]);
  var targetOrientation = getOrientation(targetMid, sourceMid, {
    x: source.width / 2 + target.width / 2,
    y: source.height / 2 + target.height / 2
  });
  if (isLoop) {
    return getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end);
  }
  sourceLayout = getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide);
  targetLayout = getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide);
  return [sourceLayout + ":" + targetLayout];
}
function getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end) {
  var orientation = attachedToSide ? attachOrientation : getVerticalOrientation(attachOrientation), sourceLayout = orientationDirectionMapping[orientation], targetLayout;
  if (attachedToSide) {
    if (isHorizontalOrientation(attachOrientation)) {
      targetLayout = shouldConnectToSameSide("y", source, target, end) ? "h" : "b";
    } else {
      targetLayout = shouldConnectToSameSide("x", source, target, end) ? "v" : "l";
    }
  } else {
    targetLayout = "v";
  }
  return [sourceLayout + ":" + targetLayout];
}
function shouldConnectToSameSide(axis, source, target, end) {
  var threshold = BOUNDARY_TO_HOST_THRESHOLD$1;
  return !(areCloseOnAxis(axis, end, target, threshold) || areCloseOnAxis(axis, end, {
    x: target.x + target.width,
    y: target.y + target.height
  }, threshold) || areCloseOnAxis(axis, end, getMid(source), threshold));
}
function areCloseOnAxis(axis, a2, b2, threshold) {
  return Math.abs(a2[axis] - b2[axis]) < threshold;
}
function getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide) {
  if (attachedToSide) {
    return orientationDirectionMapping[attachOrientation];
  }
  if (isSame(
    getVerticalOrientation(attachOrientation),
    getVerticalOrientation(targetOrientation)
  ) || isOppositeOrientation(
    getHorizontalOrientation(attachOrientation),
    getHorizontalOrientation(targetOrientation)
  )) {
    return orientationDirectionMapping[getVerticalOrientation(attachOrientation)];
  }
  return orientationDirectionMapping[getHorizontalOrientation(attachOrientation)];
}
function getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide) {
  if (attachedToSide) {
    if (isHorizontalOrientation(attachOrientation)) {
      if (isOppositeHorizontalOrientation(attachOrientation, targetOrientation) || isSame(attachOrientation, targetOrientation)) {
        return "h";
      }
      return "v";
    } else {
      if (isOppositeVerticalOrientation(attachOrientation, targetOrientation) || isSame(attachOrientation, targetOrientation)) {
        return "v";
      }
      return "h";
    }
  }
  if (isHorizontalOrientation(targetOrientation) || isSame(getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation)) && getHorizontalOrientation(targetOrientation)) {
    return "h";
  } else {
    return "v";
  }
}
function dockingToPoint(docking) {
  return assign$1({ original: docking.point.original || docking.point }, docking.actual);
}
function CroppingConnectionDocking(elementRegistry, graphicsFactory) {
  this._elementRegistry = elementRegistry;
  this._graphicsFactory = graphicsFactory;
}
CroppingConnectionDocking.$inject = ["elementRegistry", "graphicsFactory"];
CroppingConnectionDocking.prototype.getCroppedWaypoints = function(connection, source, target) {
  source = source || connection.source;
  target = target || connection.target;
  var sourceDocking = this.getDockingPoint(connection, source, true), targetDocking = this.getDockingPoint(connection, target);
  var croppedWaypoints = connection.waypoints.slice(sourceDocking.idx + 1, targetDocking.idx);
  croppedWaypoints.unshift(dockingToPoint(sourceDocking));
  croppedWaypoints.push(dockingToPoint(targetDocking));
  return croppedWaypoints;
};
CroppingConnectionDocking.prototype.getDockingPoint = function(connection, shape, dockStart) {
  var waypoints = connection.waypoints, dockingIdx, dockingPoint, croppedPoint;
  dockingIdx = dockStart ? 0 : waypoints.length - 1;
  dockingPoint = waypoints[dockingIdx];
  croppedPoint = this._getIntersection(shape, connection, dockStart);
  return {
    point: dockingPoint,
    actual: croppedPoint || dockingPoint,
    idx: dockingIdx
  };
};
CroppingConnectionDocking.prototype._getIntersection = function(shape, connection, takeFirst) {
  var shapePath = this._getShapePath(shape), connectionPath = this._getConnectionPath(connection);
  return getElementLineIntersection(shapePath, connectionPath, takeFirst);
};
CroppingConnectionDocking.prototype._getConnectionPath = function(connection) {
  return this._graphicsFactory.getConnectionPath(connection);
};
CroppingConnectionDocking.prototype._getShapePath = function(shape) {
  return this._graphicsFactory.getShapePath(shape);
};
CroppingConnectionDocking.prototype._getGfx = function(element) {
  return this._elementRegistry.getGraphics(element);
};
const ModelingModule = {
  __init__: [
    "modeling",
    "bpmnUpdater"
  ],
  __depends__: [
    BehaviorModule,
    RulesModule,
    DiOrderingModule,
    OrderingModule,
    ReplaceModule,
    CommandModule,
    LabelSupportModule,
    AttachSupportModule,
    SelectionModule,
    ChangeSupportModule,
    SpaceToolModule
  ],
  bpmnFactory: ["type", BpmnFactory],
  bpmnUpdater: ["type", BpmnUpdater],
  elementFactory: ["type", ElementFactory],
  modeling: ["type", Modeling],
  layouter: ["type", BpmnLayouter],
  connectionDocking: ["type", CroppingConnectionDocking]
};
const round$1 = Math.round;
function AppendPreview(complexPreview, connectionDocking, elementFactory, eventBus, layouter, rules) {
  this._complexPreview = complexPreview;
  this._connectionDocking = connectionDocking;
  this._elementFactory = elementFactory;
  this._eventBus = eventBus;
  this._layouter = layouter;
  this._rules = rules;
}
AppendPreview.prototype.create = function(source, type, options) {
  const complexPreview = this._complexPreview, connectionDocking = this._connectionDocking, elementFactory = this._elementFactory, eventBus = this._eventBus, layouter = this._layouter, rules = this._rules;
  const shape = elementFactory.createShape(assign$1({ type }, options));
  const position = eventBus.fire("autoPlace", {
    source,
    shape
  });
  if (!position) {
    return;
  }
  assign$1(shape, {
    x: position.x - round$1(shape.width / 2),
    y: position.y - round$1(shape.height / 2)
  });
  const connectionCreateAllowed = rules.allowed("connection.create", {
    source,
    target: shape,
    hints: {
      targetParent: source.parent
    }
  });
  let connection = null;
  if (connectionCreateAllowed) {
    connection = elementFactory.createConnection(connectionCreateAllowed);
    connection.waypoints = layouter.layoutConnection(connection, {
      source,
      target: shape
    });
    connection.waypoints = connectionDocking.getCroppedWaypoints(connection, source, shape);
  }
  complexPreview.create({
    created: [
      shape,
      connection
    ].filter((element) => !isNil(element))
  });
};
AppendPreview.prototype.cleanUp = function() {
  this._complexPreview.cleanUp();
};
AppendPreview.$inject = [
  "complexPreview",
  "connectionDocking",
  "elementFactory",
  "eventBus",
  "layouter",
  "rules"
];
const AppendPreviewModule = {
  __depends__: [
    AutoPlaceModule,
    ComplexPreviewModule,
    ModelingModule
  ],
  __init__: ["appendPreview"],
  appendPreview: ["type", AppendPreview]
};
var min = Math.min, max = Math.max;
function preventDefault(e2) {
  e2.preventDefault();
}
function stopPropagation(e2) {
  e2.stopPropagation();
}
function isTextNode(node2) {
  return node2.nodeType === Node.TEXT_NODE;
}
function toArray(nodeList) {
  return [].slice.call(nodeList);
}
function TextBox(options) {
  this.container = options.container;
  this.parent = domify$1(
    '<div class="djs-direct-editing-parent"><div class="djs-direct-editing-content" contenteditable="true"></div></div>'
  );
  this.content = query("[contenteditable]", this.parent);
  this.keyHandler = options.keyHandler || function() {
  };
  this.resizeHandler = options.resizeHandler || function() {
  };
  this.autoResize = bind$2(this.autoResize, this);
  this.handlePaste = bind$2(this.handlePaste, this);
}
TextBox.prototype.create = function(bounds, style, value, options) {
  var self2 = this;
  var parent = this.parent, content = this.content, container = this.container;
  options = this.options = options || {};
  style = this.style = style || {};
  var parentStyle = pick(style, [
    "width",
    "height",
    "maxWidth",
    "maxHeight",
    "minWidth",
    "minHeight",
    "left",
    "top",
    "backgroundColor",
    "position",
    "overflow",
    "border",
    "wordWrap",
    "textAlign",
    "outline",
    "transform"
  ]);
  assign$1(parent.style, {
    width: bounds.width + "px",
    height: bounds.height + "px",
    maxWidth: bounds.maxWidth + "px",
    maxHeight: bounds.maxHeight + "px",
    minWidth: bounds.minWidth + "px",
    minHeight: bounds.minHeight + "px",
    left: bounds.x + "px",
    top: bounds.y + "px",
    backgroundColor: "#ffffff",
    position: "absolute",
    overflow: "visible",
    border: "1px solid #ccc",
    boxSizing: "border-box",
    wordWrap: "normal",
    textAlign: "center",
    outline: "none"
  }, parentStyle);
  var contentStyle = pick(style, [
    "fontFamily",
    "fontSize",
    "fontWeight",
    "lineHeight",
    "padding",
    "paddingTop",
    "paddingRight",
    "paddingBottom",
    "paddingLeft"
  ]);
  assign$1(content.style, {
    boxSizing: "border-box",
    width: "100%",
    outline: "none",
    wordWrap: "break-word"
  }, contentStyle);
  if (options.centerVertically) {
    assign$1(content.style, {
      position: "absolute",
      top: "50%",
      transform: "translate(0, -50%)"
    }, contentStyle);
  }
  content.innerText = value;
  event.bind(content, "keydown", this.keyHandler);
  event.bind(content, "mousedown", stopPropagation);
  event.bind(content, "paste", self2.handlePaste);
  if (options.autoResize) {
    event.bind(content, "input", this.autoResize);
  }
  if (options.resizable) {
    this.resizable(style);
  }
  container.appendChild(parent);
  this.setSelection(content.lastChild, content.lastChild && content.lastChild.length);
  return parent;
};
TextBox.prototype.handlePaste = function(e2) {
  var options = this.options, style = this.style;
  e2.preventDefault();
  var text;
  if (e2.clipboardData) {
    text = e2.clipboardData.getData("text/plain");
  } else {
    text = window.clipboardData.getData("Text");
  }
  this.insertText(text);
  if (options.autoResize) {
    var hasResized = this.autoResize(style);
    if (hasResized) {
      this.resizeHandler(hasResized);
    }
  }
};
TextBox.prototype.insertText = function(text) {
  text = normalizeEndOfLineSequences(text);
  var success = document.execCommand("insertText", false, text);
  if (success) {
    return;
  }
  this._insertTextIE(text);
};
TextBox.prototype._insertTextIE = function(text) {
  var range = this.getSelection(), startContainer = range.startContainer, endContainer = range.endContainer, startOffset = range.startOffset, endOffset = range.endOffset, commonAncestorContainer = range.commonAncestorContainer;
  var childNodesArray = toArray(commonAncestorContainer.childNodes);
  var container, offset;
  if (isTextNode(commonAncestorContainer)) {
    var containerTextContent = startContainer.textContent;
    startContainer.textContent = containerTextContent.substring(0, startOffset) + text + containerTextContent.substring(endOffset);
    container = startContainer;
    offset = startOffset + text.length;
  } else if (startContainer === this.content && endContainer === this.content) {
    var textNode = document.createTextNode(text);
    this.content.insertBefore(textNode, childNodesArray[startOffset]);
    container = textNode;
    offset = textNode.textContent.length;
  } else {
    var startContainerChildIndex = childNodesArray.indexOf(startContainer), endContainerChildIndex = childNodesArray.indexOf(endContainer);
    childNodesArray.forEach(function(childNode, index2) {
      if (index2 === startContainerChildIndex) {
        childNode.textContent = startContainer.textContent.substring(0, startOffset) + text + endContainer.textContent.substring(endOffset);
      } else if (index2 > startContainerChildIndex && index2 <= endContainerChildIndex) {
        remove$2(childNode);
      }
    });
    container = startContainer;
    offset = startOffset + text.length;
  }
  if (container && offset !== void 0) {
    setTimeout(function() {
      self.setSelection(container, offset);
    });
  }
};
TextBox.prototype.autoResize = function() {
  var parent = this.parent, content = this.content;
  var fontSize = parseInt(this.style.fontSize) || 12;
  if (content.scrollHeight > parent.offsetHeight || content.scrollHeight < parent.offsetHeight - fontSize) {
    var bounds = parent.getBoundingClientRect();
    var height = content.scrollHeight;
    parent.style.height = height + "px";
    this.resizeHandler({
      width: bounds.width,
      height: bounds.height,
      dx: 0,
      dy: height - bounds.height
    });
  }
};
TextBox.prototype.resizable = function() {
  var self2 = this;
  var parent = this.parent, resizeHandle = this.resizeHandle;
  var minWidth = parseInt(this.style.minWidth) || 0, minHeight = parseInt(this.style.minHeight) || 0, maxWidth = parseInt(this.style.maxWidth) || Infinity, maxHeight = parseInt(this.style.maxHeight) || Infinity;
  if (!resizeHandle) {
    resizeHandle = this.resizeHandle = domify$1(
      '<div class="djs-direct-editing-resize-handle"></div>'
    );
    var startX, startY, startWidth, startHeight;
    var onMouseDown = function(e2) {
      preventDefault(e2);
      stopPropagation(e2);
      startX = e2.clientX;
      startY = e2.clientY;
      var bounds = parent.getBoundingClientRect();
      startWidth = bounds.width;
      startHeight = bounds.height;
      event.bind(document, "mousemove", onMouseMove);
      event.bind(document, "mouseup", onMouseUp);
    };
    var onMouseMove = function(e2) {
      preventDefault(e2);
      stopPropagation(e2);
      var newWidth = min(max(startWidth + e2.clientX - startX, minWidth), maxWidth);
      var newHeight = min(max(startHeight + e2.clientY - startY, minHeight), maxHeight);
      parent.style.width = newWidth + "px";
      parent.style.height = newHeight + "px";
      self2.resizeHandler({
        width: startWidth,
        height: startHeight,
        dx: e2.clientX - startX,
        dy: e2.clientY - startY
      });
    };
    var onMouseUp = function(e2) {
      preventDefault(e2);
      stopPropagation(e2);
      event.unbind(document, "mousemove", onMouseMove, false);
      event.unbind(document, "mouseup", onMouseUp, false);
    };
    event.bind(resizeHandle, "mousedown", onMouseDown);
  }
  assign$1(resizeHandle.style, {
    position: "absolute",
    bottom: "0px",
    right: "0px",
    cursor: "nwse-resize",
    width: "0",
    height: "0",
    borderTop: (parseInt(this.style.fontSize) / 4 || 3) + "px solid transparent",
    borderRight: (parseInt(this.style.fontSize) / 4 || 3) + "px solid #ccc",
    borderBottom: (parseInt(this.style.fontSize) / 4 || 3) + "px solid #ccc",
    borderLeft: (parseInt(this.style.fontSize) / 4 || 3) + "px solid transparent"
  });
  parent.appendChild(resizeHandle);
};
TextBox.prototype.destroy = function() {
  var parent = this.parent, content = this.content, resizeHandle = this.resizeHandle;
  content.innerText = "";
  parent.removeAttribute("style");
  content.removeAttribute("style");
  event.unbind(content, "keydown", this.keyHandler);
  event.unbind(content, "mousedown", stopPropagation);
  event.unbind(content, "input", this.autoResize);
  event.unbind(content, "paste", this.handlePaste);
  if (resizeHandle) {
    resizeHandle.removeAttribute("style");
    remove$2(resizeHandle);
  }
  remove$2(parent);
};
TextBox.prototype.getValue = function() {
  return this.content.innerText.trim();
};
TextBox.prototype.getSelection = function() {
  var selection = window.getSelection(), range = selection.getRangeAt(0);
  return range;
};
TextBox.prototype.setSelection = function(container, offset) {
  var range = document.createRange();
  if (container === null) {
    range.selectNodeContents(this.content);
  } else {
    range.setStart(container, offset);
    range.setEnd(container, offset);
  }
  var selection = window.getSelection();
  selection.removeAllRanges();
  selection.addRange(range);
};
function normalizeEndOfLineSequences(string) {
  return string.replace(/\r\n|\r|\n/g, "\n");
}
function DirectEditing(eventBus, canvas) {
  this._eventBus = eventBus;
  this._providers = [];
  this._textbox = new TextBox({
    container: canvas.getContainer(),
    keyHandler: bind$2(this._handleKey, this),
    resizeHandler: bind$2(this._handleResize, this)
  });
}
DirectEditing.$inject = ["eventBus", "canvas"];
DirectEditing.prototype.registerProvider = function(provider) {
  this._providers.push(provider);
};
DirectEditing.prototype.isActive = function(element) {
  return !!(this._active && (!element || this._active.element === element));
};
DirectEditing.prototype.cancel = function() {
  if (!this._active) {
    return;
  }
  this._fire("cancel");
  this.close();
};
DirectEditing.prototype._fire = function(event2, context) {
  this._eventBus.fire("directEditing." + event2, context || { active: this._active });
};
DirectEditing.prototype.close = function() {
  this._textbox.destroy();
  this._fire("deactivate");
  this._active = null;
  this.resizable = void 0;
};
DirectEditing.prototype.complete = function() {
  var active = this._active;
  if (!active) {
    return;
  }
  var containerBounds, previousBounds = active.context.bounds, newBounds = this.$textbox.getBoundingClientRect(), newText = this.getValue(), previousText = active.context.text;
  if (newText !== previousText || newBounds.height !== previousBounds.height || newBounds.width !== previousBounds.width) {
    containerBounds = this._textbox.container.getBoundingClientRect();
    active.provider.update(active.element, newText, active.context.text, {
      x: newBounds.left - containerBounds.left,
      y: newBounds.top - containerBounds.top,
      width: newBounds.width,
      height: newBounds.height
    });
  }
  this._fire("complete");
  this.close();
};
DirectEditing.prototype.getValue = function() {
  return this._textbox.getValue();
};
DirectEditing.prototype._handleKey = function(e2) {
  e2.stopPropagation();
  var key = e2.keyCode || e2.charCode;
  if (key === 27) {
    e2.preventDefault();
    return this.cancel();
  }
  if (key === 13 && !e2.shiftKey) {
    e2.preventDefault();
    return this.complete();
  }
};
DirectEditing.prototype._handleResize = function(event2) {
  this._fire("resize", event2);
};
DirectEditing.prototype.activate = function(element) {
  if (this.isActive()) {
    this.cancel();
  }
  var context;
  var provider = find(this._providers, function(p2) {
    return (context = p2.activate(element)) ? p2 : null;
  });
  if (context) {
    this.$textbox = this._textbox.create(
      context.bounds,
      context.style,
      context.text,
      context.options
    );
    this._active = {
      element,
      context,
      provider
    };
    if (context.options && context.options.resizable) {
      this.resizable = true;
    }
    this._fire("activate");
  }
  return !!context;
};
const DirectEditingModule = {
  __depends__: [
    InteractionEventsModule$1
  ],
  __init__: ["directEditing"],
  directEditing: ["type", DirectEditing]
};
function isDifferentType(element) {
  return function(entry) {
    var target = entry.target;
    var businessObject = getBusinessObject(element), eventDefinition = businessObject.eventDefinitions && businessObject.eventDefinitions[0];
    var isTypeEqual = businessObject.$type === target.type;
    var isEventDefinitionEqual = (eventDefinition && eventDefinition.$type) === target.eventDefinitionType;
    var isTriggeredByEventEqual = (
      // coherse to <false>
      !!target.triggeredByEvent === !!businessObject.triggeredByEvent
    );
    var isExpandedEqual = target.isExpanded === void 0 || target.isExpanded === isExpanded(element);
    return !isTypeEqual || !isEventDefinitionEqual || !isTriggeredByEventEqual || !isExpandedEqual;
  };
}
var START_EVENT = [
  {
    label: "Start event",
    actionName: "replace-with-none-start",
    className: "bpmn-icon-start-event-none",
    target: {
      type: "bpmn:StartEvent"
    }
  },
  {
    label: "Intermediate throw event",
    actionName: "replace-with-none-intermediate-throwing",
    className: "bpmn-icon-intermediate-event-none",
    target: {
      type: "bpmn:IntermediateThrowEvent"
    }
  },
  {
    label: "End event",
    actionName: "replace-with-none-end",
    className: "bpmn-icon-end-event-none",
    target: {
      type: "bpmn:EndEvent"
    }
  },
  {
    label: "Message start event",
    actionName: "replace-with-message-start",
    className: "bpmn-icon-start-event-message",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Timer start event",
    actionName: "replace-with-timer-start",
    className: "bpmn-icon-start-event-timer",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition"
    }
  },
  {
    label: "Conditional start event",
    actionName: "replace-with-conditional-start",
    className: "bpmn-icon-start-event-condition",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition"
    }
  },
  {
    label: "Signal start event",
    actionName: "replace-with-signal-start",
    className: "bpmn-icon-start-event-signal",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  }
];
var START_EVENT_SUB_PROCESS = [
  {
    label: "Start event",
    actionName: "replace-with-none-start",
    className: "bpmn-icon-start-event-none",
    target: {
      type: "bpmn:StartEvent"
    }
  },
  {
    label: "Intermediate throw event",
    actionName: "replace-with-none-intermediate-throwing",
    className: "bpmn-icon-intermediate-event-none",
    target: {
      type: "bpmn:IntermediateThrowEvent"
    }
  },
  {
    label: "End event",
    actionName: "replace-with-none-end",
    className: "bpmn-icon-end-event-none",
    target: {
      type: "bpmn:EndEvent"
    }
  }
];
var INTERMEDIATE_EVENT = [
  {
    label: "Start event",
    actionName: "replace-with-none-start",
    className: "bpmn-icon-start-event-none",
    target: {
      type: "bpmn:StartEvent"
    }
  },
  {
    label: "Intermediate throw event",
    actionName: "replace-with-none-intermediate-throw",
    className: "bpmn-icon-intermediate-event-none",
    target: {
      type: "bpmn:IntermediateThrowEvent"
    }
  },
  {
    label: "End event",
    actionName: "replace-with-none-end",
    className: "bpmn-icon-end-event-none",
    target: {
      type: "bpmn:EndEvent"
    }
  },
  {
    label: "Message intermediate catch event",
    actionName: "replace-with-message-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-message",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Message intermediate throw event",
    actionName: "replace-with-message-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-message",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Timer intermediate catch event",
    actionName: "replace-with-timer-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-timer",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition"
    }
  },
  {
    label: "Escalation intermediate throw event",
    actionName: "replace-with-escalation-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-escalation",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition"
    }
  },
  {
    label: "Conditional intermediate catch event",
    actionName: "replace-with-conditional-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-condition",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition"
    }
  },
  {
    label: "Link intermediate catch event",
    actionName: "replace-with-link-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-link",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:LinkEventDefinition",
      eventDefinitionAttrs: {
        name: ""
      }
    }
  },
  {
    label: "Link intermediate throw event",
    actionName: "replace-with-link-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-link",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:LinkEventDefinition",
      eventDefinitionAttrs: {
        name: ""
      }
    }
  },
  {
    label: "Compensation intermediate throw event",
    actionName: "replace-with-compensation-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-compensation",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition"
    }
  },
  {
    label: "Signal intermediate catch event",
    actionName: "replace-with-signal-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-signal",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  },
  {
    label: "Signal intermediate throw event",
    actionName: "replace-with-signal-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-signal",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  }
];
var END_EVENT = [
  {
    label: "Start event",
    actionName: "replace-with-none-start",
    className: "bpmn-icon-start-event-none",
    target: {
      type: "bpmn:StartEvent"
    }
  },
  {
    label: "Intermediate throw event",
    actionName: "replace-with-none-intermediate-throw",
    className: "bpmn-icon-intermediate-event-none",
    target: {
      type: "bpmn:IntermediateThrowEvent"
    }
  },
  {
    label: "End event",
    actionName: "replace-with-none-end",
    className: "bpmn-icon-end-event-none",
    target: {
      type: "bpmn:EndEvent"
    }
  },
  {
    label: "Message end event",
    actionName: "replace-with-message-end",
    className: "bpmn-icon-end-event-message",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Escalation end event",
    actionName: "replace-with-escalation-end",
    className: "bpmn-icon-end-event-escalation",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition"
    }
  },
  {
    label: "Error end event",
    actionName: "replace-with-error-end",
    className: "bpmn-icon-end-event-error",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:ErrorEventDefinition"
    }
  },
  {
    label: "Cancel end event",
    actionName: "replace-with-cancel-end",
    className: "bpmn-icon-end-event-cancel",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:CancelEventDefinition"
    }
  },
  {
    label: "Compensation end event",
    actionName: "replace-with-compensation-end",
    className: "bpmn-icon-end-event-compensation",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition"
    }
  },
  {
    label: "Signal end event",
    actionName: "replace-with-signal-end",
    className: "bpmn-icon-end-event-signal",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  },
  {
    label: "Terminate end event",
    actionName: "replace-with-terminate-end",
    className: "bpmn-icon-end-event-terminate",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:TerminateEventDefinition"
    }
  }
];
var GATEWAY = [
  {
    label: "Exclusive gateway",
    actionName: "replace-with-exclusive-gateway",
    className: "bpmn-icon-gateway-xor",
    target: {
      type: "bpmn:ExclusiveGateway"
    }
  },
  {
    label: "Parallel gateway",
    actionName: "replace-with-parallel-gateway",
    className: "bpmn-icon-gateway-parallel",
    target: {
      type: "bpmn:ParallelGateway"
    }
  },
  {
    label: "Inclusive gateway",
    actionName: "replace-with-inclusive-gateway",
    className: "bpmn-icon-gateway-or",
    target: {
      type: "bpmn:InclusiveGateway"
    }
  },
  {
    label: "Complex gateway",
    actionName: "replace-with-complex-gateway",
    className: "bpmn-icon-gateway-complex",
    target: {
      type: "bpmn:ComplexGateway"
    }
  },
  {
    label: "Event-based gateway",
    actionName: "replace-with-event-based-gateway",
    className: "bpmn-icon-gateway-eventbased",
    target: {
      type: "bpmn:EventBasedGateway",
      instantiate: false,
      eventGatewayType: "Exclusive"
    }
  }
  // Gateways deactivated until https://github.com/bpmn-io/bpmn-js/issues/194
  // {
  //   label: 'Event based instantiating Gateway',
  //   actionName: 'replace-with-exclusive-event-based-gateway',
  //   className: 'bpmn-icon-exclusive-event-based',
  //   target: {
  //     type: 'bpmn:EventBasedGateway'
  //   },
  //   options: {
  //     businessObject: { instantiate: true, eventGatewayType: 'Exclusive' }
  //   }
  // },
  // {
  //   label: 'Parallel Event based instantiating Gateway',
  //   actionName: 'replace-with-parallel-event-based-instantiate-gateway',
  //   className: 'bpmn-icon-parallel-event-based-instantiate-gateway',
  //   target: {
  //     type: 'bpmn:EventBasedGateway'
  //   },
  //   options: {
  //     businessObject: { instantiate: true, eventGatewayType: 'Parallel' }
  //   }
  // }
];
var SUBPROCESS_EXPANDED = [
  {
    label: "Transaction",
    actionName: "replace-with-transaction",
    className: "bpmn-icon-transaction",
    target: {
      type: "bpmn:Transaction",
      isExpanded: true
    }
  },
  {
    label: "Event sub-process",
    actionName: "replace-with-event-subprocess",
    className: "bpmn-icon-event-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      triggeredByEvent: true,
      isExpanded: true
    }
  },
  {
    label: "Sub-process (collapsed)",
    actionName: "replace-with-collapsed-subprocess",
    className: "bpmn-icon-subprocess-collapsed",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: false
    }
  }
];
var TRANSACTION = [
  {
    label: "Transaction",
    actionName: "replace-with-transaction",
    className: "bpmn-icon-transaction",
    target: {
      type: "bpmn:Transaction",
      isExpanded: true
    }
  },
  {
    label: "Sub-process",
    actionName: "replace-with-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: true
    }
  },
  {
    label: "Event sub-process",
    actionName: "replace-with-event-subprocess",
    className: "bpmn-icon-event-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      triggeredByEvent: true,
      isExpanded: true
    }
  }
];
var EVENT_SUB_PROCESS = TRANSACTION;
var TASK = [
  {
    label: "Task",
    actionName: "replace-with-task",
    className: "bpmn-icon-task",
    target: {
      type: "bpmn:Task"
    }
  },
  {
    label: "User task",
    actionName: "replace-with-user-task",
    className: "bpmn-icon-user",
    target: {
      type: "bpmn:UserTask"
    }
  },
  {
    label: "Service task",
    actionName: "replace-with-service-task",
    className: "bpmn-icon-service",
    target: {
      type: "bpmn:ServiceTask"
    }
  },
  {
    label: "Send task",
    actionName: "replace-with-send-task",
    className: "bpmn-icon-send",
    target: {
      type: "bpmn:SendTask"
    }
  },
  {
    label: "Receive task",
    actionName: "replace-with-receive-task",
    className: "bpmn-icon-receive",
    target: {
      type: "bpmn:ReceiveTask"
    }
  },
  {
    label: "Manual task",
    actionName: "replace-with-manual-task",
    className: "bpmn-icon-manual",
    target: {
      type: "bpmn:ManualTask"
    }
  },
  {
    label: "Business rule task",
    actionName: "replace-with-rule-task",
    className: "bpmn-icon-business-rule",
    target: {
      type: "bpmn:BusinessRuleTask"
    }
  },
  {
    label: "Script task",
    actionName: "replace-with-script-task",
    className: "bpmn-icon-script",
    target: {
      type: "bpmn:ScriptTask"
    }
  },
  {
    label: "Call activity",
    actionName: "replace-with-call-activity",
    className: "bpmn-icon-call-activity",
    target: {
      type: "bpmn:CallActivity"
    }
  },
  {
    label: "Sub-process (collapsed)",
    actionName: "replace-with-collapsed-subprocess",
    className: "bpmn-icon-subprocess-collapsed",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: false
    }
  },
  {
    label: "Sub-process (expanded)",
    actionName: "replace-with-expanded-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: true
    }
  }
];
var DATA_OBJECT_REFERENCE = [
  {
    label: "Data store reference",
    actionName: "replace-with-data-store-reference",
    className: "bpmn-icon-data-store",
    target: {
      type: "bpmn:DataStoreReference"
    }
  }
];
var DATA_STORE_REFERENCE = [
  {
    label: "Data object reference",
    actionName: "replace-with-data-object-reference",
    className: "bpmn-icon-data-object",
    target: {
      type: "bpmn:DataObjectReference"
    }
  }
];
var BOUNDARY_EVENT = [
  {
    label: "Message boundary event",
    actionName: "replace-with-message-boundary",
    className: "bpmn-icon-intermediate-event-catch-message",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Timer boundary event",
    actionName: "replace-with-timer-boundary",
    className: "bpmn-icon-intermediate-event-catch-timer",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Escalation boundary event",
    actionName: "replace-with-escalation-boundary",
    className: "bpmn-icon-intermediate-event-catch-escalation",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Conditional boundary event",
    actionName: "replace-with-conditional-boundary",
    className: "bpmn-icon-intermediate-event-catch-condition",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Error boundary event",
    actionName: "replace-with-error-boundary",
    className: "bpmn-icon-intermediate-event-catch-error",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:ErrorEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Cancel boundary event",
    actionName: "replace-with-cancel-boundary",
    className: "bpmn-icon-intermediate-event-catch-cancel",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:CancelEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Signal boundary event",
    actionName: "replace-with-signal-boundary",
    className: "bpmn-icon-intermediate-event-catch-signal",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Compensation boundary event",
    actionName: "replace-with-compensation-boundary",
    className: "bpmn-icon-intermediate-event-catch-compensation",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Message boundary event (non-interrupting)",
    actionName: "replace-with-non-interrupting-message-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-message",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Timer boundary event (non-interrupting)",
    actionName: "replace-with-non-interrupting-timer-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-timer",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Escalation boundary event (non-interrupting)",
    actionName: "replace-with-non-interrupting-escalation-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-escalation",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Conditional boundary event (non-interrupting)",
    actionName: "replace-with-non-interrupting-conditional-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-condition",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Signal boundary event (non-interrupting)",
    actionName: "replace-with-non-interrupting-signal-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-signal",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition",
      cancelActivity: false
    }
  }
];
var EVENT_SUB_PROCESS_START_EVENT = [
  {
    label: "Message start event",
    actionName: "replace-with-message-start",
    className: "bpmn-icon-start-event-message",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Timer start event",
    actionName: "replace-with-timer-start",
    className: "bpmn-icon-start-event-timer",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Conditional start event",
    actionName: "replace-with-conditional-start",
    className: "bpmn-icon-start-event-condition",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Signal start event",
    actionName: "replace-with-signal-start",
    className: "bpmn-icon-start-event-signal",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Error start event",
    actionName: "replace-with-error-start",
    className: "bpmn-icon-start-event-error",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:ErrorEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Escalation start event",
    actionName: "replace-with-escalation-start",
    className: "bpmn-icon-start-event-escalation",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Compensation start event",
    actionName: "replace-with-compensation-start",
    className: "bpmn-icon-start-event-compensation",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Message start event (non-interrupting)",
    actionName: "replace-with-non-interrupting-message-start",
    className: "bpmn-icon-start-event-non-interrupting-message",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition",
      isInterrupting: false
    }
  },
  {
    label: "Timer start event (non-interrupting)",
    actionName: "replace-with-non-interrupting-timer-start",
    className: "bpmn-icon-start-event-non-interrupting-timer",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition",
      isInterrupting: false
    }
  },
  {
    label: "Conditional start event (non-interrupting)",
    actionName: "replace-with-non-interrupting-conditional-start",
    className: "bpmn-icon-start-event-non-interrupting-condition",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition",
      isInterrupting: false
    }
  },
  {
    label: "Signal start event (non-interrupting)",
    actionName: "replace-with-non-interrupting-signal-start",
    className: "bpmn-icon-start-event-non-interrupting-signal",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition",
      isInterrupting: false
    }
  },
  {
    label: "Escalation start event (non-interrupting)",
    actionName: "replace-with-non-interrupting-escalation-start",
    className: "bpmn-icon-start-event-non-interrupting-escalation",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition",
      isInterrupting: false
    }
  }
];
var SEQUENCE_FLOW = [
  {
    label: "Sequence flow",
    actionName: "replace-with-sequence-flow",
    className: "bpmn-icon-connection"
  },
  {
    label: "Default flow",
    actionName: "replace-with-default-flow",
    className: "bpmn-icon-default-flow"
  },
  {
    label: "Conditional flow",
    actionName: "replace-with-conditional-flow",
    className: "bpmn-icon-conditional-flow"
  }
];
var PARTICIPANT = [
  {
    label: "Expanded pool/participant",
    actionName: "replace-with-expanded-pool",
    className: "bpmn-icon-participant",
    target: {
      type: "bpmn:Participant",
      isExpanded: true
    }
  },
  {
    label: function(element) {
      var label = "Empty pool/participant";
      if (element.children && element.children.length) {
        label += " (removes content)";
      }
      return label;
    },
    actionName: "replace-with-collapsed-pool",
    // TODO(@janstuemmel): maybe design new icon
    className: "bpmn-icon-lane",
    target: {
      type: "bpmn:Participant",
      isExpanded: false
    }
  }
];
const Icons = {
  "start-event-non-interrupting": `
  <svg viewBox="0 0 2048 2048" xmlns="http://www.w3.org/2000/svg">
    <g transform="translate(0 995.64)">
      <path d="m1899 28.357c21.545 567.43-598.38 1023.5-1133.6 835.92-548.09-147.21-801.57-873.95-463.59-1330 302.62-480.3 1071.7-507.54 1407.6-49.847 122.14 153.12 190.07 348.07 189.59 543.91z" fill="none" stroke="currentColor" stroke-dasharray="418.310422, 361.2328165" stroke-linecap="round" stroke-width="100"/>
    </g>
  </svg>`,
  "intermediate-event-non-interrupting": `
  <svg viewBox="0 0 2048 2048" xmlns="http://www.w3.org/2000/svg">
     <g transform="translate(0 995.64)" fill="none" stroke="currentColor" stroke-linecap="round">
        <circle cx="1024" cy="28.357" r="875" stroke-dasharray="418.310422, 361.2328165" stroke-width="100"/>
        <circle cx="1024" cy="28.357" r="685" stroke-dasharray="348.31044857,261.23283643" stroke-dashoffset="500" stroke-width="100"/>
     </g>
  </svg>`
};
function ReplaceMenuProvider(bpmnFactory, popupMenu, modeling, moddle, bpmnReplace, rules, translate2, moddleCopy) {
  this._bpmnFactory = bpmnFactory;
  this._popupMenu = popupMenu;
  this._modeling = modeling;
  this._moddle = moddle;
  this._bpmnReplace = bpmnReplace;
  this._rules = rules;
  this._translate = translate2;
  this._moddleCopy = moddleCopy;
  this._register();
}
ReplaceMenuProvider.$inject = [
  "bpmnFactory",
  "popupMenu",
  "modeling",
  "moddle",
  "bpmnReplace",
  "rules",
  "translate",
  "moddleCopy"
];
ReplaceMenuProvider.prototype._register = function() {
  this._popupMenu.registerProvider("bpmn-replace", this);
};
ReplaceMenuProvider.prototype.getPopupMenuEntries = function(target) {
  var businessObject = target.businessObject;
  var rules = this._rules;
  var filteredReplaceOptions = [];
  if (isArray$3(target) || !rules.allowed("shape.replace", { element: target })) {
    return {};
  }
  var differentType = isDifferentType(target);
  if (is$1(businessObject, "bpmn:DataObjectReference")) {
    return this._createEntries(target, DATA_OBJECT_REFERENCE);
  }
  if (is$1(businessObject, "bpmn:DataStoreReference") && !is$1(target.parent, "bpmn:Collaboration")) {
    return this._createEntries(target, DATA_STORE_REFERENCE);
  }
  if (is$1(businessObject, "bpmn:StartEvent") && !is$1(businessObject.$parent, "bpmn:SubProcess")) {
    filteredReplaceOptions = filter(START_EVENT, differentType);
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is$1(businessObject, "bpmn:Participant")) {
    filteredReplaceOptions = filter(PARTICIPANT, function(replaceOption) {
      return isExpanded(target) !== replaceOption.target.isExpanded;
    });
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is$1(businessObject, "bpmn:StartEvent") && isEventSubProcess(businessObject.$parent)) {
    filteredReplaceOptions = filter(EVENT_SUB_PROCESS_START_EVENT, function(replaceOption) {
      var target2 = replaceOption.target;
      var isInterrupting2 = target2.isInterrupting !== false;
      var isInterruptingEqual = businessObject.isInterrupting === isInterrupting2;
      return differentType(replaceOption) || !differentType(replaceOption) && !isInterruptingEqual;
    });
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is$1(businessObject, "bpmn:StartEvent") && !isEventSubProcess(businessObject.$parent) && is$1(businessObject.$parent, "bpmn:SubProcess")) {
    filteredReplaceOptions = filter(START_EVENT_SUB_PROCESS, differentType);
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is$1(businessObject, "bpmn:EndEvent")) {
    filteredReplaceOptions = filter(END_EVENT, function(replaceOption) {
      var target2 = replaceOption.target;
      if (target2.eventDefinitionType == "bpmn:CancelEventDefinition" && !is$1(businessObject.$parent, "bpmn:Transaction")) {
        return false;
      }
      return differentType(replaceOption);
    });
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is$1(businessObject, "bpmn:BoundaryEvent")) {
    filteredReplaceOptions = filter(BOUNDARY_EVENT, function(replaceOption) {
      var target2 = replaceOption.target;
      if (target2.eventDefinitionType == "bpmn:CancelEventDefinition" && !is$1(businessObject.attachedToRef, "bpmn:Transaction")) {
        return false;
      }
      var cancelActivity = target2.cancelActivity !== false;
      var isCancelActivityEqual = businessObject.cancelActivity == cancelActivity;
      return differentType(replaceOption) || !differentType(replaceOption) && !isCancelActivityEqual;
    });
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is$1(businessObject, "bpmn:IntermediateCatchEvent") || is$1(businessObject, "bpmn:IntermediateThrowEvent")) {
    filteredReplaceOptions = filter(INTERMEDIATE_EVENT, differentType);
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is$1(businessObject, "bpmn:Gateway")) {
    filteredReplaceOptions = filter(GATEWAY, differentType);
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is$1(businessObject, "bpmn:Transaction")) {
    filteredReplaceOptions = filter(TRANSACTION, differentType);
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (isEventSubProcess(businessObject) && isExpanded(target)) {
    filteredReplaceOptions = filter(EVENT_SUB_PROCESS, differentType);
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is$1(businessObject, "bpmn:SubProcess") && isExpanded(target)) {
    filteredReplaceOptions = filter(SUBPROCESS_EXPANDED, differentType);
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is$1(businessObject, "bpmn:AdHocSubProcess") && !isExpanded(target)) {
    filteredReplaceOptions = filter(TASK, function(replaceOption) {
      var target2 = replaceOption.target;
      var isTargetSubProcess = target2.type === "bpmn:SubProcess";
      var isTargetExpanded = target2.isExpanded === true;
      return isDifferentType(target2) && (!isTargetSubProcess || isTargetExpanded);
    });
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is$1(businessObject, "bpmn:SequenceFlow")) {
    return this._createSequenceFlowEntries(target, SEQUENCE_FLOW);
  }
  if (is$1(businessObject, "bpmn:FlowNode")) {
    filteredReplaceOptions = filter(TASK, differentType);
    if (is$1(businessObject, "bpmn:SubProcess") && !isExpanded(target)) {
      filteredReplaceOptions = filter(filteredReplaceOptions, function(replaceOption) {
        return replaceOption.label !== "Sub-process (collapsed)";
      });
    }
    return this._createEntries(target, filteredReplaceOptions);
  }
  return {};
};
ReplaceMenuProvider.prototype.getPopupMenuHeaderEntries = function(target) {
  var headerEntries = {};
  if (is$1(target, "bpmn:Activity") && !isEventSubProcess(target)) {
    headerEntries = {
      ...headerEntries,
      ...this._getLoopCharacteristicsHeaderEntries(target)
    };
  }
  if (is$1(target, "bpmn:DataObjectReference")) {
    headerEntries = {
      ...headerEntries,
      ...this._getCollectionHeaderEntries(target)
    };
  }
  if (is$1(target, "bpmn:Participant")) {
    headerEntries = {
      ...headerEntries,
      ...this._getParticipantMultiplicityHeaderEntries(target)
    };
  }
  if (is$1(target, "bpmn:SubProcess") && !is$1(target, "bpmn:Transaction") && !isEventSubProcess(target)) {
    headerEntries = {
      ...headerEntries,
      ...this._getAdHocHeaderEntries(target)
    };
  }
  if (canBeNonInterrupting(target)) {
    headerEntries = {
      ...headerEntries,
      ...this._getNonInterruptingHeaderEntries(target)
    };
  }
  return headerEntries;
};
ReplaceMenuProvider.prototype._createEntries = function(target, replaceOptions) {
  var entries = {};
  var self2 = this;
  forEach$1(replaceOptions, function(replaceOption) {
    entries[replaceOption.actionName] = self2._createEntry(replaceOption, target);
  });
  return entries;
};
ReplaceMenuProvider.prototype._createSequenceFlowEntries = function(target, replaceOptions) {
  var businessObject = getBusinessObject(target);
  var entries = {};
  var modeling = this._modeling, moddle = this._moddle;
  var self2 = this;
  forEach$1(replaceOptions, function(replaceOption) {
    switch (replaceOption.actionName) {
      case "replace-with-default-flow":
        if (businessObject.sourceRef.default !== businessObject && (is$1(businessObject.sourceRef, "bpmn:ExclusiveGateway") || is$1(businessObject.sourceRef, "bpmn:InclusiveGateway") || is$1(businessObject.sourceRef, "bpmn:ComplexGateway") || is$1(businessObject.sourceRef, "bpmn:Activity"))) {
          entries = {
            ...entries,
            [replaceOption.actionName]: self2._createEntry(replaceOption, target, function() {
              modeling.updateProperties(target.source, { default: businessObject });
            })
          };
        }
        break;
      case "replace-with-conditional-flow":
        if (!businessObject.conditionExpression && is$1(businessObject.sourceRef, "bpmn:Activity")) {
          entries = {
            ...entries,
            [replaceOption.actionName]: self2._createEntry(replaceOption, target, function() {
              var conditionExpression = moddle.create("bpmn:FormalExpression", { body: "" });
              modeling.updateProperties(target, { conditionExpression });
            })
          };
        }
        break;
      default:
        if (is$1(businessObject.sourceRef, "bpmn:Activity") && businessObject.conditionExpression) {
          entries = {
            ...entries,
            [replaceOption.actionName]: self2._createEntry(replaceOption, target, function() {
              modeling.updateProperties(target, { conditionExpression: void 0 });
            })
          };
        }
        if ((is$1(businessObject.sourceRef, "bpmn:ExclusiveGateway") || is$1(businessObject.sourceRef, "bpmn:InclusiveGateway") || is$1(businessObject.sourceRef, "bpmn:ComplexGateway") || is$1(businessObject.sourceRef, "bpmn:Activity")) && businessObject.sourceRef.default === businessObject) {
          entries = {
            ...entries,
            [replaceOption.actionName]: self2._createEntry(replaceOption, target, function() {
              modeling.updateProperties(target.source, { default: void 0 });
            })
          };
        }
    }
  });
  return entries;
};
ReplaceMenuProvider.prototype._createEntry = function(replaceOption, target, action) {
  var translate2 = this._translate;
  var replaceElement = this._bpmnReplace.replaceElement;
  var replaceAction = function() {
    return replaceElement(target, replaceOption.target);
  };
  var label = replaceOption.label;
  if (label && typeof label === "function") {
    label = label(target);
  }
  action = action || replaceAction;
  return {
    label: translate2(label),
    className: replaceOption.className,
    action
  };
};
ReplaceMenuProvider.prototype._getLoopCharacteristicsHeaderEntries = function(target) {
  var self2 = this;
  var translate2 = this._translate;
  function toggleLoopEntry(event2, entry) {
    if (entry.active) {
      self2._modeling.updateProperties(target, { loopCharacteristics: void 0 });
      return;
    }
    const currentLoopCharacteristics = target.businessObject.get("loopCharacteristics"), newLoopCharacteristics = self2._moddle.create(entry.options.loopCharacteristics);
    if (currentLoopCharacteristics) {
      self2._moddleCopy.copyElement(currentLoopCharacteristics, newLoopCharacteristics);
    }
    newLoopCharacteristics.set("isSequential", entry.options.isSequential);
    self2._modeling.updateProperties(target, { loopCharacteristics: newLoopCharacteristics });
  }
  var businessObject = getBusinessObject(target), loopCharacteristics = businessObject.loopCharacteristics;
  var isSequential, isLoop, isParallel;
  if (loopCharacteristics) {
    isSequential = loopCharacteristics.isSequential;
    isLoop = loopCharacteristics.isSequential === void 0;
    isParallel = loopCharacteristics.isSequential !== void 0 && !loopCharacteristics.isSequential;
  }
  return {
    "toggle-parallel-mi": {
      className: "bpmn-icon-parallel-mi-marker",
      title: translate2("Parallel multi-instance"),
      active: isParallel,
      action: toggleLoopEntry,
      options: {
        loopCharacteristics: "bpmn:MultiInstanceLoopCharacteristics",
        isSequential: false
      }
    },
    "toggle-sequential-mi": {
      className: "bpmn-icon-sequential-mi-marker",
      title: translate2("Sequential multi-instance"),
      active: isSequential,
      action: toggleLoopEntry,
      options: {
        loopCharacteristics: "bpmn:MultiInstanceLoopCharacteristics",
        isSequential: true
      }
    },
    "toggle-loop": {
      className: "bpmn-icon-loop-marker",
      title: translate2("Loop"),
      active: isLoop,
      action: toggleLoopEntry,
      options: {
        loopCharacteristics: "bpmn:StandardLoopCharacteristics"
      }
    }
  };
};
ReplaceMenuProvider.prototype._getCollectionHeaderEntries = function(target) {
  var self2 = this;
  var translate2 = this._translate;
  var dataObject = target.businessObject.dataObjectRef;
  if (!dataObject) {
    return {};
  }
  function toggleIsCollection(event2, entry) {
    self2._modeling.updateModdleProperties(
      target,
      dataObject,
      { isCollection: !entry.active }
    );
  }
  var isCollection2 = dataObject.isCollection;
  return {
    "toggle-is-collection": {
      className: "bpmn-icon-parallel-mi-marker",
      title: translate2("Collection"),
      active: isCollection2,
      action: toggleIsCollection
    }
  };
};
ReplaceMenuProvider.prototype._getParticipantMultiplicityHeaderEntries = function(target) {
  var self2 = this;
  var bpmnFactory = this._bpmnFactory;
  var translate2 = this._translate;
  function toggleParticipantMultiplicity(event2, entry) {
    var isActive = entry.active;
    var participantMultiplicity2;
    if (!isActive) {
      participantMultiplicity2 = bpmnFactory.create("bpmn:ParticipantMultiplicity");
    }
    self2._modeling.updateProperties(
      target,
      { participantMultiplicity: participantMultiplicity2 }
    );
  }
  var participantMultiplicity = target.businessObject.participantMultiplicity;
  return {
    "toggle-participant-multiplicity": {
      className: "bpmn-icon-parallel-mi-marker",
      title: translate2("Participant multiplicity"),
      active: !!participantMultiplicity,
      action: toggleParticipantMultiplicity
    }
  };
};
ReplaceMenuProvider.prototype._getAdHocHeaderEntries = function(element) {
  var translate2 = this._translate;
  var businessObject = getBusinessObject(element);
  var isAdHoc = is$1(businessObject, "bpmn:AdHocSubProcess");
  var replaceElement = this._bpmnReplace.replaceElement;
  return {
    "toggle-adhoc": {
      className: "bpmn-icon-ad-hoc-marker",
      title: translate2("Ad-hoc"),
      active: isAdHoc,
      action: function(event2, entry) {
        if (isAdHoc) {
          return replaceElement(element, { type: "bpmn:SubProcess" }, {
            autoResize: false,
            layoutConnection: false
          });
        } else {
          return replaceElement(element, { type: "bpmn:AdHocSubProcess" }, {
            autoResize: false,
            layoutConnection: false
          });
        }
      }
    }
  };
};
ReplaceMenuProvider.prototype._getNonInterruptingHeaderEntries = function(element) {
  const translate2 = this._translate;
  const businessObject = getBusinessObject(element);
  const self2 = this;
  const interruptingProperty = getInterruptingProperty(element);
  const icon = is$1(element, "bpmn:BoundaryEvent") ? Icons["intermediate-event-non-interrupting"] : Icons["start-event-non-interrupting"];
  const isNonInterrupting = !businessObject[interruptingProperty];
  return {
    "toggle-non-interrupting": {
      imageHtml: icon,
      title: translate2("Toggle non-interrupting"),
      active: isNonInterrupting,
      action: function() {
        self2._modeling.updateProperties(element, {
          [interruptingProperty]: !!isNonInterrupting
        });
      }
    }
  };
};
const PopupMenuModule = {
  __depends__: [
    PopupMenuModule$1,
    ReplaceModule,
    AutoPlaceModule
  ],
  __init__: [
    "replaceMenuProvider"
  ],
  replaceMenuProvider: ["type", ReplaceMenuProvider]
};
function ContextPadProvider$1(config, injector, eventBus, contextPad, modeling, elementFactory, connect, create2, popupMenu, canvas, rules, translate2, appendPreview) {
  config = config || {};
  contextPad.registerProvider(this);
  this._contextPad = contextPad;
  this._modeling = modeling;
  this._elementFactory = elementFactory;
  this._connect = connect;
  this._create = create2;
  this._popupMenu = popupMenu;
  this._canvas = canvas;
  this._rules = rules;
  this._translate = translate2;
  this._eventBus = eventBus;
  this._appendPreview = appendPreview;
  if (config.autoPlace !== false) {
    this._autoPlace = injector.get("autoPlace", false);
  }
  eventBus.on("create.end", 250, function(event2) {
    var context = event2.context, shape = context.shape;
    if (!hasPrimaryModifier(event2) || !contextPad.isOpen(shape)) {
      return;
    }
    var entries = contextPad.getEntries(shape);
    if (entries.replace) {
      entries.replace.action.click(event2, shape);
    }
  });
}
ContextPadProvider$1.$inject = [
  "config.contextPad",
  "injector",
  "eventBus",
  "contextPad",
  "modeling",
  "elementFactory",
  "connect",
  "create",
  "popupMenu",
  "canvas",
  "rules",
  "translate",
  "appendPreview"
];
ContextPadProvider$1.prototype.getMultiElementContextPadEntries = function(elements) {
  var modeling = this._modeling;
  var actions = {};
  if (this._isDeleteAllowed(elements)) {
    assign$1(actions, {
      "delete": {
        group: "edit",
        className: "bpmn-icon-trash",
        title: this._translate("Delete"),
        action: {
          click: function(event2, elements2) {
            modeling.removeElements(elements2.slice());
          }
        }
      }
    });
  }
  return actions;
};
ContextPadProvider$1.prototype._isDeleteAllowed = function(elements) {
  var baseAllowed = this._rules.allowed("elements.delete", {
    elements
  });
  if (isArray$3(baseAllowed)) {
    return every(baseAllowed, function(element) {
      return includes$1(baseAllowed, element);
    });
  }
  return baseAllowed;
};
ContextPadProvider$1.prototype.getContextPadEntries = function(element) {
  var contextPad = this._contextPad, modeling = this._modeling, elementFactory = this._elementFactory, connect = this._connect, create2 = this._create, popupMenu = this._popupMenu, rules = this._rules, autoPlace = this._autoPlace, translate2 = this._translate, appendPreview = this._appendPreview;
  var actions = {};
  if (element.type === "label") {
    return actions;
  }
  var businessObject = element.businessObject;
  function startConnect(event2, element2) {
    connect.start(event2, element2);
  }
  function removeElement2(e2, element2) {
    modeling.removeElements([element2]);
  }
  function getReplaceMenuPosition(element2) {
    var Y_OFFSET = 5;
    var pad = contextPad.getPad(element2).html;
    var padRect = pad.getBoundingClientRect();
    var pos = {
      x: padRect.left,
      y: padRect.bottom + Y_OFFSET
    };
    return pos;
  }
  function appendAction(type, className, title, options) {
    function appendStart(event2, element2) {
      var shape = elementFactory.createShape(assign$1({ type }, options));
      create2.start(event2, shape, {
        source: element2
      });
      appendPreview.cleanUp();
    }
    var append2 = autoPlace ? function(_2, element2) {
      var shape = elementFactory.createShape(assign$1({ type }, options));
      autoPlace.append(element2, shape);
      appendPreview.cleanUp();
    } : appendStart;
    var previewAppend = autoPlace ? function(_2, element2) {
      appendPreview.create(element2, type, options);
      return () => {
        appendPreview.cleanUp();
      };
    } : null;
    return {
      group: "model",
      className,
      title,
      action: {
        dragstart: appendStart,
        click: append2,
        hover: previewAppend
      }
    };
  }
  function splitLaneHandler(count) {
    return function(_2, element2) {
      modeling.splitLane(element2, count);
      contextPad.open(element2, true);
    };
  }
  if (isAny(businessObject, ["bpmn:Lane", "bpmn:Participant"]) && isExpanded(element)) {
    var childLanes = getChildLanes(element);
    assign$1(actions, {
      "lane-insert-above": {
        group: "lane-insert-above",
        className: "bpmn-icon-lane-insert-above",
        title: translate2("Add lane above"),
        action: {
          click: function(event2, element2) {
            modeling.addLane(element2, "top");
          }
        }
      }
    });
    if (childLanes.length < 2) {
      if (isHorizontal$3(element) ? element.height >= 120 : element.width >= 120) {
        assign$1(actions, {
          "lane-divide-two": {
            group: "lane-divide",
            className: "bpmn-icon-lane-divide-two",
            title: translate2("Divide into two lanes"),
            action: {
              click: splitLaneHandler(2)
            }
          }
        });
      }
      if (isHorizontal$3(element) ? element.height >= 180 : element.width >= 180) {
        assign$1(actions, {
          "lane-divide-three": {
            group: "lane-divide",
            className: "bpmn-icon-lane-divide-three",
            title: translate2("Divide into three lanes"),
            action: {
              click: splitLaneHandler(3)
            }
          }
        });
      }
    }
    assign$1(actions, {
      "lane-insert-below": {
        group: "lane-insert-below",
        className: "bpmn-icon-lane-insert-below",
        title: translate2("Add lane below"),
        action: {
          click: function(event2, element2) {
            modeling.addLane(element2, "bottom");
          }
        }
      }
    });
  }
  if (is$1(businessObject, "bpmn:FlowNode")) {
    if (is$1(businessObject, "bpmn:EventBasedGateway")) {
      assign$1(actions, {
        "append.receive-task": appendAction(
          "bpmn:ReceiveTask",
          "bpmn-icon-receive-task",
          translate2("Append receive task")
        ),
        "append.message-intermediate-event": appendAction(
          "bpmn:IntermediateCatchEvent",
          "bpmn-icon-intermediate-event-catch-message",
          translate2("Append message intermediate catch event"),
          { eventDefinitionType: "bpmn:MessageEventDefinition" }
        ),
        "append.timer-intermediate-event": appendAction(
          "bpmn:IntermediateCatchEvent",
          "bpmn-icon-intermediate-event-catch-timer",
          translate2("Append timer intermediate catch event"),
          { eventDefinitionType: "bpmn:TimerEventDefinition" }
        ),
        "append.condition-intermediate-event": appendAction(
          "bpmn:IntermediateCatchEvent",
          "bpmn-icon-intermediate-event-catch-condition",
          translate2("Append conditional intermediate catch event"),
          { eventDefinitionType: "bpmn:ConditionalEventDefinition" }
        ),
        "append.signal-intermediate-event": appendAction(
          "bpmn:IntermediateCatchEvent",
          "bpmn-icon-intermediate-event-catch-signal",
          translate2("Append signal intermediate catch event"),
          { eventDefinitionType: "bpmn:SignalEventDefinition" }
        )
      });
    } else if (isEventType(businessObject, "bpmn:BoundaryEvent", "bpmn:CompensateEventDefinition")) {
      assign$1(actions, {
        "append.compensation-activity": appendAction(
          "bpmn:Task",
          "bpmn-icon-task",
          translate2("Append compensation activity"),
          {
            isForCompensation: true
          }
        )
      });
    } else if (!is$1(businessObject, "bpmn:EndEvent") && !businessObject.isForCompensation && !isEventType(businessObject, "bpmn:IntermediateThrowEvent", "bpmn:LinkEventDefinition") && !isEventSubProcess(businessObject)) {
      assign$1(actions, {
        "append.end-event": appendAction(
          "bpmn:EndEvent",
          "bpmn-icon-end-event-none",
          translate2("Append end event")
        ),
        "append.gateway": appendAction(
          "bpmn:ExclusiveGateway",
          "bpmn-icon-gateway-none",
          translate2("Append gateway")
        ),
        "append.append-task": appendAction(
          "bpmn:Task",
          "bpmn-icon-task",
          translate2("Append task")
        ),
        "append.intermediate-event": appendAction(
          "bpmn:IntermediateThrowEvent",
          "bpmn-icon-intermediate-event-none",
          translate2("Append intermediate/boundary event")
        )
      });
    }
  }
  if (!popupMenu.isEmpty(element, "bpmn-replace")) {
    assign$1(actions, {
      "replace": {
        group: "edit",
        className: "bpmn-icon-screw-wrench",
        title: translate2("Change element"),
        action: {
          click: function(event2, element2) {
            var position = assign$1(getReplaceMenuPosition(element2), {
              cursor: { x: event2.x, y: event2.y }
            });
            popupMenu.open(element2, "bpmn-replace", position, {
              title: translate2("Change element"),
              width: 300,
              search: true
            });
          }
        }
      }
    });
  }
  if (is$1(businessObject, "bpmn:SequenceFlow")) {
    assign$1(actions, {
      "append.text-annotation": appendAction(
        "bpmn:TextAnnotation",
        "bpmn-icon-text-annotation",
        translate2("Add text annotation")
      )
    });
  }
  if (isAny(businessObject, [
    "bpmn:FlowNode",
    "bpmn:InteractionNode",
    "bpmn:DataObjectReference",
    "bpmn:DataStoreReference"
  ])) {
    assign$1(actions, {
      "append.text-annotation": appendAction(
        "bpmn:TextAnnotation",
        "bpmn-icon-text-annotation",
        translate2("Add text annotation")
      ),
      "connect": {
        group: "connect",
        className: "bpmn-icon-connection-multi",
        title: translate2("Connect to other element"),
        action: {
          click: startConnect,
          dragstart: startConnect
        }
      }
    });
  }
  if (is$1(businessObject, "bpmn:TextAnnotation")) {
    assign$1(actions, {
      "connect": {
        group: "connect",
        className: "bpmn-icon-connection-multi",
        title: translate2("Connect using association"),
        action: {
          click: startConnect,
          dragstart: startConnect
        }
      }
    });
  }
  if (isAny(businessObject, ["bpmn:DataObjectReference", "bpmn:DataStoreReference"])) {
    assign$1(actions, {
      "connect": {
        group: "connect",
        className: "bpmn-icon-connection-multi",
        title: translate2("Connect using data input association"),
        action: {
          click: startConnect,
          dragstart: startConnect
        }
      }
    });
  }
  if (is$1(businessObject, "bpmn:Group")) {
    assign$1(actions, {
      "append.text-annotation": appendAction(
        "bpmn:TextAnnotation",
        "bpmn-icon-text-annotation",
        translate2("Add text annotation")
      )
    });
  }
  var deleteAllowed = rules.allowed("elements.delete", { elements: [element] });
  if (isArray$3(deleteAllowed)) {
    deleteAllowed = deleteAllowed[0] === element;
  }
  if (deleteAllowed) {
    assign$1(actions, {
      "delete": {
        group: "edit",
        className: "bpmn-icon-trash",
        title: translate2("Delete"),
        action: {
          click: removeElement2
        }
      }
    });
  }
  return actions;
};
function isEventType(businessObject, type, eventDefinitionType) {
  var isType2 = businessObject.$instanceOf(type);
  var isDefinition = false;
  var definitions = businessObject.eventDefinitions || [];
  forEach$1(definitions, function(def) {
    if (def.$type === eventDefinitionType) {
      isDefinition = true;
    }
  });
  return isType2 && isDefinition;
}
function includes$1(array, item) {
  return array.indexOf(item) !== -1;
}
const ContextPadModule = {
  __depends__: [
    AppendPreviewModule,
    DirectEditingModule,
    ContextPadModule$1,
    SelectionModule,
    ConnectModule,
    CreateModule,
    PopupMenuModule
  ],
  __init__: ["contextPadProvider"],
  contextPadProvider: ["type", ContextPadProvider$1]
};
var AXIS_DIMENSIONS = {
  horizontal: ["x", "width"],
  vertical: ["y", "height"]
};
var THRESHOLD = 5;
function DistributeElements(modeling, rules) {
  this._modeling = modeling;
  this._filters = [];
  this.registerFilter(function(elements) {
    var allowed = rules.allowed("elements.distribute", { elements });
    if (isArray$3(allowed)) {
      return allowed;
    }
    return allowed ? elements : [];
  });
}
DistributeElements.$inject = ["modeling", "rules"];
DistributeElements.prototype.registerFilter = function(filterFn) {
  if (typeof filterFn !== "function") {
    throw new Error("the filter has to be a function");
  }
  this._filters.push(filterFn);
};
DistributeElements.prototype.trigger = function(elements, orientation) {
  var modeling = this._modeling;
  var groups, distributableElements;
  if (elements.length < 3) {
    return;
  }
  this._setOrientation(orientation);
  distributableElements = this._filterElements(elements);
  groups = this._createGroups(distributableElements);
  if (groups.length <= 2) {
    return;
  }
  modeling.distributeElements(groups, this._axis, this._dimension);
  return groups;
};
DistributeElements.prototype._filterElements = function(elements) {
  var filters = this._filters, axis = this._axis, dimension = this._dimension, distributableElements = [].concat(elements);
  if (!filters.length) {
    return elements;
  }
  forEach$1(filters, function(filterFn) {
    distributableElements = filterFn(distributableElements, axis, dimension);
  });
  return distributableElements;
};
DistributeElements.prototype._createGroups = function(elements) {
  var rangeGroups = [], self2 = this, axis = this._axis, dimension = this._dimension;
  if (!axis) {
    throw new Error('must have a defined "axis" and "dimension"');
  }
  var sortedElements = sortBy(elements, axis);
  forEach$1(sortedElements, function(element, idx) {
    var elementRange = self2._findRange(element, axis, dimension), range;
    var previous = rangeGroups[rangeGroups.length - 1];
    if (previous && self2._hasIntersection(previous.range, elementRange)) {
      rangeGroups[rangeGroups.length - 1].elements.push(element);
    } else {
      range = { range: elementRange, elements: [element] };
      rangeGroups.push(range);
    }
  });
  return rangeGroups;
};
DistributeElements.prototype._setOrientation = function(direction) {
  var orientation = AXIS_DIMENSIONS[direction];
  this._axis = orientation[0];
  this._dimension = orientation[1];
};
DistributeElements.prototype._hasIntersection = function(rangeA, rangeB) {
  return Math.max(rangeA.min, rangeA.max) >= Math.min(rangeB.min, rangeB.max) && Math.min(rangeA.min, rangeA.max) <= Math.max(rangeB.min, rangeB.max);
};
DistributeElements.prototype._findRange = function(element) {
  var axis = element[this._axis], dimension = element[this._dimension];
  return {
    min: axis + THRESHOLD,
    max: axis + dimension - THRESHOLD
  };
};
const DistributeElementsModule$1 = {
  __init__: ["distributeElements"],
  distributeElements: ["type", DistributeElements]
};
function BpmnDistributeElements(eventBus) {
  RuleProvider.call(this, eventBus);
}
BpmnDistributeElements.$inject = ["eventBus"];
e$3(BpmnDistributeElements, RuleProvider);
BpmnDistributeElements.prototype.init = function() {
  this.addRule("elements.distribute", function(context) {
    var elements = context.elements;
    elements = filter(elements, function(element) {
      var cannotDistribute = isAny(element, [
        "bpmn:Association",
        "bpmn:BoundaryEvent",
        "bpmn:DataInputAssociation",
        "bpmn:DataOutputAssociation",
        "bpmn:Lane",
        "bpmn:MessageFlow",
        "bpmn:SequenceFlow",
        "bpmn:TextAnnotation"
      ]);
      return !(element.labelTarget || cannotDistribute);
    });
    elements = getParents$1(elements);
    if (elements.length < 3) {
      return false;
    }
    return elements;
  });
};
var icons = {
  horizontal: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
                <polyline points="450 400 450 150 1350 150 1350 400" style="fill:none;stroke:currentColor;stroke-width:100;stroke-linejoin:round;"/>
                <rect x="150" y="450" width="600" height="1200" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
                <rect x="1050" y="450" width="600" height="800" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
              </svg>`,
  vertical: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
              <polyline points="400 1350 150 1350 150 450 400 450" style="fill:none;stroke:currentColor;stroke-width:100;stroke-linejoin:round;"/>
              <rect x="450" y="150" width="1200" height="600" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
              <rect x="450" y="1050" width="800" height="600" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
            </svg>`
};
const ICONS = icons;
var LOW_PRIORITY$5 = 900;
function DistributeElementsMenuProvider(popupMenu, distributeElements, translate2, rules) {
  this._distributeElements = distributeElements;
  this._translate = translate2;
  this._popupMenu = popupMenu;
  this._rules = rules;
  popupMenu.registerProvider("align-elements", LOW_PRIORITY$5, this);
}
DistributeElementsMenuProvider.$inject = [
  "popupMenu",
  "distributeElements",
  "translate",
  "rules"
];
DistributeElementsMenuProvider.prototype.getPopupMenuEntries = function(target) {
  var entries = {};
  if (this._isAllowed(target)) {
    assign$1(entries, this._getEntries(target));
  }
  return entries;
};
DistributeElementsMenuProvider.prototype._isAllowed = function(elements) {
  return this._rules.allowed("elements.distribute", { elements });
};
DistributeElementsMenuProvider.prototype._getEntries = function(elements) {
  var distributeElements = this._distributeElements, translate2 = this._translate, popupMenu = this._popupMenu;
  var entries = {
    "distribute-elements-horizontal": {
      group: "distribute",
      title: translate2("Distribute elements horizontally"),
      className: "bjs-align-elements-menu-entry",
      imageHtml: ICONS["horizontal"],
      action: function(event2, entry) {
        distributeElements.trigger(elements, "horizontal");
        popupMenu.close();
      }
    },
    "distribute-elements-vertical": {
      group: "distribute",
      title: translate2("Distribute elements vertically"),
      imageHtml: ICONS["vertical"],
      action: function(event2, entry) {
        distributeElements.trigger(elements, "vertical");
        popupMenu.close();
      }
    }
  };
  return entries;
};
const DistributeElementsModule = {
  __depends__: [
    PopupMenuModule$1,
    DistributeElementsModule$1
  ],
  __init__: [
    "bpmnDistributeElements",
    "distributeElementsMenuProvider"
  ],
  bpmnDistributeElements: ["type", BpmnDistributeElements],
  distributeElementsMenuProvider: ["type", DistributeElementsMenuProvider]
};
var NOT_REGISTERED_ERROR = "is not a registered action", IS_REGISTERED_ERROR = "is already registered";
function EditorActions(eventBus, injector) {
  this._actions = {};
  var self2 = this;
  eventBus.on("diagram.init", function() {
    self2._registerDefaultActions(injector);
    eventBus.fire("editorActions.init", {
      editorActions: self2
    });
  });
}
EditorActions.$inject = [
  "eventBus",
  "injector"
];
EditorActions.prototype._registerDefaultActions = function(injector) {
  var commandStack = injector.get("commandStack", false);
  var modeling = injector.get("modeling", false);
  var selection = injector.get("selection", false);
  var zoomScroll = injector.get("zoomScroll", false);
  var copyPaste = injector.get("copyPaste", false);
  var canvas = injector.get("canvas", false);
  var rules = injector.get("rules", false);
  var keyboardMove = injector.get("keyboardMove", false);
  var keyboardMoveSelection = injector.get("keyboardMoveSelection", false);
  if (commandStack) {
    this.register("undo", function() {
      commandStack.undo();
    });
    this.register("redo", function() {
      commandStack.redo();
    });
  }
  if (copyPaste && selection) {
    this.register("copy", function() {
      var selectedElements = selection.get();
      if (selectedElements.length) {
        return copyPaste.copy(selectedElements);
      }
    });
  }
  if (copyPaste) {
    this.register("paste", function() {
      copyPaste.paste();
    });
  }
  if (zoomScroll) {
    this.register("stepZoom", function(opts) {
      zoomScroll.stepZoom(opts.value);
    });
  }
  if (canvas) {
    this.register("zoom", function(opts) {
      canvas.zoom(opts.value);
    });
  }
  if (modeling && selection && rules) {
    this.register("removeSelection", function() {
      var selectedElements = selection.get();
      if (!selectedElements.length) {
        return;
      }
      var allowed = rules.allowed("elements.delete", { elements: selectedElements }), removableElements;
      if (allowed === false) {
        return;
      } else if (isArray$3(allowed)) {
        removableElements = allowed;
      } else {
        removableElements = selectedElements;
      }
      if (removableElements.length) {
        modeling.removeElements(removableElements.slice());
      }
    });
  }
  if (keyboardMove) {
    this.register("moveCanvas", function(opts) {
      keyboardMove.moveCanvas(opts);
    });
  }
  if (keyboardMoveSelection) {
    this.register("moveSelection", function(opts) {
      keyboardMoveSelection.moveSelection(opts.direction, opts.accelerated);
    });
  }
};
EditorActions.prototype.trigger = function(action, opts) {
  if (!this._actions[action]) {
    throw error(action, NOT_REGISTERED_ERROR);
  }
  return this._actions[action](opts);
};
EditorActions.prototype.register = function(actions, listener) {
  var self2 = this;
  if (typeof actions === "string") {
    return this._registerAction(actions, listener);
  }
  forEach$1(actions, function(listener2, action) {
    self2._registerAction(action, listener2);
  });
};
EditorActions.prototype._registerAction = function(action, listener) {
  if (this.isRegistered(action)) {
    throw error(action, IS_REGISTERED_ERROR);
  }
  this._actions[action] = listener;
};
EditorActions.prototype.unregister = function(action) {
  if (!this.isRegistered(action)) {
    throw error(action, NOT_REGISTERED_ERROR);
  }
  this._actions[action] = void 0;
};
EditorActions.prototype.getActions = function() {
  return Object.keys(this._actions);
};
EditorActions.prototype.isRegistered = function(action) {
  return !!this._actions[action];
};
function error(action, message) {
  return new Error(action + " " + message);
}
const EditorActionsModule$1 = {
  __init__: ["editorActions"],
  editorActions: ["type", EditorActions]
};
function BpmnEditorActions(injector) {
  injector.invoke(EditorActions, this);
}
e$3(BpmnEditorActions, EditorActions);
BpmnEditorActions.$inject = [
  "injector"
];
BpmnEditorActions.prototype._registerDefaultActions = function(injector) {
  EditorActions.prototype._registerDefaultActions.call(this, injector);
  var canvas = injector.get("canvas", false);
  var elementRegistry = injector.get("elementRegistry", false);
  var selection = injector.get("selection", false);
  var spaceTool = injector.get("spaceTool", false);
  var lassoTool = injector.get("lassoTool", false);
  var handTool = injector.get("handTool", false);
  var globalConnect = injector.get("globalConnect", false);
  var distributeElements = injector.get("distributeElements", false);
  var alignElements = injector.get("alignElements", false);
  var directEditing = injector.get("directEditing", false);
  var searchPad = injector.get("searchPad", false);
  var modeling = injector.get("modeling", false);
  var contextPad = injector.get("contextPad", false);
  if (canvas && elementRegistry && selection) {
    this._registerAction("selectElements", function() {
      var rootElement = canvas.getRootElement();
      var elements = elementRegistry.filter(function(element) {
        return element !== rootElement;
      });
      selection.select(elements);
      return elements;
    });
  }
  if (spaceTool) {
    this._registerAction("spaceTool", function() {
      spaceTool.toggle();
    });
  }
  if (lassoTool) {
    this._registerAction("lassoTool", function() {
      lassoTool.toggle();
    });
  }
  if (handTool) {
    this._registerAction("handTool", function() {
      handTool.toggle();
    });
  }
  if (globalConnect) {
    this._registerAction("globalConnectTool", function() {
      globalConnect.toggle();
    });
  }
  if (selection && distributeElements) {
    this._registerAction("distributeElements", function(opts) {
      var currentSelection = selection.get(), type = opts.type;
      if (currentSelection.length) {
        distributeElements.trigger(currentSelection, type);
      }
    });
  }
  if (selection && alignElements) {
    this._registerAction("alignElements", function(opts) {
      var currentSelection = selection.get(), aligneableElements = [], type = opts.type;
      if (currentSelection.length) {
        aligneableElements = filter(currentSelection, function(element) {
          return !is$1(element, "bpmn:Lane");
        });
        alignElements.trigger(aligneableElements, type);
      }
    });
  }
  if (selection && modeling) {
    this._registerAction("setColor", function(opts) {
      var currentSelection = selection.get();
      if (currentSelection.length) {
        modeling.setColor(currentSelection, opts);
      }
    });
  }
  if (selection && directEditing) {
    this._registerAction("directEditing", function() {
      var currentSelection = selection.get();
      if (currentSelection.length) {
        directEditing.activate(currentSelection[0]);
      }
    });
  }
  if (searchPad) {
    this._registerAction("find", function() {
      searchPad.toggle();
    });
  }
  if (canvas && modeling) {
    this._registerAction("moveToOrigin", function() {
      var rootElement = canvas.getRootElement(), boundingBox, elements;
      if (is$1(rootElement, "bpmn:Collaboration")) {
        elements = elementRegistry.filter(function(element) {
          return is$1(element.parent, "bpmn:Collaboration");
        });
      } else {
        elements = elementRegistry.filter(function(element) {
          return element !== rootElement && !is$1(element.parent, "bpmn:SubProcess");
        });
      }
      boundingBox = getBBox(elements);
      modeling.moveElements(
        elements,
        { x: -boundingBox.x, y: -boundingBox.y },
        rootElement
      );
    });
  }
  if (selection && contextPad) {
    this._registerAction("replaceElement", function(event2) {
      contextPad.triggerEntry("replace", "click", event2);
    });
  }
};
const EditorActionsModule = {
  __depends__: [
    EditorActionsModule$1
  ],
  editorActions: ["type", BpmnEditorActions]
};
function BpmnGridSnapping(eventBus) {
  eventBus.on([
    "create.init",
    "shape.move.init"
  ], function(event2) {
    var context = event2.context, shape = event2.shape;
    if (isAny(shape, [
      "bpmn:Participant",
      "bpmn:SubProcess",
      "bpmn:TextAnnotation"
    ])) {
      if (!context.gridSnappingContext) {
        context.gridSnappingContext = {};
      }
      context.gridSnappingContext.snapLocation = "top-left";
    }
  });
}
BpmnGridSnapping.$inject = ["eventBus"];
var SPACING = 10;
function quantize(value, quantum, fn) {
  if (!fn) {
    fn = "round";
  }
  return Math[fn](value / quantum) * quantum;
}
var LOWER_PRIORITY = 1200;
var LOW_PRIORITY$4 = 800;
function GridSnapping(elementRegistry, eventBus, config) {
  var active = !config || config.active !== false;
  this._eventBus = eventBus;
  var self2 = this;
  eventBus.on("diagram.init", LOW_PRIORITY$4, function() {
    self2.setActive(active);
  });
  eventBus.on([
    "create.move",
    "create.end",
    "bendpoint.move.move",
    "bendpoint.move.end",
    "connect.move",
    "connect.end",
    "connectionSegment.move.move",
    "connectionSegment.move.end",
    "resize.move",
    "resize.end",
    "shape.move.move",
    "shape.move.end"
  ], LOWER_PRIORITY, function(event2) {
    var originalEvent = event2.originalEvent;
    if (!self2.active || originalEvent && isCmd(originalEvent)) {
      return;
    }
    var context = event2.context, gridSnappingContext = context.gridSnappingContext;
    if (!gridSnappingContext) {
      gridSnappingContext = context.gridSnappingContext = {};
    }
    ["x", "y"].forEach(function(axis) {
      var options = {};
      var snapOffset = getSnapOffset(event2, axis, elementRegistry);
      if (snapOffset) {
        options.offset = snapOffset;
      }
      var snapConstraints = getSnapConstraints(event2, axis);
      if (snapConstraints) {
        assign$1(options, snapConstraints);
      }
      if (!isSnapped(event2, axis)) {
        self2.snapEvent(event2, axis, options);
      }
    });
  });
}
GridSnapping.prototype.snapEvent = function(event2, axis, options) {
  var snappedValue = this.snapValue(event2[axis], options);
  setSnapped(event2, axis, snappedValue);
};
GridSnapping.prototype.getGridSpacing = function() {
  return SPACING;
};
GridSnapping.prototype.snapValue = function(value, options) {
  var offset = 0;
  if (options && options.offset) {
    offset = options.offset;
  }
  value += offset;
  value = quantize(value, SPACING);
  var min2, max2;
  if (options && options.min) {
    min2 = options.min;
    if (isNumber(min2)) {
      min2 = quantize(min2 + offset, SPACING, "ceil");
      value = Math.max(value, min2);
    }
  }
  if (options && options.max) {
    max2 = options.max;
    if (isNumber(max2)) {
      max2 = quantize(max2 + offset, SPACING, "floor");
      value = Math.min(value, max2);
    }
  }
  value -= offset;
  return value;
};
GridSnapping.prototype.isActive = function() {
  return this.active;
};
GridSnapping.prototype.setActive = function(active) {
  this.active = active;
  this._eventBus.fire("gridSnapping.toggle", { active });
};
GridSnapping.prototype.toggleActive = function() {
  this.setActive(!this.active);
};
GridSnapping.$inject = [
  "elementRegistry",
  "eventBus",
  "config.gridSnapping"
];
function getSnapConstraints(event2, axis) {
  var context = event2.context, createConstraints = context.createConstraints, resizeConstraints = context.resizeConstraints || {}, gridSnappingContext = context.gridSnappingContext, snapConstraints = gridSnappingContext.snapConstraints;
  if (snapConstraints && snapConstraints[axis]) {
    return snapConstraints[axis];
  }
  if (!snapConstraints) {
    snapConstraints = gridSnappingContext.snapConstraints = {};
  }
  if (!snapConstraints[axis]) {
    snapConstraints[axis] = {};
  }
  var direction = context.direction;
  if (createConstraints) {
    if (isHorizontal$2(axis)) {
      snapConstraints.x.min = createConstraints.left;
      snapConstraints.x.max = createConstraints.right;
    } else {
      snapConstraints.y.min = createConstraints.top;
      snapConstraints.y.max = createConstraints.bottom;
    }
  }
  var minResizeConstraints = resizeConstraints.min, maxResizeConstraints = resizeConstraints.max;
  if (minResizeConstraints) {
    if (isHorizontal$2(axis)) {
      if (isWest(direction)) {
        snapConstraints.x.max = minResizeConstraints.left;
      } else {
        snapConstraints.x.min = minResizeConstraints.right;
      }
    } else {
      if (isNorth(direction)) {
        snapConstraints.y.max = minResizeConstraints.top;
      } else {
        snapConstraints.y.min = minResizeConstraints.bottom;
      }
    }
  }
  if (maxResizeConstraints) {
    if (isHorizontal$2(axis)) {
      if (isWest(direction)) {
        snapConstraints.x.min = maxResizeConstraints.left;
      } else {
        snapConstraints.x.max = maxResizeConstraints.right;
      }
    } else {
      if (isNorth(direction)) {
        snapConstraints.y.min = maxResizeConstraints.top;
      } else {
        snapConstraints.y.max = maxResizeConstraints.bottom;
      }
    }
  }
  return snapConstraints[axis];
}
function getSnapOffset(event2, axis, elementRegistry) {
  var context = event2.context, shape = event2.shape, gridSnappingContext = context.gridSnappingContext, snapLocation = gridSnappingContext.snapLocation, snapOffset = gridSnappingContext.snapOffset;
  if (snapOffset && isNumber(snapOffset[axis])) {
    return snapOffset[axis];
  }
  if (!snapOffset) {
    snapOffset = gridSnappingContext.snapOffset = {};
  }
  if (!isNumber(snapOffset[axis])) {
    snapOffset[axis] = 0;
  }
  if (!shape) {
    return snapOffset[axis];
  }
  if (!elementRegistry.get(shape.id)) {
    if (isHorizontal$2(axis)) {
      snapOffset[axis] += shape[axis] + shape.width / 2;
    } else {
      snapOffset[axis] += shape[axis] + shape.height / 2;
    }
  }
  if (!snapLocation) {
    return snapOffset[axis];
  }
  if (axis === "x") {
    if (/left/.test(snapLocation)) {
      snapOffset[axis] -= shape.width / 2;
    } else if (/right/.test(snapLocation)) {
      snapOffset[axis] += shape.width / 2;
    }
  } else {
    if (/top/.test(snapLocation)) {
      snapOffset[axis] -= shape.height / 2;
    } else if (/bottom/.test(snapLocation)) {
      snapOffset[axis] += shape.height / 2;
    }
  }
  return snapOffset[axis];
}
function isHorizontal$2(axis) {
  return axis === "x";
}
function isNorth(direction) {
  return direction.indexOf("n") !== -1;
}
function isWest(direction) {
  return direction.indexOf("w") !== -1;
}
function ResizeBehavior(eventBus, gridSnapping) {
  CommandInterceptor.call(this, eventBus);
  this._gridSnapping = gridSnapping;
  var self2 = this;
  this.preExecute("shape.resize", function(event2) {
    var context = event2.context, hints = context.hints || {}, autoResize = hints.autoResize;
    if (!autoResize) {
      return;
    }
    var shape = context.shape, newBounds = context.newBounds;
    if (isString(autoResize)) {
      context.newBounds = self2.snapComplex(newBounds, autoResize);
    } else {
      context.newBounds = self2.snapSimple(shape, newBounds);
    }
  });
}
ResizeBehavior.$inject = [
  "eventBus",
  "gridSnapping",
  "modeling"
];
e$3(ResizeBehavior, CommandInterceptor);
ResizeBehavior.prototype.snapSimple = function(shape, newBounds) {
  var gridSnapping = this._gridSnapping;
  newBounds.width = gridSnapping.snapValue(newBounds.width, {
    min: newBounds.width
  });
  newBounds.height = gridSnapping.snapValue(newBounds.height, {
    min: newBounds.height
  });
  newBounds.x = shape.x + shape.width / 2 - newBounds.width / 2;
  newBounds.y = shape.y + shape.height / 2 - newBounds.height / 2;
  return newBounds;
};
ResizeBehavior.prototype.snapComplex = function(newBounds, directions2) {
  if (/w|e/.test(directions2)) {
    newBounds = this.snapHorizontally(newBounds, directions2);
  }
  if (/n|s/.test(directions2)) {
    newBounds = this.snapVertically(newBounds, directions2);
  }
  return newBounds;
};
ResizeBehavior.prototype.snapHorizontally = function(newBounds, directions2) {
  var gridSnapping = this._gridSnapping, west = /w/.test(directions2), east = /e/.test(directions2);
  var snappedNewBounds = {};
  snappedNewBounds.width = gridSnapping.snapValue(newBounds.width, {
    min: newBounds.width
  });
  if (east) {
    if (west) {
      snappedNewBounds.x = gridSnapping.snapValue(newBounds.x, {
        max: newBounds.x
      });
      snappedNewBounds.width += gridSnapping.snapValue(newBounds.x - snappedNewBounds.x, {
        min: newBounds.x - snappedNewBounds.x
      });
    } else {
      newBounds.x = newBounds.x + newBounds.width - snappedNewBounds.width;
    }
  }
  assign$1(newBounds, snappedNewBounds);
  return newBounds;
};
ResizeBehavior.prototype.snapVertically = function(newBounds, directions2) {
  var gridSnapping = this._gridSnapping, north = /n/.test(directions2), south = /s/.test(directions2);
  var snappedNewBounds = {};
  snappedNewBounds.height = gridSnapping.snapValue(newBounds.height, {
    min: newBounds.height
  });
  if (north) {
    if (south) {
      snappedNewBounds.y = gridSnapping.snapValue(newBounds.y, {
        max: newBounds.y
      });
      snappedNewBounds.height += gridSnapping.snapValue(newBounds.y - snappedNewBounds.y, {
        min: newBounds.y - snappedNewBounds.y
      });
    } else {
      newBounds.y = newBounds.y + newBounds.height - snappedNewBounds.height;
    }
  }
  assign$1(newBounds, snappedNewBounds);
  return newBounds;
};
var HIGH_PRIORITY$6 = 2e3;
function SpaceToolBehavior(eventBus, gridSnapping) {
  eventBus.on([
    "spaceTool.move",
    "spaceTool.end"
  ], HIGH_PRIORITY$6, function(event2) {
    var context = event2.context;
    if (!context.initialized) {
      return;
    }
    var axis = context.axis;
    var snapped;
    if (axis === "x") {
      snapped = gridSnapping.snapValue(event2.dx);
      event2.x = event2.x + snapped - event2.dx;
      event2.dx = snapped;
    } else {
      snapped = gridSnapping.snapValue(event2.dy);
      event2.y = event2.y + snapped - event2.dy;
      event2.dy = snapped;
    }
  });
}
SpaceToolBehavior.$inject = [
  "eventBus",
  "gridSnapping"
];
const GridSnappingBehaviorModule$1 = {
  __init__: [
    "gridSnappingResizeBehavior",
    "gridSnappingSpaceToolBehavior"
  ],
  gridSnappingResizeBehavior: ["type", ResizeBehavior],
  gridSnappingSpaceToolBehavior: ["type", SpaceToolBehavior]
};
const GridSnappingModule$1 = {
  __depends__: [GridSnappingBehaviorModule$1],
  __init__: ["gridSnapping"],
  gridSnapping: ["type", GridSnapping]
};
var HIGH_PRIORITY$5 = 2e3;
function GridSnappingAutoPlaceBehavior(eventBus, gridSnapping) {
  eventBus.on("autoPlace", HIGH_PRIORITY$5, function(context) {
    var source = context.source, sourceMid = getMid(source), shape = context.shape;
    var position = getNewShapePosition(source, shape);
    ["x", "y"].forEach(function(axis) {
      var options = {};
      if (position[axis] === sourceMid[axis]) {
        return;
      }
      if (position[axis] > sourceMid[axis]) {
        options.min = position[axis];
      } else {
        options.max = position[axis];
      }
      if (is$1(shape, "bpmn:TextAnnotation")) {
        if (isHorizontal$1(axis)) {
          options.offset = -shape.width / 2;
        } else {
          options.offset = -shape.height / 2;
        }
      }
      position[axis] = gridSnapping.snapValue(position[axis], options);
    });
    return position;
  });
}
GridSnappingAutoPlaceBehavior.$inject = [
  "eventBus",
  "gridSnapping"
];
function isHorizontal$1(axis) {
  return axis === "x";
}
var HIGHER_PRIORITY$4 = 1750;
function GridSnappingParticipantBehavior(canvas, eventBus, gridSnapping) {
  eventBus.on([
    "create.start",
    "shape.move.start"
  ], HIGHER_PRIORITY$4, function(event2) {
    var context = event2.context, shape = context.shape, rootElement = canvas.getRootElement();
    if (!is$1(shape, "bpmn:Participant") || !is$1(rootElement, "bpmn:Process") || !rootElement.children.length) {
      return;
    }
    var createConstraints = context.createConstraints;
    if (!createConstraints) {
      return;
    }
    shape.width = gridSnapping.snapValue(shape.width, { min: shape.width });
    shape.height = gridSnapping.snapValue(shape.height, { min: shape.height });
  });
}
GridSnappingParticipantBehavior.$inject = [
  "canvas",
  "eventBus",
  "gridSnapping"
];
var HIGH_PRIORITY$4 = 3e3;
function GridSnappingLayoutConnectionBehavior(eventBus, gridSnapping, modeling) {
  CommandInterceptor.call(this, eventBus);
  this._gridSnapping = gridSnapping;
  var self2 = this;
  this.postExecuted([
    "connection.create",
    "connection.layout"
  ], HIGH_PRIORITY$4, function(event2) {
    var context = event2.context, connection = context.connection, hints = context.hints || {}, waypoints = connection.waypoints;
    if (hints.connectionStart || hints.connectionEnd || hints.createElementsBehavior === false) {
      return;
    }
    if (!hasMiddleSegments(waypoints)) {
      return;
    }
    modeling.updateWaypoints(connection, self2.snapMiddleSegments(waypoints));
  });
}
GridSnappingLayoutConnectionBehavior.$inject = [
  "eventBus",
  "gridSnapping",
  "modeling"
];
e$3(GridSnappingLayoutConnectionBehavior, CommandInterceptor);
GridSnappingLayoutConnectionBehavior.prototype.snapMiddleSegments = function(waypoints) {
  var gridSnapping = this._gridSnapping, snapped;
  waypoints = waypoints.slice();
  for (var i2 = 1; i2 < waypoints.length - 2; i2++) {
    snapped = snapSegment(gridSnapping, waypoints[i2], waypoints[i2 + 1]);
    waypoints[i2] = snapped[0];
    waypoints[i2 + 1] = snapped[1];
  }
  return waypoints;
};
function hasMiddleSegments(waypoints) {
  return waypoints.length > 3;
}
function horizontallyAligned(aligned) {
  return aligned === "h";
}
function verticallyAligned(aligned) {
  return aligned === "v";
}
function snapSegment(gridSnapping, segmentStart, segmentEnd) {
  var aligned = pointsAligned(segmentStart, segmentEnd);
  var snapped = {};
  if (horizontallyAligned(aligned)) {
    snapped.y = gridSnapping.snapValue(segmentStart.y);
  }
  if (verticallyAligned(aligned)) {
    snapped.x = gridSnapping.snapValue(segmentStart.x);
  }
  if ("x" in snapped || "y" in snapped) {
    segmentStart = assign$1({}, segmentStart, snapped);
    segmentEnd = assign$1({}, segmentEnd, snapped);
  }
  return [segmentStart, segmentEnd];
}
const GridSnappingBehaviorModule = {
  __init__: [
    "gridSnappingAutoPlaceBehavior",
    "gridSnappingParticipantBehavior",
    "gridSnappingLayoutConnectionBehavior"
  ],
  gridSnappingAutoPlaceBehavior: ["type", GridSnappingAutoPlaceBehavior],
  gridSnappingParticipantBehavior: ["type", GridSnappingParticipantBehavior],
  gridSnappingLayoutConnectionBehavior: ["type", GridSnappingLayoutConnectionBehavior]
};
const GridSnappingModule = {
  __depends__: [
    GridSnappingModule$1,
    GridSnappingBehaviorModule
  ],
  __init__: ["bpmnGridSnapping"],
  bpmnGridSnapping: ["type", BpmnGridSnapping]
};
var LABEL_WIDTH = 30, LABEL_HEIGHT = 30;
function BpmnInteractionEvents(eventBus, interactionEvents) {
  this._interactionEvents = interactionEvents;
  var self2 = this;
  eventBus.on([
    "interactionEvents.createHit",
    "interactionEvents.updateHit"
  ], function(context) {
    var element = context.element, gfx = context.gfx;
    if (is$1(element, "bpmn:Lane")) {
      return self2._createParticipantHit(element, gfx);
    } else if (is$1(element, "bpmn:Participant")) {
      if (isExpanded(element)) {
        return self2._createParticipantHit(element, gfx);
      } else {
        return self2._createDefaultHit(element, gfx);
      }
    } else if (is$1(element, "bpmn:SubProcess")) {
      if (isExpanded(element)) {
        return self2._createSubProcessHit(element, gfx);
      } else {
        return self2._createDefaultHit(element, gfx);
      }
    }
  });
}
BpmnInteractionEvents.$inject = [
  "eventBus",
  "interactionEvents"
];
BpmnInteractionEvents.prototype._createDefaultHit = function(element, gfx) {
  this._interactionEvents.removeHits(gfx);
  this._interactionEvents.createDefaultHit(element, gfx);
  return true;
};
BpmnInteractionEvents.prototype._createParticipantHit = function(element, gfx) {
  this._interactionEvents.removeHits(gfx);
  this._interactionEvents.createBoxHit(gfx, "no-move", {
    width: element.width,
    height: element.height
  });
  this._interactionEvents.createBoxHit(gfx, "click-stroke", {
    width: element.width,
    height: element.height
  });
  var box = isHorizontal$3(element) ? {
    width: LABEL_WIDTH,
    height: element.height
  } : {
    width: element.width,
    height: LABEL_HEIGHT
  };
  this._interactionEvents.createBoxHit(gfx, "all", box);
  return true;
};
BpmnInteractionEvents.prototype._createSubProcessHit = function(element, gfx) {
  this._interactionEvents.removeHits(gfx);
  this._interactionEvents.createBoxHit(gfx, "no-move", {
    width: element.width,
    height: element.height
  });
  this._interactionEvents.createBoxHit(gfx, "click-stroke", {
    width: element.width,
    height: element.height
  });
  this._interactionEvents.createBoxHit(gfx, "all", {
    width: element.width,
    height: LABEL_HEIGHT
  });
  return true;
};
const InteractionEventsModule = {
  __init__: ["bpmnInteractionEvents"],
  bpmnInteractionEvents: ["type", BpmnInteractionEvents]
};
function BpmnKeyboardBindings(injector) {
  injector.invoke(KeyboardBindings, this);
}
e$3(BpmnKeyboardBindings, KeyboardBindings);
BpmnKeyboardBindings.$inject = [
  "injector"
];
BpmnKeyboardBindings.prototype.registerBindings = function(keyboard, editorActions) {
  KeyboardBindings.prototype.registerBindings.call(this, keyboard, editorActions);
  function addListener(action, fn) {
    if (editorActions.isRegistered(action)) {
      keyboard.addListener(fn);
    }
  }
  addListener("selectElements", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.isKey(["a", "A"], event2) && keyboard.isCmd(event2)) {
      editorActions.trigger("selectElements");
      return true;
    }
  });
  addListener("find", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.isKey(["f", "F"], event2) && keyboard.isCmd(event2)) {
      editorActions.trigger("find");
      return true;
    }
  });
  addListener("spaceTool", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.hasModifier(event2)) {
      return;
    }
    if (keyboard.isKey(["s", "S"], event2)) {
      editorActions.trigger("spaceTool");
      return true;
    }
  });
  addListener("lassoTool", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.hasModifier(event2)) {
      return;
    }
    if (keyboard.isKey(["l", "L"], event2)) {
      editorActions.trigger("lassoTool");
      return true;
    }
  });
  addListener("handTool", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.hasModifier(event2)) {
      return;
    }
    if (keyboard.isKey(["h", "H"], event2)) {
      editorActions.trigger("handTool");
      return true;
    }
  });
  addListener("globalConnectTool", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.hasModifier(event2)) {
      return;
    }
    if (keyboard.isKey(["c", "C"], event2)) {
      editorActions.trigger("globalConnectTool");
      return true;
    }
  });
  addListener("directEditing", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.hasModifier(event2)) {
      return;
    }
    if (keyboard.isKey(["e", "E"], event2)) {
      editorActions.trigger("directEditing");
      return true;
    }
  });
  addListener("replaceElement", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.hasModifier(event2)) {
      return;
    }
    if (keyboard.isKey(["r", "R"], event2)) {
      editorActions.trigger("replaceElement", event2);
      return true;
    }
  });
};
const KeyboardModule = {
  __depends__: [
    KeyboardModule$1
  ],
  __init__: ["keyboardBindings"],
  keyboardBindings: ["type", BpmnKeyboardBindings]
};
var DEFAULT_CONFIG = {
  moveSpeed: 1,
  moveSpeedAccelerated: 10
};
var HIGHER_PRIORITY$3 = 1500;
var LEFT = "left";
var UP = "up";
var RIGHT = "right";
var DOWN = "down";
var KEY_TO_DIRECTION = {
  ArrowLeft: LEFT,
  Left: LEFT,
  ArrowUp: UP,
  Up: UP,
  ArrowRight: RIGHT,
  Right: RIGHT,
  ArrowDown: DOWN,
  Down: DOWN
};
var DIRECTIONS_DELTA = {
  left: function(speed) {
    return {
      x: -speed,
      y: 0
    };
  },
  up: function(speed) {
    return {
      x: 0,
      y: -speed
    };
  },
  right: function(speed) {
    return {
      x: speed,
      y: 0
    };
  },
  down: function(speed) {
    return {
      x: 0,
      y: speed
    };
  }
};
function KeyboardMoveSelection(config, keyboard, modeling, rules, selection) {
  var self2 = this;
  this._config = assign$1({}, DEFAULT_CONFIG, config || {});
  keyboard.addListener(HIGHER_PRIORITY$3, function(event2) {
    var keyEvent = event2.keyEvent;
    var direction = KEY_TO_DIRECTION[keyEvent.key];
    if (!direction) {
      return;
    }
    if (keyboard.isCmd(keyEvent)) {
      return;
    }
    var accelerated = keyboard.isShift(keyEvent);
    self2.moveSelection(direction, accelerated);
    return true;
  });
  this.moveSelection = function(direction, accelerated) {
    var selectedElements = selection.get();
    if (!selectedElements.length) {
      return;
    }
    var speed = this._config[accelerated ? "moveSpeedAccelerated" : "moveSpeed"];
    var delta2 = DIRECTIONS_DELTA[direction](speed);
    var canMove2 = rules.allowed("elements.move", {
      shapes: selectedElements
    });
    if (canMove2) {
      modeling.moveElements(selectedElements, delta2);
    }
  };
}
KeyboardMoveSelection.$inject = [
  "config.keyboardMoveSelection",
  "keyboard",
  "modeling",
  "rules",
  "selection"
];
const KeyboardMoveSelectionModule = {
  __depends__: [
    KeyboardModule$1,
    SelectionModule
  ],
  __init__: [
    "keyboardMoveSelection"
  ],
  keyboardMoveSelection: ["type", KeyboardMoveSelection]
};
var DEFAULT_MIN_WIDTH = 10;
function Resize(eventBus, rules, modeling, dragging) {
  this._dragging = dragging;
  this._rules = rules;
  var self2 = this;
  function handleMove(context, delta2) {
    var shape = context.shape, direction = context.direction, resizeConstraints = context.resizeConstraints, newBounds;
    context.delta = delta2;
    newBounds = resizeBounds$1(shape, direction, delta2);
    context.newBounds = ensureConstraints$2(newBounds, resizeConstraints);
    context.canExecute = self2.canResize(context);
  }
  function handleStart(context) {
    var resizeConstraints = context.resizeConstraints, minBounds = context.minBounds;
    if (resizeConstraints !== void 0) {
      return;
    }
    if (minBounds === void 0) {
      minBounds = self2.computeMinResizeBox(context);
    }
    context.resizeConstraints = {
      min: asTRBL(minBounds)
    };
  }
  function handleEnd(context) {
    var shape = context.shape, canExecute = context.canExecute, newBounds = context.newBounds;
    if (canExecute) {
      newBounds = roundBounds(newBounds);
      if (!boundsChanged(shape, newBounds)) {
        return;
      }
      modeling.resizeShape(shape, newBounds);
    }
  }
  eventBus.on("resize.start", function(event2) {
    handleStart(event2.context);
  });
  eventBus.on("resize.move", function(event2) {
    var delta2 = {
      x: event2.dx,
      y: event2.dy
    };
    handleMove(event2.context, delta2);
  });
  eventBus.on("resize.end", function(event2) {
    handleEnd(event2.context);
  });
}
Resize.prototype.canResize = function(context) {
  var rules = this._rules;
  var ctx = pick(context, ["newBounds", "shape", "delta", "direction"]);
  return rules.allowed("shape.resize", ctx);
};
Resize.prototype.activate = function(event2, shape, contextOrDirection) {
  var dragging = this._dragging, context, direction;
  if (typeof contextOrDirection === "string") {
    contextOrDirection = {
      direction: contextOrDirection
    };
  }
  context = assign$1({ shape }, contextOrDirection);
  direction = context.direction;
  if (!direction) {
    throw new Error("must provide a direction (n|w|s|e|nw|se|ne|sw)");
  }
  dragging.init(event2, getReferencePoint(shape, direction), "resize", {
    autoActivate: true,
    cursor: getCursor(direction),
    data: {
      shape,
      context
    }
  });
};
Resize.prototype.computeMinResizeBox = function(context) {
  var shape = context.shape, direction = context.direction, minDimensions, childrenBounds;
  minDimensions = context.minDimensions || {
    width: DEFAULT_MIN_WIDTH,
    height: DEFAULT_MIN_WIDTH
  };
  childrenBounds = computeChildrenBBox(shape, context.childrenBoxPadding);
  return getMinResizeBounds(direction, shape, minDimensions, childrenBounds);
};
Resize.$inject = [
  "eventBus",
  "rules",
  "modeling",
  "dragging"
];
function boundsChanged(shape, newBounds) {
  return shape.x !== newBounds.x || shape.y !== newBounds.y || shape.width !== newBounds.width || shape.height !== newBounds.height;
}
function getReferencePoint(shape, direction) {
  var mid2 = getMid(shape), trbl = asTRBL(shape);
  var referencePoint = {
    x: mid2.x,
    y: mid2.y
  };
  if (direction.indexOf("n") !== -1) {
    referencePoint.y = trbl.top;
  } else if (direction.indexOf("s") !== -1) {
    referencePoint.y = trbl.bottom;
  }
  if (direction.indexOf("e") !== -1) {
    referencePoint.x = trbl.right;
  } else if (direction.indexOf("w") !== -1) {
    referencePoint.x = trbl.left;
  }
  return referencePoint;
}
function getCursor(direction) {
  var prefix2 = "resize-";
  if (direction === "n" || direction === "s") {
    return prefix2 + "ns";
  } else if (direction === "e" || direction === "w") {
    return prefix2 + "ew";
  } else if (direction === "nw" || direction === "se") {
    return prefix2 + "nwse";
  } else {
    return prefix2 + "nesw";
  }
}
var MARKER_RESIZING = "djs-resizing", MARKER_RESIZE_NOT_OK = "resize-not-ok";
var LOW_PRIORITY$3 = 500;
function ResizePreview(eventBus, canvas, previewSupport) {
  function updateFrame(context) {
    var shape = context.shape, bounds = context.newBounds, frame = context.frame;
    if (!frame) {
      frame = context.frame = previewSupport.addFrame(shape, canvas.getActiveLayer());
      canvas.addMarker(shape, MARKER_RESIZING);
    }
    if (bounds.width > 5) {
      attr(frame, { x: bounds.x, width: bounds.width });
    }
    if (bounds.height > 5) {
      attr(frame, { y: bounds.y, height: bounds.height });
    }
    if (context.canExecute) {
      classes(frame).remove(MARKER_RESIZE_NOT_OK);
    } else {
      classes(frame).add(MARKER_RESIZE_NOT_OK);
    }
  }
  function removeFrame(context) {
    var shape = context.shape, frame = context.frame;
    if (frame) {
      remove$1(context.frame);
    }
    canvas.removeMarker(shape, MARKER_RESIZING);
  }
  eventBus.on("resize.move", LOW_PRIORITY$3, function(event2) {
    updateFrame(event2.context);
  });
  eventBus.on("resize.cleanup", function(event2) {
    removeFrame(event2.context);
  });
}
ResizePreview.$inject = [
  "eventBus",
  "canvas",
  "previewSupport"
];
var HANDLE_OFFSET = -6, HANDLE_SIZE = 8, HANDLE_HIT_SIZE = 20;
var CLS_RESIZER = "djs-resizer";
var directions = ["n", "w", "s", "e", "nw", "ne", "se", "sw"];
function ResizeHandles(eventBus, canvas, selection, resize) {
  this._resize = resize;
  this._canvas = canvas;
  var self2 = this;
  eventBus.on("selection.changed", function(e2) {
    var newSelection = e2.newSelection;
    self2.removeResizers();
    if (newSelection.length === 1) {
      forEach$1(newSelection, bind$2(self2.addResizer, self2));
    }
  });
  eventBus.on("shape.changed", function(e2) {
    var shape = e2.element;
    if (selection.isSelected(shape)) {
      self2.removeResizers();
      self2.addResizer(shape);
    }
  });
}
ResizeHandles.prototype.makeDraggable = function(element, gfx, direction) {
  var resize = this._resize;
  function startResize(event2) {
    if (isPrimaryButton(event2)) {
      resize.activate(event2, element, direction);
    }
  }
  event.bind(gfx, "mousedown", startResize);
  event.bind(gfx, "touchstart", startResize);
};
ResizeHandles.prototype._createResizer = function(element, x2, y2, direction) {
  var resizersParent = this._getResizersParent();
  var offset = getHandleOffset(direction);
  var group = create$1("g");
  classes(group).add(CLS_RESIZER);
  classes(group).add(CLS_RESIZER + "-" + element.id);
  classes(group).add(CLS_RESIZER + "-" + direction);
  append(resizersParent, group);
  var visual = create$1("rect");
  attr(visual, {
    x: -HANDLE_SIZE / 2 + offset.x,
    y: -HANDLE_SIZE / 2 + offset.y,
    width: HANDLE_SIZE,
    height: HANDLE_SIZE
  });
  classes(visual).add(CLS_RESIZER + "-visual");
  append(group, visual);
  var hit = create$1("rect");
  attr(hit, {
    x: -HANDLE_HIT_SIZE / 2 + offset.x,
    y: -HANDLE_HIT_SIZE / 2 + offset.y,
    width: HANDLE_HIT_SIZE,
    height: HANDLE_HIT_SIZE
  });
  classes(hit).add(CLS_RESIZER + "-hit");
  append(group, hit);
  transform(group, x2, y2);
  return group;
};
ResizeHandles.prototype.createResizer = function(element, direction) {
  var point = getReferencePoint(element, direction);
  var resizer = this._createResizer(element, point.x, point.y, direction);
  this.makeDraggable(element, resizer, direction);
};
ResizeHandles.prototype.addResizer = function(element) {
  var self2 = this;
  if (isConnection(element) || !this._resize.canResize({ shape: element })) {
    return;
  }
  forEach$1(directions, function(direction) {
    self2.createResizer(element, direction);
  });
};
ResizeHandles.prototype.removeResizers = function() {
  var resizersParent = this._getResizersParent();
  clear(resizersParent);
};
ResizeHandles.prototype._getResizersParent = function() {
  return this._canvas.getLayer("resizers");
};
ResizeHandles.$inject = [
  "eventBus",
  "canvas",
  "selection",
  "resize"
];
function getHandleOffset(direction) {
  var offset = {
    x: 0,
    y: 0
  };
  if (direction.indexOf("e") !== -1) {
    offset.x = -HANDLE_OFFSET;
  } else if (direction.indexOf("w") !== -1) {
    offset.x = HANDLE_OFFSET;
  }
  if (direction.indexOf("s") !== -1) {
    offset.y = -HANDLE_OFFSET;
  } else if (direction.indexOf("n") !== -1) {
    offset.y = HANDLE_OFFSET;
  }
  return offset;
}
const ResizeModule = {
  __depends__: [
    RulesModule$1,
    DraggingModule,
    PreviewSupportModule
  ],
  __init__: [
    "resize",
    "resizePreview",
    "resizeHandles"
  ],
  resize: ["type", Resize],
  resizePreview: ["type", ResizePreview],
  resizeHandles: ["type", ResizeHandles]
};
var HIGH_PRIORITY$3 = 2e3;
function LabelEditingProvider(eventBus, bpmnFactory, canvas, directEditing, modeling, resizeHandles, textRenderer) {
  this._bpmnFactory = bpmnFactory;
  this._canvas = canvas;
  this._modeling = modeling;
  this._textRenderer = textRenderer;
  directEditing.registerProvider(this);
  eventBus.on("element.dblclick", function(event2) {
    activateDirectEdit(event2.element, true);
  });
  eventBus.on([
    "autoPlace.start",
    "canvas.viewbox.changing",
    "drag.init",
    "element.mousedown",
    "popupMenu.open",
    "root.set",
    "selection.changed"
  ], function() {
    if (directEditing.isActive()) {
      directEditing.complete();
    }
  });
  eventBus.on([
    "shape.remove",
    "connection.remove"
  ], HIGH_PRIORITY$3, function(event2) {
    if (directEditing.isActive(event2.element)) {
      directEditing.cancel();
    }
  });
  eventBus.on(["commandStack.changed"], function(e2) {
    if (directEditing.isActive()) {
      directEditing.cancel();
    }
  });
  eventBus.on("directEditing.activate", function(event2) {
    resizeHandles.removeResizers();
  });
  eventBus.on("create.end", 500, function(event2) {
    var context = event2.context, element = context.shape, canExecute = event2.context.canExecute, isTouch = event2.isTouch;
    if (isTouch) {
      return;
    }
    if (!canExecute) {
      return;
    }
    if (context.hints && context.hints.createElementsBehavior === false) {
      return;
    }
    activateDirectEdit(element);
  });
  eventBus.on("autoPlace.end", 500, function(event2) {
    activateDirectEdit(event2.shape);
  });
  function activateDirectEdit(element, force) {
    if (force || isAny(element, ["bpmn:Task", "bpmn:TextAnnotation", "bpmn:Participant"]) || isCollapsedSubProcess(element)) {
      directEditing.activate(element);
    }
  }
}
LabelEditingProvider.$inject = [
  "eventBus",
  "bpmnFactory",
  "canvas",
  "directEditing",
  "modeling",
  "resizeHandles",
  "textRenderer"
];
LabelEditingProvider.prototype.activate = function(element) {
  var text = getLabel(element);
  if (text === void 0) {
    return;
  }
  var context = {
    text
  };
  var bounds = this.getEditingBBox(element);
  assign$1(context, bounds);
  var options = {};
  if (isAny(element, [
    "bpmn:Task",
    "bpmn:Participant",
    "bpmn:Lane",
    "bpmn:CallActivity"
  ]) || isCollapsedSubProcess(element)) {
    assign$1(options, {
      centerVertically: true
    });
  }
  if (isLabelExternal(element)) {
    assign$1(options, {
      autoResize: true
    });
  }
  if (is$1(element, "bpmn:TextAnnotation")) {
    assign$1(options, {
      resizable: true,
      autoResize: true
    });
  }
  assign$1(context, {
    options
  });
  return context;
};
LabelEditingProvider.prototype.getEditingBBox = function(element) {
  var canvas = this._canvas;
  var target = element.label || element;
  var bbox = canvas.getAbsoluteBBox(target);
  var mid2 = {
    x: bbox.x + bbox.width / 2,
    y: bbox.y + bbox.height / 2
  };
  var bounds = { x: bbox.x, y: bbox.y };
  var zoom2 = canvas.zoom();
  var defaultStyle = this._textRenderer.getDefaultStyle(), externalStyle = this._textRenderer.getExternalStyle();
  var externalFontSize = externalStyle.fontSize * zoom2, externalLineHeight = externalStyle.lineHeight, defaultFontSize = defaultStyle.fontSize * zoom2, defaultLineHeight = defaultStyle.lineHeight;
  var style = {
    fontFamily: this._textRenderer.getDefaultStyle().fontFamily,
    fontWeight: this._textRenderer.getDefaultStyle().fontWeight
  };
  if (is$1(element, "bpmn:Lane") || isExpandedPool(element)) {
    var isHorizontalLane = isHorizontal$3(element);
    var laneBounds = isHorizontalLane ? {
      width: bbox.height,
      height: 30 * zoom2,
      x: bbox.x - bbox.height / 2 + 15 * zoom2,
      y: mid2.y - 30 * zoom2 / 2
    } : {
      width: bbox.width,
      height: 30 * zoom2
    };
    assign$1(bounds, laneBounds);
    assign$1(style, {
      fontSize: defaultFontSize + "px",
      lineHeight: defaultLineHeight,
      paddingTop: 7 * zoom2 + "px",
      paddingBottom: 7 * zoom2 + "px",
      paddingLeft: 5 * zoom2 + "px",
      paddingRight: 5 * zoom2 + "px",
      transform: isHorizontalLane ? "rotate(-90deg)" : null
    });
  }
  if (isCollapsedPool(element)) {
    var isHorizontalPool = isHorizontal$3(element);
    var poolBounds = isHorizontalPool ? {
      width: bbox.width,
      height: bbox.height
    } : {
      width: bbox.height,
      height: bbox.width,
      x: mid2.x - bbox.height / 2,
      y: mid2.y - bbox.width / 2
    };
    assign$1(bounds, poolBounds);
    assign$1(style, {
      fontSize: defaultFontSize + "px",
      lineHeight: defaultLineHeight,
      paddingTop: 7 * zoom2 + "px",
      paddingBottom: 7 * zoom2 + "px",
      paddingLeft: 5 * zoom2 + "px",
      paddingRight: 5 * zoom2 + "px",
      transform: isHorizontalPool ? null : "rotate(-90deg)"
    });
  }
  if (isAny(element, ["bpmn:Task", "bpmn:CallActivity"]) || isCollapsedSubProcess(element)) {
    assign$1(bounds, {
      width: bbox.width,
      height: bbox.height
    });
    assign$1(style, {
      fontSize: defaultFontSize + "px",
      lineHeight: defaultLineHeight,
      paddingTop: 7 * zoom2 + "px",
      paddingBottom: 7 * zoom2 + "px",
      paddingLeft: 5 * zoom2 + "px",
      paddingRight: 5 * zoom2 + "px"
    });
  }
  if (isExpandedSubProcess(element)) {
    assign$1(bounds, {
      width: bbox.width,
      x: bbox.x
    });
    assign$1(style, {
      fontSize: defaultFontSize + "px",
      lineHeight: defaultLineHeight,
      paddingTop: 7 * zoom2 + "px",
      paddingBottom: 7 * zoom2 + "px",
      paddingLeft: 5 * zoom2 + "px",
      paddingRight: 5 * zoom2 + "px"
    });
  }
  var width = 90 * zoom2, paddingTop = 7 * zoom2, paddingBottom = 4 * zoom2;
  if (target.labelTarget) {
    assign$1(bounds, {
      width,
      height: bbox.height + paddingTop + paddingBottom,
      x: mid2.x - width / 2,
      y: bbox.y - paddingTop
    });
    assign$1(style, {
      fontSize: externalFontSize + "px",
      lineHeight: externalLineHeight,
      paddingTop: paddingTop + "px",
      paddingBottom: paddingBottom + "px"
    });
  }
  if (isLabelExternal(target) && !hasExternalLabel(target) && !isLabel(target)) {
    var externalLabelMid = getExternalLabelMid(element);
    var absoluteBBox = canvas.getAbsoluteBBox({
      x: externalLabelMid.x,
      y: externalLabelMid.y,
      width: 0,
      height: 0
    });
    var height = externalFontSize + paddingTop + paddingBottom;
    assign$1(bounds, {
      width,
      height,
      x: absoluteBBox.x - width / 2,
      y: absoluteBBox.y - height / 2
    });
    assign$1(style, {
      fontSize: externalFontSize + "px",
      lineHeight: externalLineHeight,
      paddingTop: paddingTop + "px",
      paddingBottom: paddingBottom + "px"
    });
  }
  if (is$1(element, "bpmn:TextAnnotation")) {
    assign$1(bounds, {
      width: bbox.width,
      height: bbox.height,
      minWidth: 30 * zoom2,
      minHeight: 10 * zoom2
    });
    assign$1(style, {
      textAlign: "left",
      paddingTop: 5 * zoom2 + "px",
      paddingBottom: 7 * zoom2 + "px",
      paddingLeft: 7 * zoom2 + "px",
      paddingRight: 5 * zoom2 + "px",
      fontSize: defaultFontSize + "px",
      lineHeight: defaultLineHeight
    });
  }
  return { bounds, style };
};
LabelEditingProvider.prototype.update = function(element, newLabel, activeContextText, bounds) {
  var newBounds, bbox;
  if (is$1(element, "bpmn:TextAnnotation")) {
    bbox = this._canvas.getAbsoluteBBox(element);
    newBounds = {
      x: element.x,
      y: element.y,
      width: element.width / bbox.width * bounds.width,
      height: element.height / bbox.height * bounds.height
    };
  }
  if (isEmptyText(newLabel)) {
    newLabel = null;
  }
  this._modeling.updateLabel(element, newLabel, newBounds);
};
function isCollapsedSubProcess(element) {
  return is$1(element, "bpmn:SubProcess") && !isExpanded(element);
}
function isExpandedSubProcess(element) {
  return is$1(element, "bpmn:SubProcess") && isExpanded(element);
}
function isCollapsedPool(element) {
  return is$1(element, "bpmn:Participant") && !isExpanded(element);
}
function isExpandedPool(element) {
  return is$1(element, "bpmn:Participant") && isExpanded(element);
}
function isEmptyText(label) {
  return !label || !label.trim();
}
var MARKER_HIDDEN = "djs-element-hidden", MARKER_LABEL_HIDDEN = "djs-label-hidden";
function LabelEditingPreview(eventBus, canvas, pathMap) {
  var self2 = this;
  var defaultLayer = canvas.getDefaultLayer();
  var element, absoluteElementBBox, gfx;
  eventBus.on("directEditing.activate", function(context) {
    var activeProvider = context.active;
    element = activeProvider.element.label || activeProvider.element;
    if (is$1(element, "bpmn:TextAnnotation")) {
      absoluteElementBBox = canvas.getAbsoluteBBox(element);
      gfx = create$1("g");
      var textPathData = pathMap.getScaledPath("TEXT_ANNOTATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0,
          my: 0
        }
      });
      var path = self2.path = create$1("path");
      attr(path, {
        d: textPathData,
        strokeWidth: 2,
        stroke: getStrokeColor(element)
      });
      append(gfx, path);
      append(defaultLayer, gfx);
      translate$2(gfx, element.x, element.y);
    }
    if (is$1(element, "bpmn:TextAnnotation") || element.labelTarget) {
      canvas.addMarker(element, MARKER_HIDDEN);
    } else if (is$1(element, "bpmn:Task") || is$1(element, "bpmn:CallActivity") || is$1(element, "bpmn:SubProcess") || is$1(element, "bpmn:Participant")) {
      canvas.addMarker(element, MARKER_LABEL_HIDDEN);
    }
  });
  eventBus.on("directEditing.resize", function(context) {
    if (is$1(element, "bpmn:TextAnnotation")) {
      var height = context.height, dy = context.dy;
      var newElementHeight = Math.max(element.height / absoluteElementBBox.height * (height + dy), 0);
      var textPathData = pathMap.getScaledPath("TEXT_ANNOTATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: newElementHeight,
        position: {
          mx: 0,
          my: 0
        }
      });
      attr(self2.path, {
        d: textPathData
      });
    }
  });
  eventBus.on(["directEditing.complete", "directEditing.cancel"], function(context) {
    var activeProvider = context.active;
    if (activeProvider) {
      canvas.removeMarker(activeProvider.element.label || activeProvider.element, MARKER_HIDDEN);
      canvas.removeMarker(element, MARKER_LABEL_HIDDEN);
    }
    element = void 0;
    absoluteElementBBox = void 0;
    if (gfx) {
      remove$1(gfx);
      gfx = void 0;
    }
  });
}
LabelEditingPreview.$inject = [
  "eventBus",
  "canvas",
  "pathMap"
];
function getStrokeColor(element, defaultColor) {
  var di = getDi(element);
  return di.get("stroke") || defaultColor || "black";
}
const LabelEditingModule = {
  __depends__: [
    ChangeSupportModule,
    ResizeModule,
    DirectEditingModule
  ],
  __init__: [
    "labelEditingProvider",
    "labelEditingPreview"
  ],
  labelEditingProvider: ["type", LabelEditingProvider],
  labelEditingPreview: ["type", LabelEditingPreview]
};
var ids = new IdGenerator("tt");
function createRoot(parentNode) {
  var root = domify$1(
    '<div class="djs-tooltip-container" />'
  );
  assign(root, {
    position: "absolute",
    width: "0",
    height: "0"
  });
  parentNode.insertBefore(root, parentNode.firstChild);
  return root;
}
function setPosition(el, x2, y2) {
  assign(el, { left: x2 + "px", top: y2 + "px" });
}
function setVisible(el, visible) {
  el.style.display = visible === false ? "none" : "";
}
var tooltipClass = "djs-tooltip", tooltipSelector = "." + tooltipClass;
function Tooltips(eventBus, canvas) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._ids = ids;
  this._tooltipDefaults = {
    show: {
      minZoom: 0.7,
      maxZoom: 5
    }
  };
  this._tooltips = {};
  this._tooltipRoot = createRoot(canvas.getContainer());
  var self2 = this;
  delegate.bind(this._tooltipRoot, tooltipSelector, "mousedown", function(event2) {
    event2.stopPropagation();
  });
  delegate.bind(this._tooltipRoot, tooltipSelector, "mouseover", function(event2) {
    self2.trigger("mouseover", event2);
  });
  delegate.bind(this._tooltipRoot, tooltipSelector, "mouseout", function(event2) {
    self2.trigger("mouseout", event2);
  });
  this._init();
}
Tooltips.$inject = ["eventBus", "canvas"];
Tooltips.prototype.add = function(tooltip) {
  if (!tooltip.position) {
    throw new Error("must specifiy tooltip position");
  }
  if (!tooltip.html) {
    throw new Error("must specifiy tooltip html");
  }
  var id = this._ids.next();
  tooltip = assign$1({}, this._tooltipDefaults, tooltip, {
    id
  });
  this._addTooltip(tooltip);
  if (tooltip.timeout) {
    this.setTimeout(tooltip);
  }
  return id;
};
Tooltips.prototype.trigger = function(action, event2) {
  var node2 = event2.delegateTarget || event2.target;
  var tooltip = this.get(attr$1(node2, "data-tooltip-id"));
  if (!tooltip) {
    return;
  }
  if (action === "mouseover" && tooltip.timeout) {
    this.clearTimeout(tooltip);
  }
  if (action === "mouseout" && tooltip.timeout) {
    tooltip.timeout = 1e3;
    this.setTimeout(tooltip);
  }
};
Tooltips.prototype.get = function(id) {
  if (typeof id !== "string") {
    id = id.id;
  }
  return this._tooltips[id];
};
Tooltips.prototype.clearTimeout = function(tooltip) {
  tooltip = this.get(tooltip);
  if (!tooltip) {
    return;
  }
  var removeTimer = tooltip.removeTimer;
  if (removeTimer) {
    clearTimeout(removeTimer);
    tooltip.removeTimer = null;
  }
};
Tooltips.prototype.setTimeout = function(tooltip) {
  tooltip = this.get(tooltip);
  if (!tooltip) {
    return;
  }
  this.clearTimeout(tooltip);
  var self2 = this;
  tooltip.removeTimer = setTimeout(function() {
    self2.remove(tooltip);
  }, tooltip.timeout);
};
Tooltips.prototype.remove = function(id) {
  var tooltip = this.get(id);
  if (tooltip) {
    remove$2(tooltip.html);
    remove$2(tooltip.htmlContainer);
    delete tooltip.htmlContainer;
    delete this._tooltips[tooltip.id];
  }
};
Tooltips.prototype.show = function() {
  setVisible(this._tooltipRoot);
};
Tooltips.prototype.hide = function() {
  setVisible(this._tooltipRoot, false);
};
Tooltips.prototype._updateRoot = function(viewbox) {
  var a2 = viewbox.scale || 1;
  var d2 = viewbox.scale || 1;
  var matrix = "matrix(" + a2 + ",0,0," + d2 + "," + -1 * viewbox.x * a2 + "," + -1 * viewbox.y * d2 + ")";
  this._tooltipRoot.style.transform = matrix;
  this._tooltipRoot.style["-ms-transform"] = matrix;
};
Tooltips.prototype._addTooltip = function(tooltip) {
  var id = tooltip.id, html = tooltip.html, htmlContainer, tooltipRoot = this._tooltipRoot;
  if (html.get && html.constructor.prototype.jquery) {
    html = html.get(0);
  }
  if (isString(html)) {
    html = domify$1(html);
  }
  htmlContainer = domify$1('<div data-tooltip-id="' + id + '" class="' + tooltipClass + '">');
  assign(htmlContainer, { position: "absolute" });
  htmlContainer.appendChild(html);
  if (tooltip.type) {
    classes$1(htmlContainer).add("djs-tooltip-" + tooltip.type);
  }
  if (tooltip.className) {
    classes$1(htmlContainer).add(tooltip.className);
  }
  tooltip.htmlContainer = htmlContainer;
  tooltipRoot.appendChild(htmlContainer);
  this._tooltips[id] = tooltip;
  this._updateTooltip(tooltip);
};
Tooltips.prototype._updateTooltip = function(tooltip) {
  var position = tooltip.position, htmlContainer = tooltip.htmlContainer;
  setPosition(htmlContainer, position.x, position.y);
};
Tooltips.prototype._updateTooltipVisibilty = function(viewbox) {
  forEach$1(this._tooltips, function(tooltip) {
    var show = tooltip.show, htmlContainer = tooltip.htmlContainer, visible = true;
    if (show) {
      if (show.minZoom > viewbox.scale || show.maxZoom < viewbox.scale) {
        visible = false;
      }
      setVisible(htmlContainer, visible);
    }
  });
};
Tooltips.prototype._init = function() {
  var self2 = this;
  function updateViewbox(viewbox) {
    self2._updateRoot(viewbox);
    self2._updateTooltipVisibilty(viewbox);
    self2.show();
  }
  this._eventBus.on("canvas.viewbox.changing", function(event2) {
    self2.hide();
  });
  this._eventBus.on("canvas.viewbox.changed", function(event2) {
    updateViewbox(event2.viewbox);
  });
};
const TooltipsModule = {
  __init__: ["tooltips"],
  tooltips: ["type", Tooltips]
};
var COLLAB_ERR_MSG = "flow elements must be children of pools/participants";
function ModelingFeedback(eventBus, tooltips, translate2) {
  function showError(position, message, timeout) {
    tooltips.add({
      position: {
        x: position.x + 5,
        y: position.y + 5
      },
      type: "error",
      timeout: timeout || 2e3,
      html: "<div>" + message + "</div>"
    });
  }
  eventBus.on(["shape.move.rejected", "create.rejected"], function(event2) {
    var context = event2.context, shape = context.shape, target = context.target;
    if (is$1(target, "bpmn:Collaboration") && is$1(shape, "bpmn:FlowNode")) {
      showError(event2, translate2(COLLAB_ERR_MSG));
    }
  });
}
ModelingFeedback.$inject = [
  "eventBus",
  "tooltips",
  "translate"
];
const ModelingFeedbackModule = {
  __depends__: [
    TooltipsModule
  ],
  __init__: [
    "modelingFeedback"
  ],
  modelingFeedback: ["type", ModelingFeedback]
};
var LOW_PRIORITY$2 = 500, MEDIUM_PRIORITY = 1250, HIGH_PRIORITY$2 = 1500;
var round = Math.round;
function mid(element) {
  return {
    x: element.x + round(element.width / 2),
    y: element.y + round(element.height / 2)
  };
}
function MoveEvents(eventBus, dragging, modeling, selection, rules) {
  function canMove2(shapes, delta2, position, target) {
    return rules.allowed("elements.move", {
      shapes,
      delta: delta2,
      position,
      target
    });
  }
  eventBus.on("shape.move.start", HIGH_PRIORITY$2, function(event2) {
    var context = event2.context, shape = event2.shape, shapes = selection.get().slice();
    if (shapes.indexOf(shape) === -1) {
      shapes = [shape];
    }
    shapes = removeNested(shapes);
    assign$1(context, {
      shapes,
      validatedShapes: shapes,
      shape
    });
  });
  eventBus.on("shape.move.start", MEDIUM_PRIORITY, function(event2) {
    var context = event2.context, validatedShapes = context.validatedShapes, canExecute;
    canExecute = context.canExecute = canMove2(validatedShapes);
    if (!canExecute) {
      return false;
    }
  });
  eventBus.on("shape.move.move", LOW_PRIORITY$2, function(event2) {
    var context = event2.context, validatedShapes = context.validatedShapes, hover = event2.hover, delta2 = { x: event2.dx, y: event2.dy }, position = { x: event2.x, y: event2.y }, canExecute;
    canExecute = canMove2(validatedShapes, delta2, position, hover);
    context.delta = delta2;
    context.canExecute = canExecute;
    if (canExecute === null) {
      context.target = null;
      return;
    }
    context.target = hover;
  });
  eventBus.on("shape.move.end", function(event2) {
    var context = event2.context;
    var delta2 = context.delta, canExecute = context.canExecute, isAttach = canExecute === "attach", shapes = context.shapes;
    if (canExecute === false) {
      return false;
    }
    delta2.x = round(delta2.x);
    delta2.y = round(delta2.y);
    if (delta2.x === 0 && delta2.y === 0) {
      return;
    }
    modeling.moveElements(shapes, delta2, context.target, {
      primaryShape: context.shape,
      attach: isAttach
    });
  });
  eventBus.on("element.mousedown", function(event2) {
    if (!isPrimaryButton(event2)) {
      return;
    }
    var originalEvent = getOriginal$1(event2);
    if (!originalEvent) {
      throw new Error("must supply DOM mousedown event");
    }
    return start(originalEvent, event2.element);
  });
  function start(event2, element, activate, context) {
    if (isObject(activate)) {
      context = activate;
      activate = false;
    }
    if (element.waypoints || !element.parent) {
      return;
    }
    if (classes(event2.target).has("djs-hit-no-move")) {
      return;
    }
    var referencePoint = mid(element);
    dragging.init(event2, referencePoint, "shape.move", {
      cursor: "grabbing",
      autoActivate: activate,
      data: {
        shape: element,
        context: context || {}
      }
    });
    return true;
  }
  this.start = start;
}
MoveEvents.$inject = [
  "eventBus",
  "dragging",
  "modeling",
  "selection",
  "rules"
];
function removeNested(elements) {
  var ids2 = groupBy(elements, "id");
  return filter(elements, function(element) {
    while (element = element.parent) {
      if (ids2[element.id]) {
        return false;
      }
    }
    return true;
  });
}
var LOW_PRIORITY$1 = 499;
var MARKER_DRAGGING = "djs-dragging", MARKER_OK$1 = "drop-ok", MARKER_NOT_OK$1 = "drop-not-ok", MARKER_NEW_PARENT = "new-parent", MARKER_ATTACH = "attach-ok";
function MovePreview(eventBus, canvas, styles, previewSupport) {
  function getVisualDragShapes(shapes) {
    var elements = getAllDraggedElements(shapes);
    var filteredElements = removeEdges(elements);
    return filteredElements;
  }
  function getAllDraggedElements(shapes) {
    var allShapes = selfAndAllChildren(shapes, true);
    var allConnections = map$1(allShapes, function(shape) {
      return (shape.incoming || []).concat(shape.outgoing || []);
    });
    return flatten(allShapes.concat(allConnections));
  }
  function setMarker(element, marker) {
    [MARKER_ATTACH, MARKER_OK$1, MARKER_NOT_OK$1, MARKER_NEW_PARENT].forEach(function(m2) {
      if (m2 === marker) {
        canvas.addMarker(element, m2);
      } else {
        canvas.removeMarker(element, m2);
      }
    });
  }
  function makeDraggable(context, element, addMarker) {
    previewSupport.addDragger(element, context.dragGroup);
    if (addMarker) {
      canvas.addMarker(element, MARKER_DRAGGING);
    }
    if (context.allDraggedElements) {
      context.allDraggedElements.push(element);
    } else {
      context.allDraggedElements = [element];
    }
  }
  eventBus.on("shape.move.start", LOW_PRIORITY$1, function(event2) {
    var context = event2.context, dragShapes = context.shapes, allDraggedElements = context.allDraggedElements;
    var visuallyDraggedShapes = getVisualDragShapes(dragShapes);
    if (!context.dragGroup) {
      var dragGroup = create$1("g");
      attr(dragGroup, styles.cls("djs-drag-group", ["no-events"]));
      var activeLayer = canvas.getActiveLayer();
      append(activeLayer, dragGroup);
      context.dragGroup = dragGroup;
    }
    visuallyDraggedShapes.forEach(function(shape) {
      previewSupport.addDragger(shape, context.dragGroup);
    });
    if (!allDraggedElements) {
      allDraggedElements = getAllDraggedElements(dragShapes);
    } else {
      allDraggedElements = flatten([
        allDraggedElements,
        getAllDraggedElements(dragShapes)
      ]);
    }
    forEach$1(allDraggedElements, function(e2) {
      canvas.addMarker(e2, MARKER_DRAGGING);
    });
    context.allDraggedElements = allDraggedElements;
    context.differentParents = haveDifferentParents(dragShapes);
  });
  eventBus.on("shape.move.move", LOW_PRIORITY$1, function(event2) {
    var context = event2.context, dragGroup = context.dragGroup, target = context.target, parent = context.shape.parent, canExecute = context.canExecute;
    if (target) {
      if (canExecute === "attach") {
        setMarker(target, MARKER_ATTACH);
      } else if (context.canExecute && target && target.id !== parent.id) {
        setMarker(target, MARKER_NEW_PARENT);
      } else {
        setMarker(target, context.canExecute ? MARKER_OK$1 : MARKER_NOT_OK$1);
      }
    }
    translate$2(dragGroup, event2.dx, event2.dy);
  });
  eventBus.on(["shape.move.out", "shape.move.cleanup"], function(event2) {
    var context = event2.context, target = context.target;
    if (target) {
      setMarker(target, null);
    }
  });
  eventBus.on("shape.move.cleanup", function(event2) {
    var context = event2.context, allDraggedElements = context.allDraggedElements, dragGroup = context.dragGroup;
    forEach$1(allDraggedElements, function(e2) {
      canvas.removeMarker(e2, MARKER_DRAGGING);
    });
    if (dragGroup) {
      remove$1(dragGroup);
    }
  });
  this.makeDraggable = makeDraggable;
}
MovePreview.$inject = [
  "eventBus",
  "canvas",
  "styles",
  "previewSupport"
];
function removeEdges(elements) {
  var filteredElements = filter(elements, function(element) {
    if (!isConnection(element)) {
      return true;
    } else {
      return find(elements, matchPattern({ id: element.source.id })) && find(elements, matchPattern({ id: element.target.id }));
    }
  });
  return filteredElements;
}
function haveDifferentParents(elements) {
  return size(groupBy(elements, function(e2) {
    return e2.parent && e2.parent.id;
  })) !== 1;
}
const MoveModule = {
  __depends__: [
    InteractionEventsModule$1,
    SelectionModule,
    Ouline,
    RulesModule$1,
    DraggingModule,
    PreviewSupportModule
  ],
  __init__: [
    "move",
    "movePreview"
  ],
  move: ["type", MoveEvents],
  movePreview: ["type", MovePreview]
};
const DATA_OBJECT_REFERENCE_OUTLINE_PATH = "M44.7648 11.3263L36.9892 2.64074C36.0451 1.58628 34.5651 0.988708 33.1904 0.988708H5.98667C3.22688 0.988708 0.989624 3.34892 0.989624 6.26039V55.0235C0.989624 57.9349 3.22688 60.2952 5.98667 60.2952H40.966C43.7257 60.2952 45.963 57.9349 45.963 55.0235V14.9459C45.963 13.5998 45.6407 12.3048 44.7648 11.3263Z";
const DATA_STORE_REFERENCE_OUTLINE_PATH = "M1.03845 48.1347C1.03845 49.3511 1.07295 50.758 1.38342 52.064C1.69949 53.3938 2.32428 54.7154 3.56383 55.6428C6.02533 57.4841 10.1161 58.7685 14.8212 59.6067C19.5772 60.4538 25.1388 60.8738 30.6831 60.8738C36.2276 60.8738 41.7891 60.4538 46.545 59.6067C51.2504 58.7687 55.3412 57.4842 57.8028 55.6429C59.0424 54.7156 59.6673 53.3938 59.9834 52.064C60.2938 50.7579 60.3285 49.351 60.3285 48.1344V13.8415C60.3285 12.6249 60.2938 11.218 59.9834 9.91171C59.6673 8.58194 59.0423 7.2602 57.8027 6.33294C55.341 4.49168 51.2503 3.20723 46.545 2.36914C41.7891 1.522 36.2276 1.10204 30.6831 1.10205C25.1388 1.10206 19.5772 1.52206 14.8213 2.36923C10.1162 3.20734 6.02543 4.49183 3.5639 6.33314C2.32433 7.26038 1.69951 8.58206 1.38343 9.91181C1.07295 11.2179 1.03845 12.6247 1.03845 13.8411V48.1347Z";
const DATA_OBJECT_REFERENCE_STANDARD_SIZE = { width: 36, height: 50 };
const DATA_STORE_REFERENCE_STANDARD_SIZE = { width: 50, height: 50 };
function createPath(path, attrs, OUTLINE_STYLE) {
  return create$1("path", {
    d: path,
    strokeWidth: 2,
    transform: `translate(${attrs.x}, ${attrs.y})`,
    ...OUTLINE_STYLE
  });
}
const DEFAULT_OFFSET = 5;
function OutlineProvider(outline, styles) {
  this._styles = styles;
  outline.registerProvider(this);
}
OutlineProvider.$inject = [
  "outline",
  "styles"
];
OutlineProvider.prototype.getOutline = function(element) {
  const OUTLINE_STYLE = this._styles.cls("djs-outline", ["no-fill"]);
  var outline;
  if (isLabel(element)) {
    return;
  }
  if (is$1(element, "bpmn:Gateway")) {
    outline = create$1("rect");
    assign$1(outline.style, {
      "transform-box": "fill-box",
      "transform": "rotate(45deg)",
      "transform-origin": "center"
    });
    attr(outline, assign$1({
      x: 2,
      y: 2,
      rx: 4,
      width: element.width - 4,
      height: element.height - 4
    }, OUTLINE_STYLE));
  } else if (isAny(element, ["bpmn:Task", "bpmn:SubProcess", "bpmn:Group"])) {
    outline = create$1("rect");
    attr(outline, assign$1({
      x: -DEFAULT_OFFSET,
      y: -DEFAULT_OFFSET,
      rx: 14,
      width: element.width + DEFAULT_OFFSET * 2,
      height: element.height + DEFAULT_OFFSET * 2
    }, OUTLINE_STYLE));
  } else if (is$1(element, "bpmn:EndEvent")) {
    outline = create$1("circle");
    attr(outline, assign$1({
      cx: element.width / 2,
      cy: element.height / 2,
      r: element.width / 2 + DEFAULT_OFFSET + 1
    }, OUTLINE_STYLE));
  } else if (is$1(element, "bpmn:Event")) {
    outline = create$1("circle");
    attr(outline, assign$1({
      cx: element.width / 2,
      cy: element.height / 2,
      r: element.width / 2 + DEFAULT_OFFSET
    }, OUTLINE_STYLE));
  } else if (is$1(element, "bpmn:DataObjectReference") && isStandardSize(element, "bpmn:DataObjectReference")) {
    outline = createPath(
      DATA_OBJECT_REFERENCE_OUTLINE_PATH,
      { x: -6, y: -6 },
      OUTLINE_STYLE
    );
  } else if (is$1(element, "bpmn:DataStoreReference") && isStandardSize(element, "bpmn:DataStoreReference")) {
    outline = createPath(
      DATA_STORE_REFERENCE_OUTLINE_PATH,
      { x: -6, y: -6 },
      OUTLINE_STYLE
    );
  }
  return outline;
};
OutlineProvider.prototype.updateOutline = function(element, outline) {
  if (isLabel(element)) {
    return;
  }
  if (isAny(element, ["bpmn:SubProcess", "bpmn:Group"])) {
    attr(outline, {
      width: element.width + DEFAULT_OFFSET * 2,
      height: element.height + DEFAULT_OFFSET * 2
    });
    return true;
  } else if (isAny(element, [
    "bpmn:Event",
    "bpmn:Gateway",
    "bpmn:DataStoreReference",
    "bpmn:DataObjectReference"
  ])) {
    return true;
  }
  return false;
};
function isStandardSize(element, type) {
  var standardSize;
  if (type === "bpmn:DataObjectReference") {
    standardSize = DATA_OBJECT_REFERENCE_STANDARD_SIZE;
  } else if (type === "bpmn:DataStoreReference") {
    standardSize = DATA_STORE_REFERENCE_STANDARD_SIZE;
  }
  return element.width === standardSize.width && element.height === standardSize.height;
}
const OutlineModule = {
  __depends__: [
    Ouline
  ],
  __init__: ["outlineProvider"],
  outlineProvider: ["type", OutlineProvider]
};
var TOGGLE_SELECTOR = ".djs-palette-toggle", ENTRY_SELECTOR = ".entry", ELEMENT_SELECTOR = TOGGLE_SELECTOR + ", " + ENTRY_SELECTOR;
var PALETTE_PREFIX = "djs-palette-", PALETTE_SHOWN_CLS = "shown", PALETTE_OPEN_CLS = "open", PALETTE_TWO_COLUMN_CLS = "two-column";
var DEFAULT_PRIORITY = 1e3;
function Palette(eventBus, canvas) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  var self2 = this;
  eventBus.on("tool-manager.update", function(event2) {
    var tool = event2.tool;
    self2.updateToolHighlight(tool);
  });
  eventBus.on("i18n.changed", function() {
    self2._update();
  });
  eventBus.on("diagram.init", function() {
    self2._diagramInitialized = true;
    self2._rebuild();
  });
}
Palette.$inject = ["eventBus", "canvas"];
Palette.prototype.registerProvider = function(priority, provider) {
  if (!provider) {
    provider = priority;
    priority = DEFAULT_PRIORITY;
  }
  this._eventBus.on("palette.getProviders", priority, function(event2) {
    event2.providers.push(provider);
  });
  this._rebuild();
};
Palette.prototype.getEntries = function() {
  var providers = this._getProviders();
  return providers.reduce(addPaletteEntries, {});
};
Palette.prototype._rebuild = function() {
  if (!this._diagramInitialized) {
    return;
  }
  var providers = this._getProviders();
  if (!providers.length) {
    return;
  }
  if (!this._container) {
    this._init();
  }
  this._update();
};
Palette.prototype._init = function() {
  var self2 = this;
  var eventBus = this._eventBus;
  var parentContainer = this._getParentContainer();
  var container = this._container = domify$1(Palette.HTML_MARKUP);
  parentContainer.appendChild(container);
  classes$1(parentContainer).add(PALETTE_PREFIX + PALETTE_SHOWN_CLS);
  delegate.bind(container, ELEMENT_SELECTOR, "click", function(event2) {
    var target = event2.delegateTarget;
    if (matches(target, TOGGLE_SELECTOR)) {
      return self2.toggle();
    }
    self2.trigger("click", event2);
  });
  event.bind(container, "mousedown", function(event2) {
    event2.stopPropagation();
  });
  delegate.bind(container, ENTRY_SELECTOR, "dragstart", function(event2) {
    self2.trigger("dragstart", event2);
  });
  eventBus.on("canvas.resized", this._layoutChanged, this);
  eventBus.fire("palette.create", {
    container
  });
};
Palette.prototype._getProviders = function(id) {
  var event2 = this._eventBus.createEvent({
    type: "palette.getProviders",
    providers: []
  });
  this._eventBus.fire(event2);
  return event2.providers;
};
Palette.prototype._toggleState = function(state) {
  state = state || {};
  var parent = this._getParentContainer(), container = this._container;
  var eventBus = this._eventBus;
  var twoColumn;
  var cls = classes$1(container), parentCls = classes$1(parent);
  if ("twoColumn" in state) {
    twoColumn = state.twoColumn;
  } else {
    twoColumn = this._needsCollapse(parent.clientHeight, this._entries || {});
  }
  cls.toggle(PALETTE_TWO_COLUMN_CLS, twoColumn);
  parentCls.toggle(PALETTE_PREFIX + PALETTE_TWO_COLUMN_CLS, twoColumn);
  if ("open" in state) {
    cls.toggle(PALETTE_OPEN_CLS, state.open);
    parentCls.toggle(PALETTE_PREFIX + PALETTE_OPEN_CLS, state.open);
  }
  eventBus.fire("palette.changed", {
    twoColumn,
    open: this.isOpen()
  });
};
Palette.prototype._update = function() {
  var entriesContainer = query(".djs-palette-entries", this._container), entries = this._entries = this.getEntries();
  clear$1(entriesContainer);
  forEach$1(entries, function(entry, id) {
    var grouping = entry.group || "default";
    var container = query("[data-group=" + escapeCSS(grouping) + "]", entriesContainer);
    if (!container) {
      container = domify$1('<div class="group"></div>');
      attr$1(container, "data-group", grouping);
      entriesContainer.appendChild(container);
    }
    var html = entry.html || (entry.separator ? '<hr class="separator" />' : '<div class="entry" draggable="true"></div>');
    var control = domify$1(html);
    container.appendChild(control);
    if (!entry.separator) {
      attr$1(control, "data-action", id);
      if (entry.title) {
        attr$1(control, "title", entry.title);
      }
      if (entry.className) {
        addClasses(control, entry.className);
      }
      if (entry.imageUrl) {
        var image = domify$1("<img>");
        attr$1(image, "src", entry.imageUrl);
        control.appendChild(image);
      }
    }
  });
  this.open();
};
Palette.prototype.trigger = function(action, event2, autoActivate) {
  var entry, originalEvent, button = event2.delegateTarget || event2.target;
  if (!button) {
    return event2.preventDefault();
  }
  entry = attr$1(button, "data-action");
  originalEvent = event2.originalEvent || event2;
  return this.triggerEntry(entry, action, originalEvent, autoActivate);
};
Palette.prototype.triggerEntry = function(entryId, action, event2, autoActivate) {
  var entries = this._entries, entry, handler;
  entry = entries[entryId];
  if (!entry) {
    return;
  }
  handler = entry.action;
  if (this._eventBus.fire("palette.trigger", { entry, event: event2 }) === false) {
    return;
  }
  if (isFunction(handler)) {
    if (action === "click") {
      return handler(event2, autoActivate);
    }
  } else {
    if (handler[action]) {
      return handler[action](event2, autoActivate);
    }
  }
  event2.preventDefault();
};
Palette.prototype._layoutChanged = function() {
  this._toggleState({});
};
Palette.prototype._needsCollapse = function(availableHeight, entries) {
  var margin = 20 + 10 + 20;
  var entriesHeight = Object.keys(entries).length * 46;
  return availableHeight < entriesHeight + margin;
};
Palette.prototype.close = function() {
  this._toggleState({
    open: false,
    twoColumn: false
  });
};
Palette.prototype.open = function() {
  this._toggleState({ open: true });
};
Palette.prototype.toggle = function() {
  if (this.isOpen()) {
    this.close();
  } else {
    this.open();
  }
};
Palette.prototype.isActiveTool = function(tool) {
  return tool && this._activeTool === tool;
};
Palette.prototype.updateToolHighlight = function(name2) {
  var entriesContainer, toolsContainer;
  if (!this._toolsContainer) {
    entriesContainer = query(".djs-palette-entries", this._container);
    this._toolsContainer = query("[data-group=tools]", entriesContainer);
  }
  toolsContainer = this._toolsContainer;
  forEach$1(toolsContainer.children, function(tool) {
    var actionName = tool.getAttribute("data-action");
    if (!actionName) {
      return;
    }
    var toolClasses = classes$1(tool);
    actionName = actionName.replace("-tool", "");
    if (toolClasses.contains("entry") && actionName === name2) {
      toolClasses.add("highlighted-entry");
    } else {
      toolClasses.remove("highlighted-entry");
    }
  });
};
Palette.prototype.isOpen = function() {
  return classes$1(this._container).has(PALETTE_OPEN_CLS);
};
Palette.prototype._getParentContainer = function() {
  return this._canvas.getContainer();
};
Palette.HTML_MARKUP = '<div class="djs-palette"><div class="djs-palette-entries"></div><div class="djs-palette-toggle"></div></div>';
function addClasses(element, classNames) {
  var classes2 = classes$1(element);
  var actualClassNames = isArray$3(classNames) ? classNames : classNames.split(/\s+/g);
  actualClassNames.forEach(function(cls) {
    classes2.add(cls);
  });
}
function addPaletteEntries(entries, provider) {
  var entriesOrUpdater = provider.getPaletteEntries();
  if (isFunction(entriesOrUpdater)) {
    return entriesOrUpdater(entries);
  }
  forEach$1(entriesOrUpdater, function(entry, id) {
    entries[id] = entry;
  });
  return entries;
}
const PaletteModule$1 = {
  __init__: ["palette"],
  palette: ["type", Palette]
};
var LASSO_TOOL_CURSOR = "crosshair";
function LassoTool(eventBus, canvas, dragging, elementRegistry, selection, toolManager, mouse) {
  this._selection = selection;
  this._dragging = dragging;
  this._mouse = mouse;
  var self2 = this;
  var visuals = {
    create: function(context) {
      var container = canvas.getActiveLayer(), frame;
      frame = context.frame = create$1("rect");
      attr(frame, {
        class: "djs-lasso-overlay",
        width: 1,
        height: 1,
        x: 0,
        y: 0
      });
      append(container, frame);
    },
    update: function(context) {
      var frame = context.frame, bbox = context.bbox;
      attr(frame, {
        x: bbox.x,
        y: bbox.y,
        width: bbox.width,
        height: bbox.height
      });
    },
    remove: function(context) {
      if (context.frame) {
        remove$1(context.frame);
      }
    }
  };
  toolManager.registerTool("lasso", {
    tool: "lasso.selection",
    dragging: "lasso"
  });
  eventBus.on("lasso.selection.end", function(event2) {
    var target = event2.originalEvent.target;
    if (!event2.hover && !(target instanceof SVGElement)) {
      return;
    }
    eventBus.once("lasso.selection.ended", function() {
      self2.activateLasso(event2.originalEvent, true);
    });
  });
  eventBus.on("lasso.end", 0, function(event2) {
    var context = event2.context;
    var bbox = toBBox(event2);
    var elements = elementRegistry.filter(function(element) {
      return element;
    });
    var add2 = hasSecondaryModifier(event2);
    self2.select(elements, bbox, add2 ? context.selection : []);
  });
  eventBus.on("lasso.start", function(event2) {
    var context = event2.context;
    context.bbox = toBBox(event2);
    visuals.create(context);
    context.selection = selection.get();
  });
  eventBus.on("lasso.move", function(event2) {
    var context = event2.context;
    context.bbox = toBBox(event2);
    visuals.update(context);
  });
  eventBus.on("lasso.cleanup", function(event2) {
    var context = event2.context;
    visuals.remove(context);
  });
  eventBus.on("element.mousedown", 1500, function(event2) {
    if (!hasSecondaryModifier(event2)) {
      return;
    }
    self2.activateLasso(event2.originalEvent);
    return true;
  });
}
LassoTool.$inject = [
  "eventBus",
  "canvas",
  "dragging",
  "elementRegistry",
  "selection",
  "toolManager",
  "mouse"
];
LassoTool.prototype.activateLasso = function(event2, autoActivate) {
  this._dragging.init(event2, "lasso", {
    autoActivate,
    cursor: LASSO_TOOL_CURSOR,
    data: {
      context: {}
    }
  });
};
LassoTool.prototype.activateSelection = function(event2, autoActivate) {
  this._dragging.init(event2, "lasso.selection", {
    trapClick: false,
    autoActivate,
    cursor: LASSO_TOOL_CURSOR,
    data: {
      context: {}
    },
    keepSelection: true
  });
};
LassoTool.prototype.select = function(elements, bbox, previousSelection = []) {
  var selectedElements = getEnclosedElements(elements, bbox);
  this._selection.select([
    ...previousSelection,
    ...values(selectedElements)
  ]);
};
LassoTool.prototype.toggle = function() {
  if (this.isActive()) {
    return this._dragging.cancel();
  }
  var mouseEvent = this._mouse.getLastMoveEvent();
  this.activateSelection(mouseEvent, !!mouseEvent);
};
LassoTool.prototype.isActive = function() {
  var context = this._dragging.context();
  return context && /^lasso/.test(context.prefix);
};
function toBBox(event2) {
  var start = {
    x: event2.x - event2.dx,
    y: event2.y - event2.dy
  };
  var end = {
    x: event2.x,
    y: event2.y
  };
  var bbox;
  if (start.x <= end.x && start.y < end.y || start.x < end.x && start.y <= end.y) {
    bbox = {
      x: start.x,
      y: start.y,
      width: end.x - start.x,
      height: end.y - start.y
    };
  } else if (start.x >= end.x && start.y < end.y || start.x > end.x && start.y <= end.y) {
    bbox = {
      x: end.x,
      y: start.y,
      width: start.x - end.x,
      height: end.y - start.y
    };
  } else if (start.x <= end.x && start.y > end.y || start.x < end.x && start.y >= end.y) {
    bbox = {
      x: start.x,
      y: end.y,
      width: end.x - start.x,
      height: start.y - end.y
    };
  } else if (start.x >= end.x && start.y > end.y || start.x > end.x && start.y >= end.y) {
    bbox = {
      x: end.x,
      y: end.y,
      width: start.x - end.x,
      height: start.y - end.y
    };
  } else {
    bbox = {
      x: end.x,
      y: end.y,
      width: 0,
      height: 0
    };
  }
  return bbox;
}
const LassoToolModule = {
  __depends__: [
    ToolManagerModule,
    MouseModule
  ],
  __init__: ["lassoTool"],
  lassoTool: ["type", LassoTool]
};
var HIGH_PRIORITY$1 = 1500;
var HAND_CURSOR = "grab";
function HandTool(eventBus, canvas, dragging, injector, toolManager, mouse) {
  this._dragging = dragging;
  this._mouse = mouse;
  var self2 = this, keyboard = injector.get("keyboard", false);
  toolManager.registerTool("hand", {
    tool: "hand",
    dragging: "hand.move"
  });
  eventBus.on("element.mousedown", HIGH_PRIORITY$1, function(event2) {
    if (!hasPrimaryModifier(event2)) {
      return;
    }
    self2.activateMove(event2.originalEvent, true);
    return false;
  });
  keyboard && keyboard.addListener(HIGH_PRIORITY$1, function(e2) {
    if (!isSpace(e2.keyEvent) || self2.isActive()) {
      return;
    }
    var mouseEvent = self2._mouse.getLastMoveEvent();
    self2.activateMove(mouseEvent, !!mouseEvent);
  }, "keyboard.keydown");
  keyboard && keyboard.addListener(HIGH_PRIORITY$1, function(e2) {
    if (!isSpace(e2.keyEvent) || !self2.isActive()) {
      return;
    }
    self2.toggle();
  }, "keyboard.keyup");
  eventBus.on("hand.end", function(event2) {
    var target = event2.originalEvent.target;
    if (!event2.hover && !(target instanceof SVGElement)) {
      return false;
    }
    eventBus.once("hand.ended", function() {
      self2.activateMove(event2.originalEvent, { reactivate: true });
    });
  });
  eventBus.on("hand.move.move", function(event2) {
    var scale = canvas.viewbox().scale;
    canvas.scroll({
      dx: event2.dx * scale,
      dy: event2.dy * scale
    });
  });
  eventBus.on("hand.move.end", function(event2) {
    var context = event2.context, reactivate = context.reactivate;
    if (!hasPrimaryModifier(event2) && reactivate) {
      eventBus.once("hand.move.ended", function(event3) {
        self2.activateHand(event3.originalEvent, true, true);
      });
    }
    return false;
  });
}
HandTool.$inject = [
  "eventBus",
  "canvas",
  "dragging",
  "injector",
  "toolManager",
  "mouse"
];
HandTool.prototype.activateMove = function(event2, autoActivate, context) {
  if (typeof autoActivate === "object") {
    context = autoActivate;
    autoActivate = false;
  }
  this._dragging.init(event2, "hand.move", {
    autoActivate,
    cursor: HAND_CURSOR,
    data: {
      context: context || {}
    }
  });
};
HandTool.prototype.activateHand = function(event2, autoActivate, reactivate) {
  this._dragging.init(event2, "hand", {
    trapClick: false,
    autoActivate,
    cursor: HAND_CURSOR,
    data: {
      context: {
        reactivate
      }
    }
  });
};
HandTool.prototype.toggle = function() {
  if (this.isActive()) {
    return this._dragging.cancel();
  }
  var mouseEvent = this._mouse.getLastMoveEvent();
  this.activateHand(mouseEvent, !!mouseEvent);
};
HandTool.prototype.isActive = function() {
  var context = this._dragging.context();
  if (context) {
    return /^(hand|hand\.move)$/.test(context.prefix);
  }
  return false;
};
function isSpace(keyEvent) {
  return isKey("Space", keyEvent);
}
const HandToolModule = {
  __depends__: [
    ToolManagerModule,
    MouseModule
  ],
  __init__: ["handTool"],
  handTool: ["type", HandTool]
};
var MARKER_OK = "connect-ok", MARKER_NOT_OK = "connect-not-ok";
function GlobalConnect(eventBus, dragging, connect, canvas, toolManager, rules, mouse) {
  var self2 = this;
  this._dragging = dragging;
  this._rules = rules;
  this._mouse = mouse;
  toolManager.registerTool("global-connect", {
    tool: "global-connect",
    dragging: "global-connect.drag"
  });
  eventBus.on("global-connect.hover", function(event2) {
    var context = event2.context, startTarget = event2.hover;
    var canStartConnect = context.canStartConnect = self2.canStartConnect(startTarget);
    if (canStartConnect === null) {
      return;
    }
    context.startTarget = startTarget;
    canvas.addMarker(startTarget, canStartConnect ? MARKER_OK : MARKER_NOT_OK);
  });
  eventBus.on(["global-connect.out", "global-connect.cleanup"], function(event2) {
    var startTarget = event2.context.startTarget, canStartConnect = event2.context.canStartConnect;
    if (startTarget) {
      canvas.removeMarker(startTarget, canStartConnect ? MARKER_OK : MARKER_NOT_OK);
    }
  });
  eventBus.on(["global-connect.ended"], function(event2) {
    var context = event2.context, startTarget = context.startTarget, startPosition = {
      x: event2.x,
      y: event2.y
    };
    var canStartConnect = self2.canStartConnect(startTarget);
    if (!canStartConnect) {
      return;
    }
    eventBus.once("element.out", function() {
      eventBus.once(["connect.ended", "connect.canceled"], function() {
        eventBus.fire("global-connect.drag.ended");
      });
      connect.start(null, startTarget, startPosition);
    });
    return false;
  });
}
GlobalConnect.$inject = [
  "eventBus",
  "dragging",
  "connect",
  "canvas",
  "toolManager",
  "rules",
  "mouse"
];
GlobalConnect.prototype.start = function(event2, autoActivate) {
  this._dragging.init(event2, "global-connect", {
    autoActivate,
    trapClick: false,
    data: {
      context: {}
    }
  });
};
GlobalConnect.prototype.toggle = function() {
  if (this.isActive()) {
    return this._dragging.cancel();
  }
  var mouseEvent = this._mouse.getLastMoveEvent();
  return this.start(mouseEvent, !!mouseEvent);
};
GlobalConnect.prototype.isActive = function() {
  var context = this._dragging.context();
  return context && /^global-connect/.test(context.prefix);
};
GlobalConnect.prototype.canStartConnect = function(startTarget) {
  return this._rules.allowed("connection.start", { source: startTarget });
};
const GlobalConnectModule = {
  __depends__: [
    ConnectModule,
    RulesModule$1,
    DraggingModule,
    ToolManagerModule,
    MouseModule
  ],
  globalConnect: ["type", GlobalConnect]
};
function PaletteProvider$1(palette, create2, elementFactory, spaceTool, lassoTool, handTool, globalConnect, translate2) {
  this._palette = palette;
  this._create = create2;
  this._elementFactory = elementFactory;
  this._spaceTool = spaceTool;
  this._lassoTool = lassoTool;
  this._handTool = handTool;
  this._globalConnect = globalConnect;
  this._translate = translate2;
  palette.registerProvider(this);
}
PaletteProvider$1.$inject = [
  "palette",
  "create",
  "elementFactory",
  "spaceTool",
  "lassoTool",
  "handTool",
  "globalConnect",
  "translate"
];
PaletteProvider$1.prototype.getPaletteEntries = function() {
  var actions = {}, create2 = this._create, elementFactory = this._elementFactory, spaceTool = this._spaceTool, lassoTool = this._lassoTool, handTool = this._handTool, globalConnect = this._globalConnect, translate2 = this._translate;
  function createAction(type, group, className, title, options) {
    function createListener(event2) {
      var shape = elementFactory.createShape(assign$1({ type }, options));
      create2.start(event2, shape);
    }
    return {
      group,
      className,
      title,
      action: {
        dragstart: createListener,
        click: createListener
      }
    };
  }
  function createSubprocess(event2) {
    var subProcess = elementFactory.createShape({
      type: "bpmn:SubProcess",
      x: 0,
      y: 0,
      isExpanded: true
    });
    var startEvent = elementFactory.createShape({
      type: "bpmn:StartEvent",
      x: 40,
      y: 82,
      parent: subProcess
    });
    create2.start(event2, [subProcess, startEvent], {
      hints: {
        autoSelect: [subProcess]
      }
    });
  }
  function createParticipant(event2) {
    create2.start(event2, elementFactory.createParticipantShape());
  }
  assign$1(actions, {
    "hand-tool": {
      group: "tools",
      className: "bpmn-icon-hand-tool",
      title: translate2("Activate hand tool"),
      action: {
        click: function(event2) {
          handTool.activateHand(event2);
        }
      }
    },
    "lasso-tool": {
      group: "tools",
      className: "bpmn-icon-lasso-tool",
      title: translate2("Activate lasso tool"),
      action: {
        click: function(event2) {
          lassoTool.activateSelection(event2);
        }
      }
    },
    "space-tool": {
      group: "tools",
      className: "bpmn-icon-space-tool",
      title: translate2("Activate create/remove space tool"),
      action: {
        click: function(event2) {
          spaceTool.activateSelection(event2);
        }
      }
    },
    "global-connect-tool": {
      group: "tools",
      className: "bpmn-icon-connection-multi",
      title: translate2("Activate global connect tool"),
      action: {
        click: function(event2) {
          globalConnect.start(event2);
        }
      }
    },
    "tool-separator": {
      group: "tools",
      separator: true
    },
    "create.start-event": createAction(
      "bpmn:StartEvent",
      "event",
      "bpmn-icon-start-event-none",
      translate2("Create start event")
    ),
    "create.intermediate-event": createAction(
      "bpmn:IntermediateThrowEvent",
      "event",
      "bpmn-icon-intermediate-event-none",
      translate2("Create intermediate/boundary event")
    ),
    "create.end-event": createAction(
      "bpmn:EndEvent",
      "event",
      "bpmn-icon-end-event-none",
      translate2("Create end event")
    ),
    "create.exclusive-gateway": createAction(
      "bpmn:ExclusiveGateway",
      "gateway",
      "bpmn-icon-gateway-none",
      translate2("Create gateway")
    ),
    "create.task": createAction(
      "bpmn:Task",
      "activity",
      "bpmn-icon-task",
      translate2("Create task")
    ),
    "create.data-object": createAction(
      "bpmn:DataObjectReference",
      "data-object",
      "bpmn-icon-data-object",
      translate2("Create data object reference")
    ),
    "create.data-store": createAction(
      "bpmn:DataStoreReference",
      "data-store",
      "bpmn-icon-data-store",
      translate2("Create data store reference")
    ),
    "create.subprocess-expanded": {
      group: "activity",
      className: "bpmn-icon-subprocess-expanded",
      title: translate2("Create expanded sub-process"),
      action: {
        dragstart: createSubprocess,
        click: createSubprocess
      }
    },
    "create.participant-expanded": {
      group: "collaboration",
      className: "bpmn-icon-participant",
      title: translate2("Create pool/participant"),
      action: {
        dragstart: createParticipant,
        click: createParticipant
      }
    },
    "create.group": createAction(
      "bpmn:Group",
      "artifact",
      "bpmn-icon-group",
      translate2("Create group")
    )
  });
  return actions;
};
const PaletteModule = {
  __depends__: [
    PaletteModule$1,
    CreateModule,
    SpaceToolModule,
    LassoToolModule,
    HandToolModule,
    GlobalConnectModule,
    translate
  ],
  __init__: ["paletteProvider"],
  paletteProvider: ["type", PaletteProvider$1]
};
var LOW_PRIORITY = 250;
function BpmnReplacePreview(eventBus, elementRegistry, elementFactory, canvas, previewSupport) {
  CommandInterceptor.call(this, eventBus);
  function replaceVisual(context) {
    var replacements = context.canExecute.replacements;
    forEach$1(replacements, function(replacement) {
      var id = replacement.oldElementId;
      var newElement = {
        type: replacement.newElementType
      };
      if (context.visualReplacements[id]) {
        return;
      }
      var element = elementRegistry.get(id);
      assign$1(newElement, { x: element.x, y: element.y });
      var tempShape = elementFactory.createShape(newElement);
      canvas.addShape(tempShape, element.parent);
      var gfx = query('[data-element-id="' + escapeCSS(element.id) + '"]', context.dragGroup);
      if (gfx) {
        attr(gfx, { display: "none" });
      }
      var dragger = previewSupport.addDragger(tempShape, context.dragGroup);
      context.visualReplacements[id] = dragger;
      canvas.removeShape(tempShape);
    });
  }
  function restoreVisual(context) {
    var visualReplacements = context.visualReplacements;
    forEach$1(visualReplacements, function(dragger, id) {
      var originalGfx = query('[data-element-id="' + escapeCSS(id) + '"]', context.dragGroup);
      if (originalGfx) {
        attr(originalGfx, { display: "inline" });
      }
      dragger.remove();
      if (visualReplacements[id]) {
        delete visualReplacements[id];
      }
    });
  }
  eventBus.on("shape.move.move", LOW_PRIORITY, function(event2) {
    var context = event2.context, canExecute = context.canExecute;
    if (!context.visualReplacements) {
      context.visualReplacements = {};
    }
    if (canExecute && canExecute.replacements) {
      replaceVisual(context);
    } else {
      restoreVisual(context);
    }
  });
}
BpmnReplacePreview.$inject = [
  "eventBus",
  "elementRegistry",
  "elementFactory",
  "canvas",
  "previewSupport"
];
e$3(BpmnReplacePreview, CommandInterceptor);
const ReplacePreviewModule = {
  __depends__: [
    PreviewSupportModule
  ],
  __init__: ["bpmnReplacePreview"],
  bpmnReplacePreview: ["type", BpmnReplacePreview]
};
var HIGHER_PRIORITY$2 = 1250;
var BOUNDARY_TO_HOST_THRESHOLD = 40;
var TARGET_BOUNDS_PADDING = 20, TASK_BOUNDS_PADDING = 10;
var TARGET_CENTER_PADDING = 20;
var AXES = ["x", "y"];
var abs = Math.abs;
function BpmnConnectSnapping(eventBus) {
  eventBus.on([
    "connect.hover",
    "connect.move",
    "connect.end"
  ], HIGHER_PRIORITY$2, function(event2) {
    var context = event2.context, canExecute = context.canExecute, start = context.start, hover = context.hover, source = context.source, target = context.target;
    if (event2.originalEvent && isCmd(event2.originalEvent)) {
      return;
    }
    if (!context.initialConnectionStart) {
      context.initialConnectionStart = context.connectionStart;
    }
    if (canExecute && hover) {
      snapToShape(event2, hover, getTargetBoundsPadding(hover));
    }
    if (hover && isAnyType(canExecute, [
      "bpmn:Association",
      "bpmn:DataInputAssociation",
      "bpmn:DataOutputAssociation",
      "bpmn:SequenceFlow"
    ])) {
      context.connectionStart = mid$2(start);
      if (isAny(hover, ["bpmn:Event", "bpmn:Gateway"])) {
        snapToPosition(event2, mid$2(hover));
      }
      if (isAny(hover, ["bpmn:Task", "bpmn:SubProcess"])) {
        snapToTargetMid(event2, hover);
      }
      if (is$1(source, "bpmn:BoundaryEvent") && target === source.host) {
        snapBoundaryEventLoop(event2);
      }
    } else if (isType(canExecute, "bpmn:MessageFlow")) {
      if (is$1(start, "bpmn:Event")) {
        context.connectionStart = mid$2(start);
      }
      if (is$1(hover, "bpmn:Event")) {
        snapToPosition(event2, mid$2(hover));
      }
    } else {
      context.connectionStart = context.initialConnectionStart;
    }
  });
}
BpmnConnectSnapping.$inject = ["eventBus"];
function snapToShape(event2, target, padding) {
  AXES.forEach(function(axis) {
    var dimensionForAxis = getDimensionForAxis(axis, target);
    if (event2[axis] < target[axis] + padding) {
      setSnapped(event2, axis, target[axis] + padding);
    } else if (event2[axis] > target[axis] + dimensionForAxis - padding) {
      setSnapped(event2, axis, target[axis] + dimensionForAxis - padding);
    }
  });
}
function snapToTargetMid(event2, target) {
  var targetMid = mid$2(target);
  AXES.forEach(function(axis) {
    if (isMid(event2, target, axis)) {
      setSnapped(event2, axis, targetMid[axis]);
    }
  });
}
function snapBoundaryEventLoop(event2) {
  var context = event2.context, source = context.source, target = context.target;
  if (isReverse(context)) {
    return;
  }
  var sourceMid = mid$2(source), orientation = getOrientation(sourceMid, target, -10), axes = [];
  if (/top|bottom/.test(orientation)) {
    axes.push("x");
  }
  if (/left|right/.test(orientation)) {
    axes.push("y");
  }
  axes.forEach(function(axis) {
    var coordinate = event2[axis], newCoordinate;
    if (abs(coordinate - sourceMid[axis]) < BOUNDARY_TO_HOST_THRESHOLD) {
      if (coordinate > sourceMid[axis]) {
        newCoordinate = sourceMid[axis] + BOUNDARY_TO_HOST_THRESHOLD;
      } else {
        newCoordinate = sourceMid[axis] - BOUNDARY_TO_HOST_THRESHOLD;
      }
      setSnapped(event2, axis, newCoordinate);
    }
  });
}
function snapToPosition(event2, position) {
  setSnapped(event2, "x", position.x);
  setSnapped(event2, "y", position.y);
}
function isType(attrs, type) {
  return attrs && attrs.type === type;
}
function isAnyType(attrs, types2) {
  return some(types2, function(type) {
    return isType(attrs, type);
  });
}
function getDimensionForAxis(axis, element) {
  return axis === "x" ? element.width : element.height;
}
function getTargetBoundsPadding(target) {
  if (is$1(target, "bpmn:Task")) {
    return TASK_BOUNDS_PADDING;
  } else {
    return TARGET_BOUNDS_PADDING;
  }
}
function isMid(event2, target, axis) {
  return event2[axis] > target[axis] + TARGET_CENTER_PADDING && event2[axis] < target[axis] + getDimensionForAxis(axis, target) - TARGET_CENTER_PADDING;
}
function isReverse(context) {
  var hover = context.hover, source = context.source;
  return hover && source && hover === source;
}
function SnapContext() {
  this._targets = {};
  this._snapOrigins = {};
  this._snapLocations = [];
  this._defaultSnaps = {};
}
SnapContext.prototype.getSnapOrigin = function(snapLocation) {
  return this._snapOrigins[snapLocation];
};
SnapContext.prototype.setSnapOrigin = function(snapLocation, snapOrigin) {
  this._snapOrigins[snapLocation] = snapOrigin;
  if (this._snapLocations.indexOf(snapLocation) === -1) {
    this._snapLocations.push(snapLocation);
  }
};
SnapContext.prototype.addDefaultSnap = function(snapLocation, point) {
  var snapValues = this._defaultSnaps[snapLocation];
  if (!snapValues) {
    snapValues = this._defaultSnaps[snapLocation] = [];
  }
  snapValues.push(point);
};
SnapContext.prototype.getSnapLocations = function() {
  return this._snapLocations;
};
SnapContext.prototype.setSnapLocations = function(snapLocations) {
  this._snapLocations = snapLocations;
};
SnapContext.prototype.pointsForTarget = function(target) {
  var targetId = target.id || target;
  var snapPoints = this._targets[targetId];
  if (!snapPoints) {
    snapPoints = this._targets[targetId] = new SnapPoints();
    snapPoints.initDefaults(this._defaultSnaps);
  }
  return snapPoints;
};
function SnapPoints() {
  this._snapValues = {};
}
SnapPoints.prototype.add = function(snapLocation, point) {
  var snapValues = this._snapValues[snapLocation];
  if (!snapValues) {
    snapValues = this._snapValues[snapLocation] = { x: [], y: [] };
  }
  if (snapValues.x.indexOf(point.x) === -1) {
    snapValues.x.push(point.x);
  }
  if (snapValues.y.indexOf(point.y) === -1) {
    snapValues.y.push(point.y);
  }
};
SnapPoints.prototype.snap = function(point, snapLocation, axis, tolerance) {
  var snappingValues = this._snapValues[snapLocation];
  return snappingValues && snapTo(point[axis], snappingValues[axis], tolerance);
};
SnapPoints.prototype.initDefaults = function(defaultSnaps) {
  var self2 = this;
  forEach$1(defaultSnaps || {}, function(snapPoints, snapLocation) {
    forEach$1(snapPoints, function(point) {
      self2.add(snapLocation, point);
    });
  });
};
var HIGHER_PRIORITY$1 = 1250;
function CreateMoveSnapping(elementRegistry, eventBus, snapping) {
  var self2 = this;
  this._elementRegistry = elementRegistry;
  eventBus.on([
    "create.start",
    "shape.move.start"
  ], function(event2) {
    self2.initSnap(event2);
  });
  eventBus.on([
    "create.move",
    "create.end",
    "shape.move.move",
    "shape.move.end"
  ], HIGHER_PRIORITY$1, function(event2) {
    var context = event2.context, shape = context.shape, snapContext = context.snapContext, target = context.target;
    if (event2.originalEvent && isCmd(event2.originalEvent)) {
      return;
    }
    if (isSnapped(event2) || !target) {
      return;
    }
    var snapPoints = snapContext.pointsForTarget(target);
    if (!snapPoints.initialized) {
      snapPoints = self2.addSnapTargetPoints(snapPoints, shape, target);
      snapPoints.initialized = true;
    }
    snapping.snap(event2, snapPoints);
  });
  eventBus.on([
    "create.cleanup",
    "shape.move.cleanup"
  ], function() {
    snapping.hide();
  });
}
CreateMoveSnapping.$inject = [
  "elementRegistry",
  "eventBus",
  "snapping"
];
CreateMoveSnapping.prototype.initSnap = function(event2) {
  var elementRegistry = this._elementRegistry;
  var context = event2.context, shape = context.shape, snapContext = context.snapContext;
  if (!snapContext) {
    snapContext = context.snapContext = new SnapContext();
  }
  var shapeMid;
  if (elementRegistry.get(shape.id)) {
    shapeMid = mid$2(shape, event2);
  } else {
    shapeMid = {
      x: event2.x + mid$2(shape).x,
      y: event2.y + mid$2(shape).y
    };
  }
  var shapeTopLeft = {
    x: shapeMid.x - shape.width / 2,
    y: shapeMid.y - shape.height / 2
  }, shapeBottomRight = {
    x: shapeMid.x + shape.width / 2,
    y: shapeMid.y + shape.height / 2
  };
  snapContext.setSnapOrigin("mid", {
    x: shapeMid.x - event2.x,
    y: shapeMid.y - event2.y
  });
  if (isLabel(shape)) {
    return snapContext;
  }
  snapContext.setSnapOrigin("top-left", {
    x: shapeTopLeft.x - event2.x,
    y: shapeTopLeft.y - event2.y
  });
  snapContext.setSnapOrigin("bottom-right", {
    x: shapeBottomRight.x - event2.x,
    y: shapeBottomRight.y - event2.y
  });
  return snapContext;
};
CreateMoveSnapping.prototype.addSnapTargetPoints = function(snapPoints, shape, target) {
  var snapTargets = this.getSnapTargets(shape, target);
  forEach$1(snapTargets, function(snapTarget) {
    if (isLabel(snapTarget)) {
      if (isLabel(shape)) {
        snapPoints.add("mid", mid$2(snapTarget));
      }
      return;
    }
    if (isConnection(snapTarget)) {
      if (snapTarget.waypoints.length < 3) {
        return;
      }
      var waypoints = snapTarget.waypoints.slice(1, -1);
      forEach$1(waypoints, function(waypoint) {
        snapPoints.add("mid", waypoint);
      });
      return;
    }
    snapPoints.add("mid", mid$2(snapTarget));
  });
  if (!isNumber(shape.x) || !isNumber(shape.y)) {
    return snapPoints;
  }
  if (this._elementRegistry.get(shape.id)) {
    snapPoints.add("mid", mid$2(shape));
  }
  return snapPoints;
};
CreateMoveSnapping.prototype.getSnapTargets = function(shape, target) {
  return getChildren(target).filter(function(child) {
    return !isHidden$1(child);
  });
};
function isHidden$1(element) {
  return !!element.hidden;
}
var HIGH_PRIORITY = 1500;
function BpmnCreateMoveSnapping(eventBus, injector) {
  injector.invoke(CreateMoveSnapping, this);
  eventBus.on(["create.move", "create.end"], HIGH_PRIORITY, setSnappedIfConstrained);
  eventBus.on([
    "create.move",
    "create.end",
    "shape.move.move",
    "shape.move.end"
  ], HIGH_PRIORITY, function(event2) {
    var context = event2.context, canExecute = context.canExecute, target = context.target;
    var canAttach2 = canExecute && (canExecute === "attach" || canExecute.attach);
    if (canAttach2 && !isSnapped(event2)) {
      snapBoundaryEvent(event2, target);
    }
  });
}
e$3(BpmnCreateMoveSnapping, CreateMoveSnapping);
BpmnCreateMoveSnapping.$inject = [
  "eventBus",
  "injector"
];
BpmnCreateMoveSnapping.prototype.initSnap = function(event2) {
  var snapContext = CreateMoveSnapping.prototype.initSnap.call(this, event2);
  var shape = event2.shape;
  var isMove = !!this._elementRegistry.get(shape.id);
  forEach$1(shape.outgoing, function(connection) {
    var docking = connection.waypoints[0];
    docking = docking.original || docking;
    snapContext.setSnapOrigin(connection.id + "-docking", getDockingSnapOrigin(docking, isMove, event2));
  });
  forEach$1(shape.incoming, function(connection) {
    var docking = connection.waypoints[connection.waypoints.length - 1];
    docking = docking.original || docking;
    snapContext.setSnapOrigin(connection.id + "-docking", getDockingSnapOrigin(docking, isMove, event2));
  });
  if (is$1(shape, "bpmn:Participant")) {
    snapContext.setSnapLocations(["top-left", "bottom-right", "mid"]);
  }
  return snapContext;
};
BpmnCreateMoveSnapping.prototype.addSnapTargetPoints = function(snapPoints, shape, target) {
  CreateMoveSnapping.prototype.addSnapTargetPoints.call(this, snapPoints, shape, target);
  var snapTargets = this.getSnapTargets(shape, target);
  forEach$1(snapTargets, function(snapTarget) {
    if (isContainer(snapTarget) || areAll([shape, snapTarget], "bpmn:TextAnnotation")) {
      snapPoints.add("top-left", topLeft(snapTarget));
      snapPoints.add("bottom-right", bottomRight(snapTarget));
    }
  });
  var elementRegistry = this._elementRegistry;
  forEach$1(shape.incoming, function(connection) {
    if (elementRegistry.get(shape.id)) {
      if (!includes(snapTargets, connection.source)) {
        snapPoints.add("mid", getMid(connection.source));
      }
      var docking = connection.waypoints[0];
      snapPoints.add(connection.id + "-docking", docking.original || docking);
    }
  });
  forEach$1(shape.outgoing, function(connection) {
    if (elementRegistry.get(shape.id)) {
      if (!includes(snapTargets, connection.target)) {
        snapPoints.add("mid", getMid(connection.target));
      }
      var docking = connection.waypoints[connection.waypoints.length - 1];
      snapPoints.add(connection.id + "-docking", docking.original || docking);
    }
  });
  if (is$1(target, "bpmn:SequenceFlow")) {
    snapPoints = this.addSnapTargetPoints(snapPoints, shape, target.parent);
  }
  return snapPoints;
};
BpmnCreateMoveSnapping.prototype.getSnapTargets = function(shape, target) {
  return CreateMoveSnapping.prototype.getSnapTargets.call(this, shape, target).filter(function(snapTarget) {
    return !is$1(snapTarget, "bpmn:Lane");
  });
};
function snapBoundaryEvent(event2, target) {
  var targetTRBL = asTRBL(target);
  var direction = getBoundaryAttachment(event2, target);
  var context = event2.context, shape = context.shape;
  var offset;
  if (shape.parent) {
    offset = { x: 0, y: 0 };
  } else {
    offset = getMid(shape);
  }
  if (/top/.test(direction)) {
    setSnapped(event2, "y", targetTRBL.top - offset.y);
  } else if (/bottom/.test(direction)) {
    setSnapped(event2, "y", targetTRBL.bottom - offset.y);
  }
  if (/left/.test(direction)) {
    setSnapped(event2, "x", targetTRBL.left - offset.x);
  } else if (/right/.test(direction)) {
    setSnapped(event2, "x", targetTRBL.right - offset.x);
  }
}
function areAll(elements, type) {
  return elements.every(function(el) {
    return is$1(el, type);
  });
}
function isContainer(element) {
  if (is$1(element, "bpmn:SubProcess") && isExpanded(element)) {
    return true;
  }
  return is$1(element, "bpmn:Participant");
}
function setSnappedIfConstrained(event2) {
  var context = event2.context, createConstraints = context.createConstraints;
  if (!createConstraints) {
    return;
  }
  var top = createConstraints.top, right = createConstraints.right, bottom = createConstraints.bottom, left = createConstraints.left;
  if (left && left >= event2.x || right && right <= event2.x) {
    setSnapped(event2, "x", event2.x);
  }
  if (top && top >= event2.y || bottom && bottom <= event2.y) {
    setSnapped(event2, "y", event2.y);
  }
}
function includes(array, value) {
  return array.indexOf(value) !== -1;
}
function getDockingSnapOrigin(docking, isMove, event2) {
  return isMove ? {
    x: docking.x - event2.x,
    y: docking.y - event2.y
  } : {
    x: docking.x,
    y: docking.y
  };
}
var HIGHER_PRIORITY = 1250;
function ResizeSnapping(eventBus, snapping) {
  var self2 = this;
  eventBus.on(["resize.start"], function(event2) {
    self2.initSnap(event2);
  });
  eventBus.on([
    "resize.move",
    "resize.end"
  ], HIGHER_PRIORITY, function(event2) {
    var context = event2.context, shape = context.shape, parent = shape.parent, direction = context.direction, snapContext = context.snapContext;
    if (event2.originalEvent && isCmd(event2.originalEvent)) {
      return;
    }
    if (isSnapped(event2)) {
      return;
    }
    var snapPoints = snapContext.pointsForTarget(parent);
    if (!snapPoints.initialized) {
      snapPoints = self2.addSnapTargetPoints(snapPoints, shape, parent, direction);
      snapPoints.initialized = true;
    }
    if (isHorizontal(direction)) {
      setSnapped(event2, "x", event2.x);
    }
    if (isVertical(direction)) {
      setSnapped(event2, "y", event2.y);
    }
    snapping.snap(event2, snapPoints);
  });
  eventBus.on(["resize.cleanup"], function() {
    snapping.hide();
  });
}
ResizeSnapping.prototype.initSnap = function(event2) {
  var context = event2.context, shape = context.shape, direction = context.direction, snapContext = context.snapContext;
  if (!snapContext) {
    snapContext = context.snapContext = new SnapContext();
  }
  var snapOrigin = getSnapOrigin(shape, direction);
  snapContext.setSnapOrigin("corner", {
    x: snapOrigin.x - event2.x,
    y: snapOrigin.y - event2.y
  });
  return snapContext;
};
ResizeSnapping.prototype.addSnapTargetPoints = function(snapPoints, shape, target, direction) {
  var snapTargets = this.getSnapTargets(shape, target);
  forEach$1(snapTargets, function(snapTarget) {
    snapPoints.add("corner", bottomRight(snapTarget));
    snapPoints.add("corner", topLeft(snapTarget));
  });
  snapPoints.add("corner", getSnapOrigin(shape, direction));
  return snapPoints;
};
ResizeSnapping.$inject = [
  "eventBus",
  "snapping"
];
ResizeSnapping.prototype.getSnapTargets = function(shape, target) {
  return getChildren(target).filter(function(child) {
    return !isAttached(child, shape) && !isConnection(child) && !isHidden(child) && !isLabel(child);
  });
};
function getSnapOrigin(shape, direction) {
  var mid2 = getMid(shape), trbl = asTRBL(shape);
  var snapOrigin = {
    x: mid2.x,
    y: mid2.y
  };
  if (direction.indexOf("n") !== -1) {
    snapOrigin.y = trbl.top;
  } else if (direction.indexOf("s") !== -1) {
    snapOrigin.y = trbl.bottom;
  }
  if (direction.indexOf("e") !== -1) {
    snapOrigin.x = trbl.right;
  } else if (direction.indexOf("w") !== -1) {
    snapOrigin.x = trbl.left;
  }
  return snapOrigin;
}
function isAttached(element, host) {
  return element.host === host;
}
function isHidden(element) {
  return !!element.hidden;
}
function isHorizontal(direction) {
  return direction === "n" || direction === "s";
}
function isVertical(direction) {
  return direction === "e" || direction === "w";
}
var SNAP_TOLERANCE = 7;
var SNAP_LINE_HIDE_DELAY = 1e3;
function Snapping(canvas) {
  this._canvas = canvas;
  this._asyncHide = debounce(bind$2(this.hide, this), SNAP_LINE_HIDE_DELAY);
}
Snapping.$inject = ["canvas"];
Snapping.prototype.snap = function(event2, snapPoints) {
  var context = event2.context, snapContext = context.snapContext, snapLocations = snapContext.getSnapLocations();
  var snapping = {
    x: isSnapped(event2, "x"),
    y: isSnapped(event2, "y")
  };
  forEach$1(snapLocations, function(location) {
    var snapOrigin = snapContext.getSnapOrigin(location);
    var snapCurrent = {
      x: event2.x + snapOrigin.x,
      y: event2.y + snapOrigin.y
    };
    forEach$1(["x", "y"], function(axis) {
      var locationSnapping;
      if (!snapping[axis]) {
        locationSnapping = snapPoints.snap(snapCurrent, location, axis, SNAP_TOLERANCE);
        if (locationSnapping !== void 0) {
          snapping[axis] = {
            value: locationSnapping,
            originValue: locationSnapping - snapOrigin[axis]
          };
        }
      }
    });
    if (snapping.x && snapping.y) {
      return false;
    }
  });
  this.showSnapLine("vertical", snapping.x && snapping.x.value);
  this.showSnapLine("horizontal", snapping.y && snapping.y.value);
  forEach$1(["x", "y"], function(axis) {
    var axisSnapping = snapping[axis];
    if (isObject(axisSnapping)) {
      setSnapped(event2, axis, axisSnapping.originValue);
    }
  });
};
Snapping.prototype._createLine = function(orientation) {
  var root = this._canvas.getLayer("snap");
  var line = create$1("path");
  attr(line, { d: "M0,0 L0,0" });
  classes(line).add("djs-snap-line");
  append(root, line);
  return {
    update: function(position) {
      if (!isNumber(position)) {
        attr(line, { display: "none" });
      } else {
        if (orientation === "horizontal") {
          attr(line, {
            d: "M-100000," + position + " L+100000," + position,
            display: ""
          });
        } else {
          attr(line, {
            d: "M " + position + ",-100000 L " + position + ", +100000",
            display: ""
          });
        }
      }
    }
  };
};
Snapping.prototype._createSnapLines = function() {
  this._snapLines = {
    horizontal: this._createLine("horizontal"),
    vertical: this._createLine("vertical")
  };
};
Snapping.prototype.showSnapLine = function(orientation, position) {
  var line = this.getSnapLine(orientation);
  if (line) {
    line.update(position);
  }
  this._asyncHide();
};
Snapping.prototype.getSnapLine = function(orientation) {
  if (!this._snapLines) {
    this._createSnapLines();
  }
  return this._snapLines[orientation];
};
Snapping.prototype.hide = function() {
  forEach$1(this._snapLines, function(snapLine) {
    snapLine.update();
  });
};
const SnappingModule$1 = {
  __init__: [
    "createMoveSnapping",
    "resizeSnapping",
    "snapping"
  ],
  createMoveSnapping: ["type", CreateMoveSnapping],
  resizeSnapping: ["type", ResizeSnapping],
  snapping: ["type", Snapping]
};
const SnappingModule = {
  __depends__: [SnappingModule$1],
  __init__: [
    "connectSnapping",
    "createMoveSnapping"
  ],
  connectSnapping: ["type", BpmnConnectSnapping],
  createMoveSnapping: ["type", BpmnCreateMoveSnapping]
};
function SearchPad(canvas, eventBus, overlays, selection, translate2) {
  this._open = false;
  this._results = [];
  this._eventMaps = [];
  this._canvas = canvas;
  this._eventBus = eventBus;
  this._overlays = overlays;
  this._selection = selection;
  this._translate = translate2;
  this._container = this._getBoxHtml();
  this._searchInput = query(SearchPad.INPUT_SELECTOR, this._container);
  this._resultsContainer = query(SearchPad.RESULTS_CONTAINER_SELECTOR, this._container);
  this._canvas.getContainer().appendChild(this._container);
  eventBus.on(["canvas.destroy", "diagram.destroy"], this.close, this);
}
SearchPad.$inject = [
  "canvas",
  "eventBus",
  "overlays",
  "selection",
  "translate"
];
SearchPad.prototype._bindEvents = function() {
  var self2 = this;
  function listen(el, selector, type, fn) {
    self2._eventMaps.push({
      el,
      type,
      listener: delegate.bind(el, selector, type, fn)
    });
  }
  listen(document, "html", "click", function(e2) {
    self2.close();
  });
  listen(this._container, SearchPad.INPUT_SELECTOR, "click", function(e2) {
    e2.stopPropagation();
    e2.delegateTarget.focus();
  });
  listen(this._container, SearchPad.RESULT_SELECTOR, "mouseover", function(e2) {
    e2.stopPropagation();
    self2._scrollToNode(e2.delegateTarget);
    self2._preselect(e2.delegateTarget);
  });
  listen(this._container, SearchPad.RESULT_SELECTOR, "click", function(e2) {
    e2.stopPropagation();
    self2._select(e2.delegateTarget);
  });
  listen(this._container, SearchPad.INPUT_SELECTOR, "keydown", function(e2) {
    if (isKey("ArrowUp", e2)) {
      e2.preventDefault();
    }
    if (isKey("ArrowDown", e2)) {
      e2.preventDefault();
    }
  });
  listen(this._container, SearchPad.INPUT_SELECTOR, "keyup", function(e2) {
    if (isKey("Escape", e2)) {
      return self2.close();
    }
    if (isKey("Enter", e2)) {
      var selected = self2._getCurrentResult();
      return selected ? self2._select(selected) : self2.close();
    }
    if (isKey("ArrowUp", e2)) {
      return self2._scrollToDirection(true);
    }
    if (isKey("ArrowDown", e2)) {
      return self2._scrollToDirection();
    }
    if (isKey(["ArrowLeft", "ArrowRight"], e2)) {
      return;
    }
    self2._search(e2.delegateTarget.value);
  });
};
SearchPad.prototype._unbindEvents = function() {
  this._eventMaps.forEach(function(m2) {
    delegate.unbind(m2.el, m2.type, m2.listener);
  });
};
SearchPad.prototype._search = function(pattern) {
  var self2 = this;
  this._clearResults();
  if (!pattern || pattern === "") {
    return;
  }
  var searchResults = this._searchProvider.find(pattern);
  if (!searchResults.length) {
    return;
  }
  searchResults.forEach(function(result) {
    var id = result.element.id;
    var node3 = self2._createResultNode(result, id);
    self2._results[id] = {
      element: result.element,
      node: node3
    };
  });
  var node2 = query(SearchPad.RESULT_SELECTOR, this._resultsContainer);
  this._scrollToNode(node2);
  this._preselect(node2);
};
SearchPad.prototype._scrollToDirection = function(previous) {
  var selected = this._getCurrentResult();
  if (!selected) {
    return;
  }
  var node2 = previous ? selected.previousElementSibling : selected.nextElementSibling;
  if (node2) {
    this._scrollToNode(node2);
    this._preselect(node2);
  }
};
SearchPad.prototype._scrollToNode = function(node2) {
  if (!node2 || node2 === this._getCurrentResult()) {
    return;
  }
  var nodeOffset = node2.offsetTop;
  var containerScroll = this._resultsContainer.scrollTop;
  var bottomScroll = nodeOffset - this._resultsContainer.clientHeight + node2.clientHeight;
  if (nodeOffset < containerScroll) {
    this._resultsContainer.scrollTop = nodeOffset;
  } else if (containerScroll < bottomScroll) {
    this._resultsContainer.scrollTop = bottomScroll;
  }
};
SearchPad.prototype._clearResults = function() {
  clear$1(this._resultsContainer);
  this._results = [];
  this._resetOverlay();
  this._eventBus.fire("searchPad.cleared");
};
SearchPad.prototype._getCurrentResult = function() {
  return query(SearchPad.RESULT_SELECTED_SELECTOR, this._resultsContainer);
};
SearchPad.prototype._createResultNode = function(result, id) {
  var node2 = domify$1(SearchPad.RESULT_HTML);
  if (result.primaryTokens.length > 0) {
    createInnerTextNode(node2, result.primaryTokens, SearchPad.RESULT_PRIMARY_HTML);
  }
  createInnerTextNode(node2, result.secondaryTokens, SearchPad.RESULT_SECONDARY_HTML);
  attr$1(node2, SearchPad.RESULT_ID_ATTRIBUTE, id);
  this._resultsContainer.appendChild(node2);
  return node2;
};
SearchPad.prototype.registerProvider = function(provider) {
  this._searchProvider = provider;
};
SearchPad.prototype.open = function() {
  if (!this._searchProvider) {
    throw new Error("no search provider registered");
  }
  if (this.isOpen()) {
    return;
  }
  this._bindEvents();
  this._open = true;
  classes$1(this._container).add("open");
  this._searchInput.focus();
  this._eventBus.fire("searchPad.opened");
};
SearchPad.prototype.close = function() {
  if (!this.isOpen()) {
    return;
  }
  this._unbindEvents();
  this._open = false;
  classes$1(this._container).remove("open");
  this._clearResults();
  this._searchInput.value = "";
  this._searchInput.blur();
  this._resetOverlay();
  this._eventBus.fire("searchPad.closed");
};
SearchPad.prototype.toggle = function() {
  this.isOpen() ? this.close() : this.open();
};
SearchPad.prototype.isOpen = function() {
  return this._open;
};
SearchPad.prototype._preselect = function(node2) {
  var selectedNode = this._getCurrentResult();
  if (node2 === selectedNode) {
    return;
  }
  if (selectedNode) {
    classes$1(selectedNode).remove(SearchPad.RESULT_SELECTED_CLASS);
  }
  var id = attr$1(node2, SearchPad.RESULT_ID_ATTRIBUTE);
  var element = this._results[id].element;
  classes$1(node2).add(SearchPad.RESULT_SELECTED_CLASS);
  this._resetOverlay(element);
  this._canvas.scrollToElement(element, { top: 400 });
  this._selection.select(element);
  this._eventBus.fire("searchPad.preselected", element);
};
SearchPad.prototype._select = function(node2) {
  var id = attr$1(node2, SearchPad.RESULT_ID_ATTRIBUTE);
  var element = this._results[id].element;
  this.close();
  this._resetOverlay();
  this._canvas.scrollToElement(element, { top: 400 });
  this._selection.select(element);
  this._eventBus.fire("searchPad.selected", element);
};
SearchPad.prototype._resetOverlay = function(element) {
  if (this._overlayId) {
    this._overlays.remove(this._overlayId);
  }
  if (element) {
    var box = getBBox(element);
    var overlay = constructOverlay(box);
    this._overlayId = this._overlays.add(element, overlay);
  }
};
SearchPad.prototype._getBoxHtml = function() {
  const box = domify$1(SearchPad.BOX_HTML);
  const input = query(SearchPad.INPUT_SELECTOR, box);
  if (input) {
    input.setAttribute("aria-label", this._translate("Search in diagram"));
  }
  return box;
};
function constructOverlay(box) {
  var offset = 6;
  var w2 = box.width + offset * 2;
  var h2 = box.height + offset * 2;
  var styles = {
    width: w2 + "px",
    height: h2 + "px"
  };
  var html = domify$1('<div class="' + SearchPad.OVERLAY_CLASS + '"></div>');
  assign(html, styles);
  return {
    position: {
      bottom: h2 - offset,
      right: w2 - offset
    },
    show: true,
    html
  };
}
function createInnerTextNode(parentNode, tokens, template) {
  var text = createHtmlText(tokens);
  var childNode = domify$1(template);
  childNode.innerHTML = text;
  parentNode.appendChild(childNode);
}
function createHtmlText(tokens) {
  var htmlText = "";
  tokens.forEach(function(t2) {
    if (t2.matched) {
      htmlText += '<strong class="' + SearchPad.RESULT_HIGHLIGHT_CLASS + '">' + escapeHTML(t2.matched) + "</strong>";
    } else {
      htmlText += escapeHTML(t2.normal);
    }
  });
  return htmlText !== "" ? htmlText : null;
}
SearchPad.CONTAINER_SELECTOR = ".djs-search-container";
SearchPad.INPUT_SELECTOR = ".djs-search-input input";
SearchPad.RESULTS_CONTAINER_SELECTOR = ".djs-search-results";
SearchPad.RESULT_SELECTOR = ".djs-search-result";
SearchPad.RESULT_SELECTED_CLASS = "djs-search-result-selected";
SearchPad.RESULT_SELECTED_SELECTOR = "." + SearchPad.RESULT_SELECTED_CLASS;
SearchPad.RESULT_ID_ATTRIBUTE = "data-result-id";
SearchPad.RESULT_HIGHLIGHT_CLASS = "djs-search-highlight";
SearchPad.OVERLAY_CLASS = "djs-search-overlay";
SearchPad.BOX_HTML = '<div class="djs-search-container djs-draggable djs-scrollable"><div class="djs-search-input"><input type="text"/></div><div class="djs-search-results"></div></div>';
SearchPad.RESULT_HTML = '<div class="djs-search-result"></div>';
SearchPad.RESULT_PRIMARY_HTML = '<div class="djs-search-result-primary"></div>';
SearchPad.RESULT_SECONDARY_HTML = '<p class="djs-search-result-secondary"></p>';
const SearchPadModule = {
  __depends__: [
    translate,
    OverlaysModule,
    SelectionModule
  ],
  searchPad: ["type", SearchPad]
};
function BpmnSearchProvider(elementRegistry, searchPad, canvas) {
  this._elementRegistry = elementRegistry;
  this._canvas = canvas;
  searchPad.registerProvider(this);
}
BpmnSearchProvider.$inject = [
  "elementRegistry",
  "searchPad",
  "canvas"
];
BpmnSearchProvider.prototype.find = function(pattern) {
  var rootElement = this._canvas.getRootElement();
  var elements = this._elementRegistry.filter(function(element) {
    if (element.labelTarget) {
      return false;
    }
    return true;
  });
  elements = filter(elements, function(element) {
    return element !== rootElement;
  });
  elements = map$1(elements, function(element) {
    return {
      primaryTokens: matchAndSplit(getLabel(element), pattern),
      secondaryTokens: matchAndSplit(element.id, pattern),
      element
    };
  });
  elements = filter(elements, function(element) {
    return hasMatched(element.primaryTokens) || hasMatched(element.secondaryTokens);
  });
  elements = sortBy(elements, function(element) {
    return getLabel(element.element) + element.element.id;
  });
  return elements;
};
function hasMatched(tokens) {
  var matched = filter(tokens, function(token) {
    return !!token.matched;
  });
  return matched.length > 0;
}
function matchAndSplit(text, pattern) {
  var tokens = [], originalText = text;
  if (!text) {
    return tokens;
  }
  text = text.toLowerCase();
  pattern = pattern.toLowerCase();
  var i2 = text.indexOf(pattern);
  if (i2 > -1) {
    if (i2 !== 0) {
      tokens.push({
        normal: originalText.substr(0, i2)
      });
    }
    tokens.push({
      matched: originalText.substr(i2, pattern.length)
    });
    if (pattern.length + i2 < text.length) {
      tokens.push({
        normal: originalText.substr(pattern.length + i2, text.length)
      });
    }
  } else {
    tokens.push({
      normal: originalText
    });
  }
  return tokens;
}
const SearchModule = {
  __depends__: [
    SearchPadModule
  ],
  __init__: ["bpmnSearch"],
  bpmnSearch: ["type", BpmnSearchProvider]
};
var initialDiagram = '<?xml version="1.0" encoding="UTF-8"?><bpmn:definitions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:bpmn="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:dc="http://www.omg.org/spec/DD/20100524/DC" targetNamespace="http://bpmn.io/schema/bpmn" id="Definitions_1"><bpmn:process id="Process_1" isExecutable="false"><bpmn:startEvent id="StartEvent_1"/></bpmn:process><bpmndi:BPMNDiagram id="BPMNDiagram_1"><bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="Process_1"><bpmndi:BPMNShape id="_BPMNShape_StartEvent_2" bpmnElement="StartEvent_1"><dc:Bounds height="36.0" width="36.0" x="173.0" y="102.0"/></bpmndi:BPMNShape></bpmndi:BPMNPlane></bpmndi:BPMNDiagram></bpmn:definitions>';
function Modeler(options) {
  BaseModeler.call(this, options);
}
e$3(Modeler, BaseModeler);
Modeler.Viewer = Viewer;
Modeler.NavigatedViewer = NavigatedViewer;
Modeler.prototype.createDiagram = function createDiagram() {
  return this.importXML(initialDiagram);
};
Modeler.prototype._interactionModules = [
  // non-modeling components
  KeyboardMoveModule,
  MoveCanvasModule,
  ZoomScrollModule
];
Modeler.prototype._modelingModules = [
  // modeling components
  AlignElementsModule,
  AutoPlaceModule,
  AutoScrollModule,
  AutoResizeModule,
  BendpointsModule,
  ConnectModule,
  ConnectionPreviewModule,
  ContextPadModule,
  CopyPasteModule,
  CreateModule,
  DistributeElementsModule,
  EditorActionsModule,
  GridSnappingModule,
  InteractionEventsModule,
  KeyboardModule,
  KeyboardMoveSelectionModule,
  LabelEditingModule,
  ModelingModule,
  ModelingFeedbackModule,
  MoveModule,
  OutlineModule,
  PaletteModule,
  ReplacePreviewModule,
  ResizeModule,
  SnappingModule,
  SearchModule
];
Modeler.prototype._modules = [].concat(
  Viewer.prototype._modules,
  Modeler.prototype._interactionModules,
  Modeler.prototype._modelingModules
);
const EVENT_TYPE = ["element.click", "shape.added", "element.changed"];
class BPMN {
  constructor(cbk) {
    __publicField(this, "activeElement");
    __publicField(this, "activeElementID");
    __publicField(this, "businessObject");
    __publicField(this, "activeBindDefine");
    __publicField(this, "updatingProperties");
    __publicField(this, "modeler");
    __publicField(this, "shapeType");
    __publicField(this, "typeChange");
    __publicField(this, "dataChange");
    if (cbk) {
      const { typeChange, dataChange } = cbk;
      this.typeChange = typeChange;
      this.dataChange = dataChange;
    }
    this.updatingProperties = false;
  }
  getters() {
  }
  setters() {
  }
  /**
   * 刷新状态方法
   * @param elementRegistry 所有的节点
   * @param elementAction 动作dom
   * @returns
   * 1.如果没有bpmn或者没有动作对象直接结束
   * 2.保存动作对象到store中的activeElement
   * 3.获取当前动作的element
   * 4.根据element的id获取shape
   * 5.获取shape上保存的数据也就是businessObject,这一布有判断 如果没有shape 给定一个空对象
   * 6.获取这个节点的类型
   * 7.通过节点的类型获取对应的抽屉组件集合并保存到store的activeBindDefine
   */
  //刷新状态
  refreshState(elementRegistry, elementAction) {
    var _a;
    if (!this || !elementAction) {
      return;
    }
    this.activeElement = elementAction;
    let shape = {};
    let element = {};
    if (elementAction.id) {
      shape = elementAction;
      this.activeElement = elementAction;
      element = elementAction;
    } else {
      element = elementAction.element;
      shape = elementRegistry.get(element.id);
    }
    this.activeElementID = element.id;
    if (typeof this.dataChange == "function") {
      this.dataChange(this.businessObject, shape == null ? void 0 : shape.businessObject);
    }
    this.businessObject = shape ? shape.businessObject : {};
    let type = element.type;
    if (element.type === "label" && /_label$/.test(element.id)) {
      const replace = element.id.replace(/_label$/, "");
      type = (_a = elementRegistry._elements[replace]) == null ? void 0 : _a.element.type;
    }
    if (typeof this.typeChange == "function") {
      this.typeChange(this.shapeType, type);
    }
    this.shapeType = type;
  }
  /**
   * 初始化bpmn
   * @param options
   * 1.创建bpmn对象 并保存在store的modeler中
   * 2.获取所有的节点 通过get(节点id)的方法
   * 3.给bpmn绑定事件 分别为element.click:点击节点  shape.added:新增节点 element:changed:节点变化
   * 4.根据事件的类型来进行同的初始化操作也就是执行refreshState方法
   */
  initModeler(options) {
    this.modeler = new Modeler(options);
    const elementRegistry = this.modeler.get("elementRegistry");
    EVENT_TYPE.forEach((event2) => {
      this.addEventListener(event2, (elementAction) => {
        var _a;
        console.log(elementAction);
        const element = elementAction.element || elementAction.context.element;
        if (!element && !elementAction.type) {
          return;
        }
        if (element.type == "label" && elementAction.type == "shape.added") {
          return;
        }
        const updating = this.updatingProperties;
        const elementTypeNonEqualActive = ((_a = this == null ? void 0 : this.activeElement) == null ? void 0 : _a.element) && element.id !== this.activeElement.element.id;
        if ("element.changed" == elementAction.type && (updating || elementTypeNonEqualActive)) {
          return;
        }
        nextTick().then(() => {
          if (event2 == "element.click" || event2 == "shape.added") {
            this.activeElementID = element.id;
          }
          if (event2 === "shape.added" && ["bpmn:StartEvent", "bpmn:UserTask"].includes(element.type) && !element.businessObject.name) {
            const length2 = this.getShapeAll().filter(
              (item) => ["bpmn:StartEvent", "bpmn:UserTask"].includes(item.type)
            ).length || 0;
            this.updateProperties(element, {
              name: element.type == "bpmn:StartEvent" ? "开始节点" : "未命名节点" + length2
            });
          }
          this.refreshState(elementRegistry, elementAction);
        });
      });
    });
  }
  getModeling() {
    return this.getModeler().get("modeling");
  }
  getBusinessObject() {
    return this.businessObject;
  }
  getModdle() {
    return this.modeler.get("moddle");
  }
  getModeler() {
    return this.modeler;
  }
  // 获取选中的节点类型
  getShapeType() {
    return this.shapeType;
  }
  //获取选中的节点
  getActiveElement() {
    return this.activeElement;
  }
  //获取图中所有节点
  getShapeAll() {
    return this.modeler.get("elementRegistry").getAll()[0].children;
  }
  getShapeById(id) {
    const elementRegistry = this.modeler.get("elementRegistry");
    return elementRegistry.get(id);
  }
  getShape() {
    return this.getShapeById(this.activeElement.element.id);
  }
  //获取xml数据
  getXML() {
    return new Promise((resolve, reject) => {
      this.modeler.saveXML({ format: true }).then((response) => {
        resolve(response);
      }).catch((err) => {
        reject(err);
      });
    });
  }
  //更新节点数据
  updateProperties(element, properties) {
    this.updatingProperties = true;
    this.modeler.get("modeling").updateProperties(element, properties);
    this.updatingProperties = false;
  }
  updateExtensionElements(elementName, value) {
    var _a, _b;
    const moddle = this.getModdle();
    const element = this.getShape();
    const extensionElements = (_a = this.getBusinessObject()) == null ? void 0 : _a.extensionElements;
    const otherExtensions = ((_b = extensionElements == null ? void 0 : extensionElements.values) == null ? void 0 : _b.filter((ex) => ex.$type !== elementName).map((item) => toRaw(item))) || [];
    const extensions = moddle.create("bpmn:ExtensionElements", {
      values: otherExtensions.concat(value instanceof Array ? value : [value])
    });
    this.updateProperties(element, { extensionElements: extensions });
  }
  addEventListener(string, func) {
    this.modeler.get("eventBus").on(string, function(e2) {
      func(e2);
    });
  }
  //导入xml生成数据
  importXML(string) {
    return this.modeler.importXML(string);
  }
  setType(value) {
    this.shapeType = value;
  }
  setActiveElement(value) {
    this.activeElement = value;
  }
  resetData() {
    this.activeElement = null;
    this.businessObject = null;
    this.activeBindDefine = null;
    this.updatingProperties = false;
    this.modeler = null;
    this.shapeType = void 0;
  }
}
const i18nTranslate_zh = {
  // 添加部分
  "Append EndEvent": "追加结束事件",
  "Append Gateway": "追加网关",
  "Append Task": "追加任务",
  "Append Intermediate/Boundary Event": "追加中间抛出事件/边界事件",
  "Activate the global connect tool": "激活全局连接工具",
  "Append {type}": "添加 {type}",
  "Add Lane above": "在上面添加道",
  "Divide into two Lanes": "分割成两个道",
  "Divide into three Lanes": "分割成三个道",
  "Add Lane below": "在下面添加道",
  "Append compensation activity": "追加补偿活动",
  "Change type": "修改类型",
  "Connect using Association": "使用关联连接",
  "Connect using Sequence/MessageFlow or Association": "使用顺序/消息流或者关联连接",
  "Connect using DataInputAssociation": "使用数据输入关联连接",
  Remove: "移除",
  "Activate the hand tool": "激活抓手工具",
  "Activate the lasso tool": "激活套索工具",
  "Activate the create/remove space tool": "激活创建/删除空间工具",
  "Create expanded SubProcess": "创建扩展子过程",
  "Create IntermediateThrowEvent/BoundaryEvent": "创建中间抛出事件/边界事件",
  "Create Pool/Participant": "创建池/参与者",
  "Parallel Multi Instance": "并行多重事件",
  "Sequential Multi Instance": "时序多重事件",
  DataObjectReference: "数据对象参考",
  DataStoreReference: "数据存储参考",
  Loop: "循环",
  "Ad-hoc": "即席",
  "Create {type}": "创建 {type}",
  Task: "任务",
  "Send Task": "发送任务",
  "Receive Task": "接收任务",
  "User Task": "用户任务",
  "Manual Task": "手工任务",
  "Business Rule Task": "业务规则任务",
  "Service Task": "服务任务",
  "Script Task": "脚本任务",
  "Call Activity": "调用活动",
  "Sub Process (collapsed)": "子流程（折叠的）",
  "Sub Process (expanded)": "子流程（展开的）",
  "Start Event": "开始事件",
  StartEvent: "开始事件",
  "Intermediate Throw Event": "中间事件",
  "End Event": "结束事件",
  EndEvent: "结束事件",
  "Create StartEvent": "创建开始事件",
  "Create EndEvent": "创建结束事件",
  "Create Task": "创建任务",
  "Create User Task": "创建用户任务",
  "Create Gateway": "创建网关",
  "Create DataObjectReference": "创建数据对象",
  "Create DataStoreReference": "创建数据存储",
  "Create Group": "创建分组",
  "Create Intermediate/Boundary Event": "创建中间/边界事件",
  "Message Start Event": "消息开始事件",
  "Timer Start Event": "定时开始事件",
  "Conditional Start Event": "条件开始事件",
  "Signal Start Event": "信号开始事件",
  "Error Start Event": "错误开始事件",
  "Escalation Start Event": "升级开始事件",
  "Compensation Start Event": "补偿开始事件",
  "Message Start Event (non-interrupting)": "消息开始事件（非中断）",
  "Timer Start Event (non-interrupting)": "定时开始事件（非中断）",
  "Conditional Start Event (non-interrupting)": "条件开始事件（非中断）",
  "Signal Start Event (non-interrupting)": "信号开始事件（非中断）",
  "Escalation Start Event (non-interrupting)": "升级开始事件（非中断）",
  "Message Intermediate Catch Event": "消息中间捕获事件",
  "Message Intermediate Throw Event": "消息中间抛出事件",
  "Timer Intermediate Catch Event": "定时中间捕获事件",
  "Escalation Intermediate Throw Event": "升级中间抛出事件",
  "Conditional Intermediate Catch Event": "条件中间捕获事件",
  "Link Intermediate Catch Event": "链接中间捕获事件",
  "Link Intermediate Throw Event": "链接中间抛出事件",
  "Compensation Intermediate Throw Event": "补偿中间抛出事件",
  "Signal Intermediate Catch Event": "信号中间捕获事件",
  "Signal Intermediate Throw Event": "信号中间抛出事件",
  "Message End Event": "消息结束事件",
  "Escalation End Event": "定时结束事件",
  "Error End Event": "错误结束事件",
  "Cancel End Event": "取消结束事件",
  "Compensation End Event": "补偿结束事件",
  "Signal End Event": "信号结束事件",
  "Terminate End Event": "终止结束事件",
  "Message Boundary Event": "消息边界事件",
  "Message Boundary Event (non-interrupting)": "消息边界事件（非中断）",
  "Timer Boundary Event": "定时边界事件",
  "Timer Boundary Event (non-interrupting)": "定时边界事件（非中断）",
  "Escalation Boundary Event": "升级边界事件",
  "Escalation Boundary Event (non-interrupting)": "升级边界事件（非中断）",
  "Conditional Boundary Event": "条件边界事件",
  "Conditional Boundary Event (non-interrupting)": "条件边界事件（非中断）",
  "Error Boundary Event": "错误边界事件",
  "Cancel Boundary Event": "取消边界事件",
  "Signal Boundary Event": "信号边界事件",
  "Signal Boundary Event (non-interrupting)": "信号边界事件（非中断）",
  "Compensation Boundary Event": "补偿边界事件",
  "Exclusive Gateway": "互斥网关",
  "Parallel Gateway": "并行网关",
  "Inclusive Gateway": "相容网关",
  "Complex Gateway": "复杂网关",
  "Event based Gateway": "事件网关",
  Transaction: "转运",
  "Sub Process": "子流程",
  "Event Sub Process": "事件子流程",
  "Collapsed Pool": "折叠池",
  "Expanded Pool": "展开池",
  // Errors
  "no parent for {element} in {parent}": "在{parent}里，{element}没有父类",
  "no shape type specified": "没有指定的形状类型",
  "flow elements must be children of pools/participants": "流元素必须是池/参与者的子类",
  "out of bounds release": "out of bounds release",
  "more than {count} child lanes": "子道大于{count} ",
  "element required": "元素不能为空",
  "diagram not part of bpmn:Definitions": "流程图不符合bpmn规范",
  "no diagram to display": "没有可展示的流程图",
  "no process or collaboration to display": "没有可展示的流程/协作",
  "element {element} referenced by {referenced}#{property} not yet drawn": "由{referenced}#{property}引用的{element}元素仍未绘制",
  "already rendered {element}": "{element} 已被渲染",
  "failed to import {element}": "导入{element}失败",
  //属性面板的参数
  Id: "编号",
  Name: "名称",
  General: "常规",
  Details: "详情",
  "Message Name": "消息名称",
  Message: "消息",
  Initiator: "创建者",
  "Asynchronous Continuations": "持续异步",
  "Asynchronous Before": "异步前",
  "Asynchronous After": "异步后",
  "Job Configuration": "工作配置",
  Exclusive: "排除",
  "Job Priority": "工作优先级",
  "Retry Time Cycle": "重试时间周期",
  Documentation: "文档",
  "Element Documentation": "元素文档",
  "History Configuration": "历史配置",
  "History Time To Live": "历史的生存时间",
  Forms: "表单",
  "Form Key": "表单key",
  "Form Fields": "表单字段",
  "Business Key": "业务key",
  "Form Field": "表单字段",
  ID: "编号",
  Type: "类型",
  Label: "名称",
  "Default Value": "默认值",
  "Default Flow": "默认流转路径",
  "Conditional Flow": "条件流转路径",
  "Sequence Flow": "普通流转路径",
  Validation: "校验",
  "Add Constraint": "添加约束",
  Config: "配置",
  Properties: "属性",
  "Add Property": "添加属性",
  Value: "值",
  Listeners: "监听器",
  "Execution Listener": "执行监听",
  "Event Type": "事件类型",
  "Listener Type": "监听器类型",
  "Java Class": "Java类",
  Expression: "表达式",
  "Must provide a value": "必须提供一个值",
  "Delegate Expression": "代理表达式",
  Script: "脚本",
  "Script Format": "脚本格式",
  "Script Type": "脚本类型",
  "Inline Script": "内联脚本",
  "External Script": "外部脚本",
  Resource: "资源",
  "Field Injection": "字段注入",
  Extensions: "扩展",
  "Input/Output": "输入/输出",
  "Input Parameters": "输入参数",
  "Output Parameters": "输出参数",
  Parameters: "参数",
  "Output Parameter": "输出参数",
  "Timer Definition Type": "定时器定义类型",
  "Timer Definition": "定时器定义",
  Date: "日期",
  Duration: "持续",
  Cycle: "循环",
  Signal: "信号",
  "Signal Name": "信号名称",
  Escalation: "升级",
  Error: "错误",
  "Link Name": "链接名称",
  Condition: "条件名称",
  "Variable Name": "变量名称",
  "Variable Event": "变量事件",
  "Specify more than one variable change event as a comma separated list.": "多个变量事件以逗号隔开",
  "Wait for Completion": "等待完成",
  "Activity Ref": "活动参考",
  "Version Tag": "版本标签",
  Executable: "可执行文件",
  "External Task Configuration": "扩展任务配置",
  "Task Priority": "任务优先级",
  External: "外部",
  Connector: "连接器",
  "Must configure Connector": "必须配置连接器",
  "Connector Id": "连接器编号",
  Implementation: "实现方式",
  "Field Injections": "字段注入",
  Fields: "字段",
  "Result Variable": "结果变量",
  Topic: "主题",
  "Configure Connector": "配置连接器",
  "Input Parameter": "输入参数",
  Assignee: "代理人",
  "Candidate Users": "候选用户",
  "Candidate Groups": "候选组",
  "Due Date": "到期时间",
  "Follow Up Date": "跟踪日期",
  Priority: "优先级",
  "The follow up date as an EL expression (e.g. ${someDate} or an ISO date (e.g. 2015-06-26T09:54:00)": "跟踪日期必须符合EL表达式，如： ${someDate} ,或者一个ISO标准日期，如：2015-06-26T09:54:00",
  "The due date as an EL expression (e.g. ${someDate} or an ISO date (e.g. 2015-06-26T09:54:00)": "跟踪日期必须符合EL表达式，如： ${someDate} ,或者一个ISO标准日期，如：2015-06-26T09:54:00",
  Variables: "变量",
  "Candidate Starter Configuration": "候选人起动器配置",
  "Candidate Starter Groups": "候选人起动器组",
  "This maps to the process definition key.": "这映射到流程定义键。",
  "Candidate Starter Users": "候选人起动器的用户",
  "Specify more than one user as a comma separated list.": "指定多个用户作为逗号分隔的列表。",
  "Tasklist Configuration": "Tasklist配置",
  Startable: "启动",
  "Specify more than one group as a comma separated list.": "指定多个组作为逗号分隔的列表。"
};
const i18nMap = {
  zh: i18nTranslate_zh
};
function getI18nTranslate(i18n) {
  const i18nTranslate = i18nMap[i18n];
  return function customTranslate(template, replacements) {
    replacements = replacements || {};
    template = i18nTranslate[template] || template;
    return template.replace(/{([^}]+)}/g, function(_2, key) {
      return replacements[key] || "{" + key + "}";
    });
  };
}
const createDefaultBpmnXml = (key, name2) => {
  return `<?xml version="1.0" encoding="UTF-8"?>
  <bpmn2:definitions
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:bpmn2="http://www.omg.org/spec/BPMN/20100524/MODEL"
    xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI"
    xmlns:dc="http://www.omg.org/spec/DD/20100524/DC"
    xmlns:di="http://www.omg.org/spec/DD/20100524/DI"
    xsi:schemaLocation="http://www.omg.org/spec/BPMN/20100524/MODEL BPMN20.xsd"
    id="sample-diagram"
    targetNamespace="http://activiti.org/bpmn">
    <bpmn2:process id="Process_${key}" name="${name2}" isExecutable="true">
    </bpmn2:process>
    <bpmndi:BPMNDiagram id="BPMNDiagram_1">
      <bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="Process_${key}">
      </bpmndi:BPMNPlane>
    </bpmndi:BPMNDiagram>
  </bpmn2:definitions>`;
};
function PaletteProvider(palette, create2, elementFactory, spaceTool, lassoTool, handTool, globalConnect, translate2) {
  this._palette = palette;
  this._create = create2;
  this._elementFactory = elementFactory;
  this._spaceTool = spaceTool;
  this._lassoTool = lassoTool;
  this._handTool = handTool;
  this._globalConnect = globalConnect;
  this._translate = translate2;
  palette.registerProvider(this);
}
PaletteProvider.$inject = [
  "palette",
  "create",
  "elementFactory",
  "spaceTool",
  "lassoTool",
  "handTool",
  "globalConnect",
  "translate"
];
PaletteProvider.prototype.getPaletteEntries = function(_element) {
  var actions = {}, create2 = this._create, elementFactory = this._elementFactory, spaceTool = this._spaceTool, lassoTool = this._lassoTool, handTool = this._handTool, globalConnect = this._globalConnect, translate2 = this._translate;
  function createAction(type, group, className, title, options) {
    function createListener(event2) {
      var shape = elementFactory.createShape(Object.assign({ type }, options));
      if (options) {
        shape.businessObject.di.isExpanded = options.isExpanded;
      }
      create2.start(event2, shape);
    }
    var shortType = type.replace(/^bpmn:/, "");
    return {
      group,
      className,
      title: title || translate2("Create {type}", { type: shortType }),
      action: {
        dragstart: createListener,
        click: createListener
      }
    };
  }
  Object.assign(actions, {
    "hand-tool": {
      group: "tools",
      className: "bpmn-icon-hand-tool",
      title: translate2("Activate the hand tool"),
      action: {
        click: function(event2) {
          handTool.activateHand(event2);
        }
      }
    },
    "lasso-tool": {
      group: "tools",
      className: "bpmn-icon-lasso-tool",
      title: translate2("Activate the lasso tool"),
      action: {
        click: function(event2) {
          lassoTool.activateSelection(event2);
        }
      }
    },
    "space-tool": {
      group: "tools",
      className: "bpmn-icon-space-tool",
      title: translate2("Activate the create/remove space tool"),
      action: {
        click: function(event2) {
          spaceTool.activateSelection(event2);
        }
      }
    },
    "global-connect-tool": {
      group: "tools",
      className: "bpmn-icon-connection-multi",
      title: translate2("Activate the global connect tool"),
      action: {
        click: function(event2) {
          globalConnect.start(event2);
        }
      }
    },
    "tool-separator": {
      group: "tools",
      separator: true
    },
    "create.start-event": createAction(
      "bpmn:StartEvent",
      "event",
      "bpmn-icon-start-event-none",
      translate2("Create StartEvent")
    ),
    // 'create.intermediate-event': createAction(
    //   'bpmn:IntermediateThrowEvent',
    //   'event',
    //   'bpmn-icon-intermediate-event-none',
    //   translate('Create Intermediate/Boundary Event'),
    // ),
    "create.end-event": createAction(
      "bpmn:EndEvent",
      "event",
      "bpmn-icon-end-event-none",
      translate2("Create EndEvent")
    ),
    "create.exclusive-gateway": createAction(
      "bpmn:ExclusiveGateway",
      "gateway",
      "bpmn-icon-gateway-none",
      translate2("Create Gateway")
    ),
    // 'create.task': createAction(
    //   'bpmn:Task',
    //   'activity',
    //   'bpmn-icon-task',
    //   translate('Create Task'),
    // ),
    "create.user-task": createAction(
      "bpmn:UserTask",
      "activity",
      "bpmn-icon-user-task",
      translate2("Create User Task")
    )
    // 'create.service-task': createAction(
    //   'bpmn:ServiceTask',
    //   'activity',
    //   'bpmn-icon-service-task',
    //   translate('Create Service Task'),
    // ),
    // 'create.data-object': createAction(
    //   'bpmn:DataObjectReference',
    //   'data-object',
    //   'bpmn-icon-data-object',
    //   translate('Create DataObjectReference'),
    // ),
    // 'create.data-store': createAction(
    //   'bpmn:DataStoreReference',
    //   'data-store',
    //   'bpmn-icon-data-store',
    //   translate('Create DataStoreReference'),
    // ),
    // 'create.subprocess-expanded': {
    //   group: 'activity',
    //   className: 'bpmn-icon-subprocess-expanded',
    //   title: translate('Create expanded SubProcess'),
    //   action: {
    //     dragstart: createSubprocess,
    //     click: createSubprocess,
    //   },
    // },
    // 'create.participant-expanded': {
    //   group: 'collaboration',
    //   className: 'bpmn-icon-participant',
    //   title: translate('Create Pool/Participant'),
    //   action: {
    //     dragstart: createParticipant,
    //     click: createParticipant,
    //   },
    // },
    // 'create.group': createAction(
    //   'bpmn:Group',
    //   'artifact',
    //   'bpmn-icon-group',
    //   translate('Create Group'),
    // ),
  });
  return actions;
};
const paletteProvider = {
  __depends__: [
    PaletteModule$1,
    CreateModule,
    SpaceToolModule$1,
    LassoToolModule,
    HandToolModule,
    GlobalConnectModule,
    translate
  ],
  __init__: ["paletteProvider"],
  paletteProvider: ["type", PaletteProvider]
};
function ContextPadProvider(config, injector, eventBus, contextPad, modeling, elementFactory, connect, create2, popupMenu, canvas, rules, translate2) {
  config = config || {};
  contextPad.registerProvider(this);
  this._contextPad = contextPad;
  this._modeling = modeling;
  this._elementFactory = elementFactory;
  this._connect = connect;
  this._create = create2;
  this._popupMenu = popupMenu;
  this._canvas = canvas;
  this._rules = rules;
  this._translate = translate2;
  if (config.autoPlace !== false) {
    this._autoPlace = injector.get("autoPlace", false);
  }
  eventBus.on("create.end", 250, function(event2) {
    var context = event2.context, shape = context.shape;
    if (!hasPrimaryModifier(event2) || !contextPad.isOpen(shape)) {
      return;
    }
    var entries = contextPad.getEntries(shape);
    if (entries.replace) {
      entries.replace.action.click(event2, shape);
    }
  });
}
ContextPadProvider.$inject = [
  "config.contextPad",
  "injector",
  "eventBus",
  "contextPad",
  "modeling",
  "elementFactory",
  "connect",
  "create",
  "popupMenu",
  "canvas",
  "rules",
  "translate"
];
ContextPadProvider.prototype.getContextPadEntries = function(element) {
  console.log(element);
  let modeling = this._modeling, elementFactory = this._elementFactory, connect = this._connect, create2 = this._create, autoPlace = this._autoPlace, translate2 = this._translate, actions = {};
  function appendAction(type, className, title, options) {
    if (typeof title !== "string") {
      options = title;
      title = translate2("Append {type}", { type: type.replace(/^bpmn:/, "") });
    }
    function appendStart(event2, element2) {
      var shape = elementFactory.createShape(Object.assign({ type }, options));
      create2.start(event2, shape, {
        source: element2
      });
    }
    var append2 = autoPlace ? function(event2, element2) {
      var shape = elementFactory.createShape(Object.assign({ type }, options));
      autoPlace.append(element2, shape);
    } : appendStart;
    return {
      group: "model",
      className,
      title,
      action: {
        dragstart: appendStart,
        click: append2
      }
    };
  }
  function removeElement2(_e) {
    modeling.removeElements([element]);
  }
  function startConnect(event2, element2) {
    connect.start(event2, element2);
  }
  if (element.type === "bpmn:SequenceFlow") {
    Object.assign(actions, {
      // 'append.end-event': appendAction(
      //   'bpmn:EndEvent',
      //   'bpmn-icon-end-event-none',
      //   translate('Append EndEvent'),
      // ),
      // 'append.gateway': appendAction(
      //   'bpmn:ExclusiveGateway',
      //   'bpmn-icon-gateway-none',
      //   translate('Append Gateway'),
      // ),
      // 'append.append-task': appendAction(
      //   'bpmn:UserTask',
      //   'bpmn-icon-user-task',
      //   translate('Append Task'),
      // ),
      // 'append.intermediate-event': appendAction(
      //   'bpmn:IntermediateThrowEvent',
      //   'bpmn-icon-intermediate-event-none',
      //   translate('Append Intermediate/Boundary Event'),
      // ),
      delete: {
        group: "edit",
        className: "bpmn-icon-trash",
        title: translate2("Remove"),
        action: {
          click: removeElement2
        }
      }
      // connect: {
      //   group: 'connect',
      //   className: 'bpmn-icon-connection-multi',
      //   title: translate('Connect using Association'),
      //   action: {
      //     click: startConnect,
      //     dragstart: startConnect,
      //   },
      // },
    });
  } else {
    Object.assign(actions, {
      "append.end-event": appendAction(
        "bpmn:EndEvent",
        "bpmn-icon-end-event-none",
        translate2("Append EndEvent")
      ),
      "append.gateway": appendAction(
        "bpmn:ExclusiveGateway",
        "bpmn-icon-gateway-none",
        translate2("Append Gateway")
      ),
      "append.append-task": appendAction(
        "bpmn:UserTask",
        "bpmn-icon-user-task",
        translate2("Append Task")
      ),
      // 'append.intermediate-event': appendAction(
      //   'bpmn:IntermediateThrowEvent',
      //   'bpmn-icon-intermediate-event-none',
      //   translate('Append Intermediate/Boundary Event'),
      // ),
      delete: {
        group: "edit",
        className: "bpmn-icon-trash",
        title: translate2("Remove"),
        action: {
          click: removeElement2
        }
      },
      connect: {
        group: "connect",
        className: "bpmn-icon-connection-multi",
        title: translate2("Connect using Association"),
        action: {
          click: startConnect,
          dragstart: startConnect
        }
      }
    });
  }
  return actions;
};
const CustomContextPadProvider = {
  // __depends__: [
  //   DirectEditingModule,
  //   ContextPadModule,
  //   SelectionModule,
  //   ConnectModule,
  //   CreateModule,
  // ],
  __init__: ["contextPadProvider"],
  contextPadProvider: ["type", ContextPadProvider]
};
const name = "Camunda";
const uri = "http://camunda.org/schema/1.0/bpmn";
const prefix = "camunda";
const xml = {
  tagAlias: "lowerCase"
};
const associations = [];
const types = [
  {
    name: "Definitions",
    isAbstract: true,
    "extends": [
      "bpmn:Definitions"
    ],
    properties: [
      {
        name: "diagramRelationId",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "InOutBinding",
    superClass: [
      "Element"
    ],
    isAbstract: true,
    properties: [
      {
        name: "source",
        isAttr: true,
        type: "String"
      },
      {
        name: "sourceExpression",
        isAttr: true,
        type: "String"
      },
      {
        name: "target",
        isAttr: true,
        type: "String"
      },
      {
        name: "businessKey",
        isAttr: true,
        type: "String"
      },
      {
        name: "local",
        isAttr: true,
        type: "Boolean",
        "default": false
      },
      {
        name: "variables",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "In",
    superClass: [
      "InOutBinding"
    ],
    meta: {
      allowedIn: [
        "bpmn:CallActivity",
        "bpmn:SignalEventDefinition"
      ]
    }
  },
  {
    name: "Out",
    superClass: [
      "InOutBinding"
    ],
    meta: {
      allowedIn: [
        "bpmn:CallActivity"
      ]
    }
  },
  {
    name: "AsyncCapable",
    isAbstract: true,
    "extends": [
      "bpmn:Activity",
      "bpmn:Gateway",
      "bpmn:Event"
    ],
    properties: [
      {
        name: "async",
        isAttr: true,
        type: "Boolean",
        "default": false
      },
      {
        name: "asyncBefore",
        isAttr: true,
        type: "Boolean",
        "default": false
      },
      {
        name: "asyncAfter",
        isAttr: true,
        type: "Boolean",
        "default": false
      },
      {
        name: "exclusive",
        isAttr: true,
        type: "Boolean",
        "default": true
      }
    ]
  },
  {
    name: "JobPriorized",
    isAbstract: true,
    "extends": [
      "bpmn:Process",
      "camunda:AsyncCapable"
    ],
    properties: [
      {
        name: "jobPriority",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "SignalEventDefinitionExtension",
    isAbstract: true,
    "extends": [
      "bpmn:SignalEventDefinition"
    ],
    properties: [
      {
        name: "async",
        isAttr: true,
        type: "Boolean",
        "default": false
      }
    ]
  },
  {
    name: "ErrorEventDefinitionExtension",
    isAbstract: true,
    "extends": [
      "bpmn:ErrorEventDefinition"
    ],
    properties: [
      {
        name: "errorCodeVariable",
        isAttr: true,
        type: "String"
      },
      {
        name: "errorMessageVariable",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ErrorEventDefinition",
    superClass: [
      "bpmn:ErrorEventDefinition",
      "Element"
    ],
    properties: [
      {
        name: "expression",
        isAttr: true,
        type: "String"
      }
    ],
    meta: {
      allowedIn: [
        "bpmn:ServiceTask"
      ]
    }
  },
  {
    name: "Error",
    isAbstract: true,
    "extends": [
      "bpmn:Error"
    ],
    properties: [
      {
        name: "camunda:errorMessage",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "PotentialStarter",
    superClass: [
      "Element"
    ],
    properties: [
      {
        name: "resourceAssignmentExpression",
        type: "bpmn:ResourceAssignmentExpression"
      }
    ]
  },
  {
    name: "FormSupported",
    isAbstract: true,
    "extends": [
      "bpmn:StartEvent",
      "bpmn:UserTask"
    ],
    properties: [
      {
        name: "formHandlerClass",
        isAttr: true,
        type: "String"
      },
      {
        name: "formKey",
        isAttr: true,
        type: "String"
      },
      {
        name: "formRef",
        isAttr: true,
        type: "String"
      },
      {
        name: "formRefBinding",
        isAttr: true,
        type: "String"
      },
      {
        name: "formRefVersion",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "TemplateSupported",
    isAbstract: true,
    "extends": [
      "bpmn:Collaboration",
      "bpmn:Process",
      "bpmn:FlowElement"
    ],
    properties: [
      {
        name: "modelerTemplate",
        isAttr: true,
        type: "String"
      },
      {
        name: "modelerTemplateVersion",
        isAttr: true,
        type: "Integer"
      }
    ]
  },
  {
    name: "Initiator",
    isAbstract: true,
    "extends": [
      "bpmn:StartEvent"
    ],
    properties: [
      {
        name: "initiator",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ScriptTask",
    isAbstract: true,
    "extends": [
      "bpmn:ScriptTask"
    ],
    properties: [
      {
        name: "resultVariable",
        isAttr: true,
        type: "String"
      },
      {
        name: "resource",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Process",
    isAbstract: true,
    "extends": [
      "bpmn:Process"
    ],
    properties: [
      {
        name: "candidateStarterGroups",
        isAttr: true,
        type: "String"
      },
      {
        name: "candidateStarterUsers",
        isAttr: true,
        type: "String"
      },
      {
        name: "versionTag",
        isAttr: true,
        type: "String"
      },
      {
        name: "historyTimeToLive",
        isAttr: true,
        type: "String"
      },
      {
        name: "isStartableInTasklist",
        isAttr: true,
        type: "Boolean",
        "default": true
      }
    ]
  },
  {
    name: "EscalationEventDefinitionExtension",
    isAbstract: true,
    "extends": [
      "bpmn:EscalationEventDefinition"
    ],
    properties: [
      {
        name: "escalationCodeVariable",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "FormalExpression",
    isAbstract: true,
    "extends": [
      "bpmn:FormalExpression"
    ],
    properties: [
      {
        name: "resource",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Assignable",
    "extends": [
      "bpmn:UserTask"
    ],
    properties: [
      {
        name: "assignee",
        isAttr: true,
        type: "String"
      },
      {
        name: "candidateUsers",
        isAttr: true,
        type: "String"
      },
      {
        name: "candidateGroups",
        isAttr: true,
        type: "String"
      },
      {
        name: "dueDate",
        isAttr: true,
        type: "String"
      },
      {
        name: "followUpDate",
        isAttr: true,
        type: "String"
      },
      {
        name: "priority",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "CallActivity",
    "extends": [
      "bpmn:CallActivity"
    ],
    properties: [
      {
        name: "calledElementBinding",
        isAttr: true,
        type: "String",
        "default": "latest"
      },
      {
        name: "calledElementVersion",
        isAttr: true,
        type: "String"
      },
      {
        name: "calledElementVersionTag",
        isAttr: true,
        type: "String"
      },
      {
        name: "calledElementTenantId",
        isAttr: true,
        type: "String"
      },
      {
        name: "caseRef",
        isAttr: true,
        type: "String"
      },
      {
        name: "caseBinding",
        isAttr: true,
        type: "String",
        "default": "latest"
      },
      {
        name: "caseVersion",
        isAttr: true,
        type: "String"
      },
      {
        name: "caseTenantId",
        isAttr: true,
        type: "String"
      },
      {
        name: "variableMappingClass",
        isAttr: true,
        type: "String"
      },
      {
        name: "variableMappingDelegateExpression",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ServiceTaskLike",
    "extends": [
      "bpmn:ServiceTask",
      "bpmn:BusinessRuleTask",
      "bpmn:SendTask",
      "bpmn:MessageEventDefinition"
    ],
    properties: [
      {
        name: "expression",
        isAttr: true,
        type: "String"
      },
      {
        name: "class",
        isAttr: true,
        type: "String"
      },
      {
        name: "delegateExpression",
        isAttr: true,
        type: "String"
      },
      {
        name: "resultVariable",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "DmnCapable",
    "extends": [
      "bpmn:BusinessRuleTask"
    ],
    properties: [
      {
        name: "decisionRef",
        isAttr: true,
        type: "String"
      },
      {
        name: "decisionRefBinding",
        isAttr: true,
        type: "String",
        "default": "latest"
      },
      {
        name: "decisionRefVersion",
        isAttr: true,
        type: "String"
      },
      {
        name: "mapDecisionResult",
        isAttr: true,
        type: "String",
        "default": "resultList"
      },
      {
        name: "decisionRefTenantId",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ExternalCapable",
    "extends": [
      "camunda:ServiceTaskLike"
    ],
    properties: [
      {
        name: "type",
        isAttr: true,
        type: "String"
      },
      {
        name: "topic",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "TaskPriorized",
    "extends": [
      "bpmn:Process",
      "camunda:ExternalCapable"
    ],
    properties: [
      {
        name: "taskPriority",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Properties",
    superClass: [
      "Element"
    ],
    meta: {
      allowedIn: [
        "*"
      ]
    },
    properties: [
      {
        name: "values",
        type: "Property",
        isMany: true
      }
    ]
  },
  {
    name: "Property",
    superClass: [
      "Element"
    ],
    properties: [
      {
        name: "id",
        type: "String",
        isAttr: true
      },
      {
        name: "name",
        type: "String",
        isAttr: true
      },
      {
        name: "value",
        type: "String",
        isAttr: true
      }
    ]
  },
  {
    name: "Connector",
    superClass: [
      "Element"
    ],
    meta: {
      allowedIn: [
        "camunda:ServiceTaskLike"
      ]
    },
    properties: [
      {
        name: "inputOutput",
        type: "InputOutput"
      },
      {
        name: "connectorId",
        type: "String"
      }
    ]
  },
  {
    name: "InputOutput",
    superClass: [
      "Element"
    ],
    meta: {
      allowedIn: [
        "bpmn:FlowNode",
        "camunda:Connector"
      ]
    },
    properties: [
      {
        name: "inputOutput",
        type: "InputOutput"
      },
      {
        name: "connectorId",
        type: "String"
      },
      {
        name: "inputParameters",
        isMany: true,
        type: "InputParameter"
      },
      {
        name: "outputParameters",
        isMany: true,
        type: "OutputParameter"
      }
    ]
  },
  {
    name: "InputOutputParameter",
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "value",
        isBody: true,
        type: "String"
      },
      {
        name: "definition",
        type: "InputOutputParameterDefinition"
      }
    ]
  },
  {
    name: "InputOutputParameterDefinition",
    isAbstract: true
  },
  {
    name: "List",
    superClass: [
      "InputOutputParameterDefinition"
    ],
    properties: [
      {
        name: "items",
        isMany: true,
        type: "InputOutputParameterDefinition"
      }
    ]
  },
  {
    name: "Map",
    superClass: [
      "InputOutputParameterDefinition"
    ],
    properties: [
      {
        name: "entries",
        isMany: true,
        type: "Entry"
      }
    ]
  },
  {
    name: "Entry",
    properties: [
      {
        name: "key",
        isAttr: true,
        type: "String"
      },
      {
        name: "value",
        isBody: true,
        type: "String"
      },
      {
        name: "definition",
        type: "InputOutputParameterDefinition"
      }
    ]
  },
  {
    name: "Value",
    superClass: [
      "InputOutputParameterDefinition"
    ],
    properties: [
      {
        name: "id",
        isAttr: true,
        type: "String"
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "value",
        isBody: true,
        type: "String"
      }
    ]
  },
  {
    name: "Script",
    superClass: [
      "InputOutputParameterDefinition"
    ],
    properties: [
      {
        name: "scriptFormat",
        isAttr: true,
        type: "String"
      },
      {
        name: "resource",
        isAttr: true,
        type: "String"
      },
      {
        name: "value",
        isBody: true,
        type: "String"
      }
    ]
  },
  {
    name: "Field",
    superClass: [
      "Element"
    ],
    meta: {
      allowedIn: [
        "camunda:ServiceTaskLike",
        "camunda:ExecutionListener",
        "camunda:TaskListener"
      ]
    },
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "expression",
        type: "String"
      },
      {
        name: "stringValue",
        isAttr: true,
        type: "String"
      },
      {
        name: "string",
        type: "String"
      }
    ]
  },
  {
    name: "InputParameter",
    superClass: [
      "InputOutputParameter"
    ]
  },
  {
    name: "OutputParameter",
    superClass: [
      "InputOutputParameter"
    ]
  },
  {
    name: "Collectable",
    isAbstract: true,
    "extends": [
      "bpmn:MultiInstanceLoopCharacteristics"
    ],
    superClass: [
      "camunda:AsyncCapable"
    ],
    properties: [
      {
        name: "collection",
        isAttr: true,
        type: "String"
      },
      {
        name: "elementVariable",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "FailedJobRetryTimeCycle",
    superClass: [
      "Element"
    ],
    meta: {
      allowedIn: [
        "camunda:AsyncCapable",
        "bpmn:MultiInstanceLoopCharacteristics"
      ]
    },
    properties: [
      {
        name: "body",
        isBody: true,
        type: "String"
      }
    ]
  },
  {
    name: "ExecutionListener",
    superClass: [
      "Element"
    ],
    meta: {
      allowedIn: [
        "bpmn:Task",
        "bpmn:ServiceTask",
        "bpmn:UserTask",
        "bpmn:BusinessRuleTask",
        "bpmn:ScriptTask",
        "bpmn:ReceiveTask",
        "bpmn:ManualTask",
        "bpmn:ExclusiveGateway",
        "bpmn:SequenceFlow",
        "bpmn:ParallelGateway",
        "bpmn:InclusiveGateway",
        "bpmn:EventBasedGateway",
        "bpmn:StartEvent",
        "bpmn:IntermediateCatchEvent",
        "bpmn:IntermediateThrowEvent",
        "bpmn:EndEvent",
        "bpmn:BoundaryEvent",
        "bpmn:CallActivity",
        "bpmn:SubProcess",
        "bpmn:Process"
      ]
    },
    properties: [
      {
        name: "expression",
        isAttr: true,
        type: "String"
      },
      {
        name: "class",
        isAttr: true,
        type: "String"
      },
      {
        name: "delegateExpression",
        isAttr: true,
        type: "String"
      },
      {
        name: "event",
        isAttr: true,
        type: "String"
      },
      {
        name: "script",
        type: "Script"
      },
      {
        name: "fields",
        type: "Field",
        isMany: true
      }
    ]
  },
  {
    name: "TaskListener",
    superClass: [
      "Element"
    ],
    meta: {
      allowedIn: [
        "bpmn:UserTask"
      ]
    },
    properties: [
      {
        name: "expression",
        isAttr: true,
        type: "String"
      },
      {
        name: "class",
        isAttr: true,
        type: "String"
      },
      {
        name: "delegateExpression",
        isAttr: true,
        type: "String"
      },
      {
        name: "event",
        isAttr: true,
        type: "String"
      },
      {
        name: "script",
        type: "Script"
      },
      {
        name: "fields",
        type: "Field",
        isMany: true
      },
      {
        name: "id",
        type: "String",
        isAttr: true
      },
      {
        name: "eventDefinitions",
        type: "bpmn:TimerEventDefinition",
        isMany: true
      }
    ]
  },
  {
    name: "FormProperty",
    superClass: [
      "Element"
    ],
    meta: {
      allowedIn: [
        "bpmn:StartEvent",
        "bpmn:UserTask"
      ]
    },
    properties: [
      {
        name: "id",
        type: "String",
        isAttr: true
      },
      {
        name: "name",
        type: "String",
        isAttr: true
      },
      {
        name: "type",
        type: "String",
        isAttr: true
      },
      {
        name: "required",
        type: "String",
        isAttr: true
      },
      {
        name: "readable",
        type: "String",
        isAttr: true
      },
      {
        name: "writable",
        type: "String",
        isAttr: true
      },
      {
        name: "variable",
        type: "String",
        isAttr: true
      },
      {
        name: "expression",
        type: "String",
        isAttr: true
      },
      {
        name: "datePattern",
        type: "String",
        isAttr: true
      },
      {
        name: "default",
        type: "String",
        isAttr: true
      },
      {
        name: "values",
        type: "Value",
        isMany: true
      }
    ]
  },
  {
    name: "FormData",
    superClass: [
      "Element"
    ],
    meta: {
      allowedIn: [
        "bpmn:StartEvent",
        "bpmn:UserTask"
      ]
    },
    properties: [
      {
        name: "fields",
        type: "FormField",
        isMany: true
      },
      {
        name: "businessKey",
        type: "String",
        isAttr: true
      }
    ]
  },
  {
    name: "FormField",
    superClass: [
      "Element"
    ],
    properties: [
      {
        name: "id",
        type: "String",
        isAttr: true
      },
      {
        name: "label",
        type: "String",
        isAttr: true
      },
      {
        name: "type",
        type: "String",
        isAttr: true
      },
      {
        name: "datePattern",
        type: "String",
        isAttr: true
      },
      {
        name: "defaultValue",
        type: "String",
        isAttr: true
      },
      {
        name: "properties",
        type: "Properties"
      },
      {
        name: "validation",
        type: "Validation"
      },
      {
        name: "values",
        type: "Value",
        isMany: true
      }
    ]
  },
  {
    name: "Validation",
    superClass: [
      "Element"
    ],
    properties: [
      {
        name: "constraints",
        type: "Constraint",
        isMany: true
      }
    ]
  },
  {
    name: "Constraint",
    superClass: [
      "Element"
    ],
    properties: [
      {
        name: "name",
        type: "String",
        isAttr: true
      },
      {
        name: "config",
        type: "String",
        isAttr: true
      }
    ]
  },
  {
    name: "ConditionalEventDefinitionExtension",
    isAbstract: true,
    "extends": [
      "bpmn:ConditionalEventDefinition"
    ],
    properties: [
      {
        name: "variableName",
        isAttr: true,
        type: "String"
      },
      {
        name: "variableEvents",
        isAttr: true,
        type: "String"
      }
    ]
  }
];
const emumerations = [];
const camundaModdleDescriptor = {
  name,
  uri,
  prefix,
  xml,
  associations,
  types,
  emumerations
};
const _hoisted_1 = { class: "bpmn-page" };
const _hoisted_2 = ["id"];
const defaultProcessIdAndName = "1";
const _sfc_main = /* @__PURE__ */ defineComponent({
  __name: "index",
  props: {
    bpmnID: {
      type: String,
      default: "modeler-container"
    },
    isReadOnly: {
      type: Boolean,
      default: false
    }
  },
  emits: ["select:element", "data:change"],
  setup(__props, { expose: __expose, emit: __emit }) {
    let props = __props;
    let emits = __emit;
    const bpmnStore = reactive(
      new BPMN({
        dataChange: (_oldVal, newVal) => {
          emits("data:change", { businessObject: newVal });
        }
      })
    );
    onMounted(() => {
      if (props.isReadOnly) {
        bpmnStore.initModeler({
          container: `#${props.bpmnID}`,
          additionalModules: [
            //添加翻译
            {
              translate: ["value", getI18nTranslate("zh")],
              paletteProvider: ["value", ""],
              //禁用/清空左侧工具栏
              labelEditingProvider: ["value", ""],
              //禁用节点编辑
              contextPadProvider: ["value", ""],
              //禁用图形菜单
              bendpoints: ["value", {}],
              //禁用连线拖动
              zoomScroll: ["value", ""],
              //禁用滚动
              moveCanvas: ["value", ""],
              //禁用拖动整个流程图
              move: ["value", ""]
              //禁用单个图形拖动
            }
            // customPalette,
            // paletteProvider,
            // CustomContextPadProvider,
            // customContextPad,
            // customRender,
          ],
          moddleExtensions: {
            // activiti: activitiModdel,
            camunda: camundaModdleDescriptor
          }
        });
      } else {
        bpmnStore.initModeler({
          container: `#${props.bpmnID}`,
          additionalModules: [
            //添加翻译
            { translate: ["value", getI18nTranslate("zh")] },
            // customPalette,
            paletteProvider,
            CustomContextPadProvider
            // customContextPad,
            // customRender,
          ],
          moddleExtensions: {
            // activiti: activitiModdel,
            camunda: camundaModdleDescriptor
          }
        });
      }
      bpmnStore.importXML(
        createDefaultBpmnXml(defaultProcessIdAndName, defaultProcessIdAndName)
      ).then((result) => {
        if (result.length) {
          console.warn("importSuccess warnings", result);
        }
      }).catch((err) => {
        console.warn("importFail errors ", err);
      });
    });
    watch(
      () => bpmnStore.activeElementID,
      (_newVal) => {
        if (!bpmnStore.getShapeById(bpmnStore.activeElementID)) {
          bpmnStore.setActiveElement(void 0);
          bpmnStore.setType(void 0);
          return;
        }
        let businessObject = bpmnStore.getBusinessObject() || void 0;
        if ([
          "bpmn:StartEvent",
          "bpmn:ExclusiveGateway",
          "bpmn:SequenceFlow"
        ].includes(bpmnStore.getShapeType())) {
          emits("select:element", {
            businessObject,
            shapeType: bpmnStore.getShapeType()
          });
          return;
        }
        emits("select:element", {
          businessObject: void 0,
          shapeType: bpmnStore.getShapeType()
        });
      },
      {
        deep: true
      }
    );
    onBeforeUnmount(() => {
      bpmnStore.resetData();
    });
    __expose({
      bpmnStore
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1, [
        createElementVNode("div", {
          id: __props.bpmnID,
          class: "modeler-container"
        }, null, 8, _hoisted_2)
      ]);
    };
  }
});
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const BpmnVue = /* @__PURE__ */ _export_sfc(_sfc_main, [["__scopeId", "data-v-005514a3"]]);
function useBpmn() {
  return new BPMN();
}
BpmnVue.name = "Bpmn-Vue";
BpmnVue.install = function(app) {
  app.component(BpmnVue.name, BpmnVue);
};
const components = [BpmnVue];
const install = function(Vue) {
  if (install.installed)
    return;
  install.installed = true;
  components.map((component) => {
    Vue.component(component.name, component);
  });
};
if (typeof window !== "undefined" && window.Vue) {
  install(window.Vue);
}
const index = {
  // 导出的对象必须具备一个 install 方法
  install
};
export {
  BpmnVue,
  index as default,
  useBpmn
};
